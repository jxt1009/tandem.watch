{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://tandem.watch/./chrome-extension/src/managers/sync/lock.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/SyncManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://tandem.watch/./chrome-extension/src/content/main.js","webpack://tandem.watch/./chrome-extension/src/managers/state/StateManager.js","webpack://tandem.watch/./chrome-extension/src/ui/UIManager.js","webpack://tandem.watch/./chrome-extension/src/content/netflix/NetflixController.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/eventListeners.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/ui.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/reconnect.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/signaling.js","webpack://tandem.watch/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\n  constructor() {\n    this.suppressLocalUntil = 0;\n  }\n  set(durationMs) {\n    this.suppressLocalUntil = Date.now() + durationMs;\n  }\n  isActive() {\n    return Date.now() < this.suppressLocalUntil;\n  }\n}\n","import { SyncLock } from './lock.js';\nimport { attachPlaybackListeners } from './eventListeners.js';\nimport { createRemoteHandlers } from './remoteHandlers.js';\n\nclass MutableRef {\n  constructor(value) { this.value = value; }\n  get() { return this.value; }\n  set(v) { this.value = v; }\n}\n\nexport class SyncManager {\n  constructor(stateManager, netflixController) {\n    this.state = stateManager;\n    this.netflix = netflixController;\n    this.lock = new SyncLock();\n    this.isInitializedRef = new MutableRef(false);\n    this.listeners = null;\n    this.initialSyncRequestAt = 0;\n    this.initialSyncWindowMs = 8000;\n    this.lastKnownTimeSeconds = 0;\n    this.videoMonitorInterval = null;\n    this.activeVideo = null;\n    this.urlSync = null;\n    this.hostUserId = null;\n    this.heartbeatInterval = null;\n\n    this.remote = createRemoteHandlers({\n      state: this.state,\n      netflix: this.netflix,\n      lock: this.lock,\n      isInitializedRef: this.isInitializedRef,\n      urlSync: () => this.urlSync,\n      shouldAcceptLateSync: () => {\n        if (!this.initialSyncRequestAt) return false;\n        return (Date.now() - this.initialSyncRequestAt) < this.initialSyncWindowMs;\n      },\n      onInitialSyncApplied: () => {\n        this.initialSyncRequestAt = 0;\n      }\n    });\n  }\n\n  setUrlSync(urlSync) {\n    this.urlSync = urlSync;\n  }\n\n  async setup() {\n    try {\n      // Only setup sync manager on /watch pages\n      if (!window.location.pathname.startsWith('/watch')) {\n        console.log('[SyncManager] Not on /watch page, skipping setup');\n        return;\n      }\n      \n      console.log('[SyncManager] Starting setup - waiting for video element...');\n      const video = await this.waitForVideo();\n      if (!video) { \n        console.warn('[SyncManager] Netflix video element not found'); \n        return; \n      }\n      \n      console.log('[SyncManager] Video element found, setting up event listeners');\n      this.activeVideo = video;\n      \n      // Check for pending seek time from URL change (episode selection)\n      const pendingSeekTime = sessionStorage.getItem('tandem_pending_seek_time');\n      if (pendingSeekTime) {\n        try {\n          const seekTime = parseFloat(pendingSeekTime);\n          console.log('[SyncManager] Applying pending seek from URL initiator:', seekTime);\n          sessionStorage.removeItem('tandem_pending_seek_time');\n          \n          // Wait for video to be ready, then seek to initiator's position\n          await this.waitForVideoReady(video);\n          this.lock.set(2000);\n          await this.netflix.seek(seekTime * 1000);\n          console.log('[SyncManager] Seeked to initiator time:', seekTime);\n        } catch (e) {\n          console.error('[SyncManager] Error applying pending seek time:', e);\n          sessionStorage.removeItem('tandem_pending_seek_time');\n        }\n      }\n      \n      // Check for pending sync from URL navigation\n      const pendingSyncStr = sessionStorage.getItem('tandem_pending_sync');\n      if (pendingSyncStr) {\n        try {\n          const pendingSync = JSON.parse(pendingSyncStr);\n          if (Date.now() - pendingSync.timestamp < 10000) {\n            console.log('[SyncManager] Applying pending sync from URL navigation');\n            sessionStorage.removeItem('tandem_pending_sync');\n            this.isInitializedRef.set(true);\n            this.initialSyncRequestAt = 0;\n            \n            // Apply the pending sync state\n            this.lock.set(1500);\n            await this.netflix.seek(pendingSync.currentTime * 1000);\n            const isPaused = await this.netflix.isPaused();\n            if (pendingSync.isPlaying && isPaused) {\n              await this.netflix.play();\n            } else if (!pendingSync.isPlaying && !isPaused) {\n              await this.netflix.pause();\n            }\n            \n            this.attachListeners(video);\n            this.startVideoMonitor();\n            console.log('[SyncManager] Setup complete with pending sync applied');\n            return;\n          } else {\n            console.log('[SyncManager] Pending sync expired, ignoring');\n            sessionStorage.removeItem('tandem_pending_sync');\n          }\n        } catch (e) {\n          console.error('[SyncManager] Error applying pending sync:', e);\n          sessionStorage.removeItem('tandem_pending_sync');\n        }\n      }\n      \n      this.isInitializedRef.set(false);\n      \n      // Check if we just navigated from browse - if so, respect Netflix's natural behavior\n      // and become the leader that others sync to\n      const fromBrowse = sessionStorage.getItem('tandem_from_browse');\n      if (fromBrowse === 'true') {\n        console.log('[SyncManager] Just navigated from browse - becoming leader, will broadcast state once video is ready');\n        sessionStorage.removeItem('tandem_from_browse');\n        // Mark as initialized immediately so we start broadcasting our state\n        this.isInitializedRef.set(true);\n        this.initialSyncRequestAt = 0;\n        \n        // Wait for Netflix resume event before broadcasting state\n        const broadcastAfterResume = () => {\n          let resumed = false;\n          let timeoutId = null;\n          \n          const broadcast = async (source) => {\n            if (resumed) return;\n            resumed = true;\n            \n            // Clean up listeners\n            video.removeEventListener('seeked', onSeeked);\n            video.removeEventListener('timeupdate', onTimeUpdate);\n            if (timeoutId) clearTimeout(timeoutId);\n            \n            try {\n              const currentTime = await this.netflix.getCurrentTime();\n              const isPaused = await this.netflix.isPaused();\n              const currentTimeSeconds = currentTime != null ? currentTime / 1000 : 0;\n              console.log('[SyncManager] Broadcasting initial state as leader from', source + ':', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing');\n              \n              // Send full sync message with timestamp, not just play/pause\n              this.state.safeSendMessage({ \n                type: 'SEEK', \n                currentTime: currentTimeSeconds,\n                isPlaying: !isPaused,\n                eventTimestamp: Date.now()\n              });\n            } catch (e) {\n              console.error('[SyncManager] Error broadcasting leader state:', e);\n            }\n          };\n          \n          // Listen for seeked event (Netflix resuming to saved position)\n          const onSeeked = async () => {\n            const currentTime = await this.netflix.getCurrentTime();\n            if (currentTime != null && currentTime > 5000) {\n              console.log('[SyncManager] Detected resume via seeked event at', (currentTime / 1000).toFixed(2) + 's');\n              broadcast('seeked');\n            }\n          };\n          \n          // Listen for timeupdate as fallback\n          const onTimeUpdate = async () => {\n            const currentTime = await this.netflix.getCurrentTime();\n            if (currentTime != null && currentTime > 5000) {\n              console.log('[SyncManager] Detected resume via timeupdate at', (currentTime / 1000).toFixed(2) + 's');\n              broadcast('timeupdate');\n            }\n          };\n          \n          video.addEventListener('seeked', onSeeked);\n          video.addEventListener('timeupdate', onTimeUpdate);\n          \n          // Fallback timeout (8 seconds)\n          timeoutId = setTimeout(() => {\n            console.log('[SyncManager] Resume timeout reached, broadcasting current state');\n            broadcast('timeout');\n          }, 8000);\n          \n          // Check immediately if already at resume position\n          this.netflix.getCurrentTime().then(currentTime => {\n            if (currentTime != null && currentTime > 5000) {\n              console.log('[SyncManager] Already at resume position:', (currentTime / 1000).toFixed(2) + 's');\n              broadcast('immediate');\n            }\n          });\n        };\n        \n        // Start waiting for resume\n        if (video.readyState >= 3) {\n          console.log('[SyncManager] Video ready, waiting for Netflix resume event');\n          broadcastAfterResume();\n        } else {\n          console.log('[SyncManager] Waiting for video ready before resume detection');\n          const onVideoReady = () => {\n            video.removeEventListener('canplay', onVideoReady);\n            console.log('[SyncManager] Video ready, waiting for Netflix resume event');\n            broadcastAfterResume();\n          };\n          video.addEventListener('canplay', onVideoReady);\n          setTimeout(() => {\n            video.removeEventListener('canplay', onVideoReady);\n            console.log('[SyncManager] Video ready timeout, starting resume detection anyway');\n            broadcastAfterResume();\n          }, 3000);\n        }\n      } else {\n        // Wait for video to be ready before requesting sync\n        const requestSyncWhenReady = () => {\n          console.log('[SyncManager] Video ready - requesting initial sync from other clients');\n          this.initialSyncRequestAt = Date.now();\n          this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\n          \n          // If no response after 2 seconds, consider ourselves initialized\n          setTimeout(() => {\n            if (!this.isInitializedRef.get()) {\n              console.log('[SyncManager] No sync response received after 2s, marking as initialized (will still accept late sync briefly)');\n              this.isInitializedRef.set(true);\n              console.log('[SyncManager] isInitialized is now:', this.isInitializedRef.get());\n            } else {\n              console.log('[SyncManager] Already initialized, skipping timeout initialization');\n            }\n          }, 2000);\n        };\n        \n        const onVideoReady = () => {\n          console.log('[SyncManager] Video canplay event fired');\n          video.removeEventListener('canplay', onVideoReady);\n          requestSyncWhenReady();\n        };\n        \n        // If video is already ready, request sync immediately\n        if (video.readyState >= 3) { // HAVE_FUTURE_DATA or better\n          console.log('[SyncManager] Video already ready (readyState:', video.readyState + ')');\n          requestSyncWhenReady();\n        } else {\n          console.log('[SyncManager] Waiting for video to be ready before requesting sync (readyState:', video.readyState + ')');\n          video.addEventListener('canplay', onVideoReady);\n          // Fallback timeout\n          setTimeout(() => {\n            video.removeEventListener('canplay', onVideoReady);\n            console.log('[SyncManager] Timeout reached, requesting sync anyway');\n            requestSyncWhenReady();\n          }, 5000);\n        }\n      }\n      \n      this.attachListeners(video);\n      this.startVideoMonitor();\n      console.log('[SyncManager] Setup complete - ready to sync');\n    } catch (err) { \n      console.error('[SyncManager] Error setting up playback sync:', err); \n    }\n  }\n\n  attachListeners(video) {\n    // Clean up old listeners first (in case of re-setup)\n    if (this.listeners && this.listeners.cleanup) {\n      try {\n        const { handlePlay, handlePause, handleSeeked } = this.listeners;\n        if (this.listeners.video) {\n          this.listeners.video.removeEventListener('play', handlePlay);\n          this.listeners.video.removeEventListener('pause', handlePause);\n          this.listeners.video.removeEventListener('seeked', handleSeeked);\n        }\n        this.listeners.cleanup();\n        console.log('[SyncManager] Cleaned up old listeners before attaching new ones');\n      } catch (e) {\n        console.warn('[SyncManager] Error cleaning up old listeners:', e);\n      }\n    }\n\n    const listeners = attachPlaybackListeners({\n      video,\n      state: this.state,\n      isInitializedRef: this.isInitializedRef,\n      lock: this.lock,\n      onPlay: (vid) => this.broadcastPlay(vid),\n      onPause: (vid) => this.broadcastPause(vid),\n      onSeek: (vid) => this.broadcastSeek(vid),\n      onPositionUpdate: (vid) => this.broadcastPosition(vid)\n    });\n    this.listeners = listeners;\n  }\n\n  startVideoMonitor() {\n    if (this.videoMonitorInterval) return;\n    this.videoMonitorInterval = setInterval(() => {\n      if (!this.isOnWatchPage()) return;\n      const currentVideo = this.netflix.getVideoElement();\n      if (currentVideo && currentVideo !== this.activeVideo) {\n        console.log('[SyncManager] Detected new Netflix video element, reattaching listeners');\n        this.activeVideo = currentVideo;\n        this.attachListeners(currentVideo);\n      }\n    }, 1000);\n  }\n\n  teardown() {\n    console.log('[SyncManager] Tearing down sync manager');\n    if (this.listeners) {\n      const { video, handlePlay, handlePause, handleSeeked, cleanup } = this.listeners;\n      try {\n        video.removeEventListener('play', handlePlay);\n        video.removeEventListener('pause', handlePause);\n        video.removeEventListener('seeked', handleSeeked);\n        if (cleanup) cleanup(); // Clear the position update interval\n        console.log('[SyncManager] Event listeners removed');\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\n      this.listeners = null;\n    }\n    if (this.videoMonitorInterval) {\n      clearInterval(this.videoMonitorInterval);\n      this.videoMonitorInterval = null;\n    }\n    this.activeVideo = null;\n    this.isInitializedRef.set(false);\n    this.stopHostHeartbeat();\n  }\n\n  waitForVideo() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\n      const check = () => {\n        const video = this.netflix.getVideoElement();\n        if (video) { clearTimeout(timeout); resolve(video); }\n        else { setTimeout(check, 100); }\n      };\n      check();\n    });\n  }\n\n  isOnWatchPage() {\n    return window.location.pathname.startsWith('/watch');\n  }\n\n  async broadcastPlay(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\n      return;\n    }\n    try {\n      const currentTimeMs = await this.netflix.getCurrentTime();\n      const currentTime = currentTimeMs != null ? currentTimeMs / 1000 : (video?.currentTime || 0);\n      console.log('[SyncManager] Broadcasting PLAY event at', currentTime.toFixed(2) + 's');\n      this.state.safeSendMessage({ \n        type: 'PLAY_PAUSE', \n        control: 'play',\n        currentTime: currentTime,\n        eventTimestamp: Date.now()\n      });\n    } catch (e) {\n      console.warn('[SyncManager] Error broadcasting play:', e);\n      this.state.safeSendMessage({ \n        type: 'PLAY_PAUSE', \n        control: 'play',\n        currentTime: video?.currentTime || 0,\n        eventTimestamp: Date.now()\n      });\n    }\n  }\n\n  async broadcastPause(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\n      return;\n    }\n    try {\n      const currentTimeMs = await this.netflix.getCurrentTime();\n      const currentTime = currentTimeMs != null ? currentTimeMs / 1000 : (video?.currentTime || 0);\n      console.log('[SyncManager] Broadcasting PAUSE event at', currentTime.toFixed(2) + 's');\n      this.state.safeSendMessage({ \n        type: 'PLAY_PAUSE', \n        control: 'pause',\n        currentTime: currentTime,\n        eventTimestamp: Date.now()\n      });\n    } catch (e) {\n      console.warn('[SyncManager] Error broadcasting pause:', e);\n      this.state.safeSendMessage({ \n        type: 'PLAY_PAUSE', \n        control: 'pause',\n        currentTime: video?.currentTime || 0,\n        eventTimestamp: Date.now()\n      });\n    }\n  }\n\n  broadcastSeek(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\n    this.state.safeSendMessage({ \n      type: 'SEEK', \n      currentTime: video.currentTime, \n      isPlaying: !video.paused,\n      eventTimestamp: Date.now()\n    });\n  }\n\n  broadcastPosition(video) {\n    if (!this.isOnWatchPage()) {\n      return;\n    }\n    // Send continuous position update for live timestamp tracking\n    // Use Netflix controller for accurate time (video.currentTime can be 0 on Netflix)\n    this.netflix.getCurrentTime().then((currentTimeMs) => {\n      let currentTime = null;\n      if (currentTimeMs != null) {\n        currentTime = currentTimeMs / 1000;\n      }\n\n      // Fallback to video element time if Netflix API not ready\n      if ((currentTime == null || currentTime === 0) && video?.currentTime > 0) {\n        currentTime = video.currentTime;\n      }\n\n      // If still zero, keep last known time to avoid resetting to 0\n      if (currentTime == null || currentTime === 0) {\n        currentTime = this.lastKnownTimeSeconds || 0;\n      } else {\n        this.lastKnownTimeSeconds = currentTime;\n      }\n\n      if (currentTime === 0) return;\n      this.state.safeSendMessage({ \n        type: 'POSITION_UPDATE', \n        currentTime, \n        isPlaying: !video.paused \n      });\n    }).catch((err) => {\n      console.warn('[SyncManager] Failed to read currentTime for POSITION_UPDATE:', err);\n    });\n  }\n\n  // Remote event handlers\n  handleRequestSync(fromUserId, respectAutoPlay) { return this.remote.handleRequestSync(fromUserId, respectAutoPlay); }\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay) {\n    // Only handle sync responses on /watch pages to avoid preview videos interfering\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring sync response - not on /watch page');\n      return;\n    }\n    return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay);\n  }\n  handlePlaybackControl(control, currentTime, fromUserId, eventTimestamp) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId, eventTimestamp); }\n  handleSeek(currentTime, isPlaying, fromUserId, eventTimestamp) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId, eventTimestamp); }\n  handleSeekPause(currentTime, fromUserId) { return this.remote.handleSeekPause(currentTime, fromUserId); }\n  handleHostHeartbeat(currentTime, isPlaying, fromUserId, eventTimestamp) { return this.remote.handleHostHeartbeat(currentTime, isPlaying, fromUserId, eventTimestamp); }\n\n  setHostUserId(hostUserId) {\n    this.hostUserId = hostUserId;\n    this.updateHostHeartbeat();\n  }\n\n  updateHostHeartbeat() {\n    const localUserId = this.state.getUserId();\n    if (this.hostUserId && localUserId && this.hostUserId === localUserId) {\n      this.startHostHeartbeat();\n    } else {\n      this.stopHostHeartbeat();\n    }\n  }\n\n  startHostHeartbeat() {\n    if (this.heartbeatInterval) return;\n    this.heartbeatInterval = setInterval(async () => {\n      if (!this.isOnWatchPage() || !this.isInitializedRef.get()) return;\n      const currentTimeMs = await this.netflix.getCurrentTime();\n      let currentTime = Number.isFinite(currentTimeMs) ? (currentTimeMs / 1000) : null;\n      if (currentTime == null) {\n        const video = this.netflix.getVideoElement();\n        currentTime = video?.currentTime || 0;\n      }\n      const video = this.netflix.getVideoElement();\n      const isPlaying = video ? !video.paused : true;\n      this.state.safeSendMessage({\n        type: 'HOST_HEARTBEAT',\n        currentTime,\n        isPlaying,\n        eventTimestamp: Date.now()\n      });\n    }, 3000);\n  }\n\n  stopHostHeartbeat() {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n}\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft, showReconnecting, hideOverlay, showPlaceholder }) {\n  return function createPeerConnection(peerId) {\n    console.log('[PeerConnection] Creating peer connection for peerId:', peerId);\n    \n    // Ensure any existing video/container AND stream is removed before creating placeholder\n    // This prevents duplicates when rapidly recreating connections (like force refresh)\n    removeRemoteVideo(peerId);\n    remoteStreams.delete(peerId); // Also clear the stream\n    \n    // Show placeholder immediately when peer connection is created\n    showPlaceholder(peerId);\n    \n    const state = stateManager.getState();\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: ['stun:stun.l.google.com:19302'] },\n        { urls: ['stun:stun1.l.google.com:19302'] }\n      ]\n    });\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\n      }\n    };\n    pc.ontrack = (event) => {\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\n      if (!stream) {\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\n        stream = new MediaStream();\n        remoteStreams.set(peerId, stream);\n      }\n      if (event.track) {\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\n        try { \n          // Check if track already exists in stream to prevent duplicates\n          const existingTrack = stream.getTracks().find(t => t.id === event.track.id);\n          if (!existingTrack) {\n            stream.addTrack(event.track);\n          } else {\n            console.log('[PeerConnection] Track already in stream, skipping');\n          }\n        } catch (e) {\n          console.warn('[PeerConnection] Error adding track:', e);\n        }\n      }\n      \n      // Check if video element exists\n      const hasVideoInMap = remoteVideos.has(peerId);\n      const hasVideoInDom = !!document.getElementById('tandem-remote-' + peerId);\n      const videoExists = hasVideoInMap || hasVideoInDom;\n      \n      if (videoExists) {\n        console.log('[PeerConnection] Video already exists for peer:', peerId, 'inMap:', hasVideoInMap, 'inDom:', hasVideoInDom);\n        // Update the existing video element's stream if it's different\n        const existingVideo = remoteVideos.get(peerId) || document.getElementById('tandem-remote-' + peerId);\n        if (existingVideo && existingVideo.srcObject !== stream) {\n          console.log('[PeerConnection] Updating existing video element with new stream');\n          existingVideo.srcObject = stream;\n          // Ensure it's tracked in the map\n          if (!hasVideoInMap) {\n            remoteVideos.set(peerId, existingVideo);\n          }\n        }\n      } else {\n        // Wait for both audio and video tracks before creating video element\n        const tracks = stream.getTracks();\n        const hasAudio = tracks.some(t => t.kind === 'audio');\n        const hasVideo = tracks.some(t => t.kind === 'video');\n        \n        console.log('[PeerConnection] Stream status - audio:', hasAudio, 'video:', hasVideo, 'total tracks:', tracks.length);\n        \n        // Only create video element when we have both tracks\n        if (hasAudio && hasVideo) {\n          console.log('[PeerConnection] Both tracks present, adding remote video for peer:', peerId);\n          addRemoteVideo(peerId, stream);\n        } else {\n          console.log('[PeerConnection] Waiting for more tracks before creating video element');\n        }\n      }\n    };\n    pc.onconnectionstatechange = () => {\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, '', pc.connectionState);\n      if (pc.connectionState === 'connected') {\n        clearReconnection(peerId);\n        hideOverlay(peerId);\n      } else if (pc.connectionState === 'disconnected') {\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          // Keep video visible while reconnecting - don't remove immediately\n          console.log('[PeerConnection] Connection disconnected, attempting reconnection while keeping video visible');\n          showReconnecting(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'failed') {\n        console.log('[PeerConnection] Connection failed for peer:', peerId);\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          // Remove video on failed state and try to reconnect\n          removeRemoteVideo(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'closed') {\n        removeRemoteVideo(peerId);\n        clearReconnection(peerId);\n      }\n    };\n    return pc;\n  };\n}\n\nexport function addOrReplaceTrack(pc, track, stream) {\n  const senders = pc.getSenders();\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n  if (existingSender) {\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\n  } else {\n    try { pc.addTrack(track, stream); } catch (e) {}\n  }\n}\n","import { StateManager } from '../managers/state/StateManager.js';\nimport { NetflixController } from './netflix/NetflixController.js';\nimport { SyncManager } from '../managers/sync/SyncManager.js';\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\nimport { UIManager } from '../ui/UIManager.js';\nimport { URLSync } from '../managers/url/URLSync.js';\n\nconsole.log('[Content Script] Initializing managers...');\n\n// Don't clean up stale elements on navigation - they should persist\n// Only clean up if party is not active\nconst wasPartyActive = sessionStorage.getItem('tandem_was_active') === 'true';\nif (!wasPartyActive) {\n  console.log('[Content Script] No active party detected, cleaning up stale elements...');\n  const staleContainers = document.querySelectorAll('[id^=\"tandem-container-\"]');\n  const staleVideos = document.querySelectorAll('[id^=\"tandem-remote-\"]');\n  const staleOverlays = document.querySelectorAll('[id^=\"tandem-overlay-\"]');\n  const staleLocalVideo = document.getElementById('tandem-local-preview');\n  const staleWaitingIndicator = document.getElementById('tandem-waiting-indicator');\n\n  staleContainers.forEach(el => {\n    console.log('[Content Script] Removing stale container:', el.id);\n    el.remove();\n  });\n  staleVideos.forEach(el => {\n    console.log('[Content Script] Removing stale video:', el.id);\n    el.remove();\n  });\n  staleOverlays.forEach(el => {\n    console.log('[Content Script] Removing stale overlay:', el.id);\n    el.remove();\n  });\n  if (staleLocalVideo) {\n    console.log('[Content Script] Removing stale local video');\n    staleLocalVideo.remove();\n  }\n  if (staleWaitingIndicator) {\n    console.log('[Content Script] Removing stale waiting indicator');\n    staleWaitingIndicator.remove();\n  }\n} else {\n  console.log('[Content Script] Party is active, keeping existing video elements');\n}\n\nconst stateManager = new StateManager();\nconst uiManager = new UIManager();\nconst netflixController = new NetflixController();\nconst syncManager = new SyncManager(stateManager, netflixController);\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\n\n// Callback when we navigate to a different /watch page\nconst handleWatchPageChange = () => {\n  console.log('[Content Script] Watch page changed - reinitializing sync manager');\n  const state = stateManager.getState();\n  if (state.partyActive) {\n    console.log('[Content Script] Party is active, reinitializing sync manager');\n    syncManager.teardown();\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to reinitialize sync manager:', err);\n    });\n  } else {\n    console.log('[Content Script] Party not active, skipping sync manager reinitialization');\n  }\n};\n\n// Also initialize sync manager when navigating TO a watch page (not just between watch pages)\nconst handleNavigationToWatch = () => {\n  console.log('[Content Script] Navigated to /watch page');\n  const state = stateManager.getState();\n  if (state.partyActive) {\n    console.log('[Content Script] Party is active, initializing sync manager');\n    syncManager.teardown();\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to initialize sync manager:', err);\n    });\n  }\n};\n\n// Teardown sync manager when leaving a watch page\nconst handleLeaveWatch = () => {\n  console.log('[Content Script] Left /watch page');\n  syncManager.teardown();\n};\n\nconst urlSync = new URLSync(stateManager, handleWatchPageChange, handleNavigationToWatch, handleLeaveWatch, netflixController);\nsyncManager.setUrlSync(urlSync);\nconsole.log('[Content Script] Managers initialized');\n\nfunction checkJoinFromLink() {\n  const state = stateManager.getState();\n  if (state.partyActive) {\n    return;\n  }\n\n  try {\n    const url = new URL(window.location.href);\n    const roomId = url.searchParams.get('tandemRoom');\n    if (!roomId) {\n      return;\n    }\n\n    console.log('[Content Script] Found tandemRoom in URL, joining room:', roomId);\n\n    // Extract PIN if present\n    const pin = url.searchParams.get('pin') || null;\n\n    // Clean the URL so it doesn't keep re-triggering\n    url.searchParams.delete('tandemRoom');\n    url.searchParams.delete('pin');\n    history.replaceState({}, document.title, url.toString());\n\n    chrome.runtime.sendMessage({ type: 'START_PARTY', roomId, pin }, (response) => {\n      if (response && response.success) {\n        console.log('[Content Script] Joined party from link successfully');\n      } else {\n        console.error('[Content Script] Failed to join party from link:', response ? response.error : 'Unknown error');\n      }\n    });\n  } catch (e) {\n    console.error('[Content Script] Failed to process tandemRoom in URL:', e);\n  }\n}\n\nlet localStream = null;\nlet videoElementMonitor = null;\n\n// If party was active before this page load, try to restore videos immediately\nif (wasPartyActive) {\n  console.log('[Content Script] Party was active, checking for restoration state...');\n  setTimeout(() => {\n    // Give the page a moment to initialize\n    const state = stateManager.getState();\n    if (state.partyActive && localStream) {\n      console.log('[Content Script] Restoring local preview video after navigation');\n      const existingPreview = document.getElementById('tandem-local-preview');\n      if (!existingPreview) {\n        uiManager.attachLocalPreview(localStream);\n      }\n    }\n  }, 100);\n}\n\n// Monitor and restore video elements if they get removed during navigation\nfunction startVideoElementMonitoring() {\n  if (videoElementMonitor) return;\n  \n  videoElementMonitor = setInterval(() => {\n    const state = stateManager.getState();\n    if (!state.partyActive) return;\n    \n    // Check if local preview exists\n    if (localStream && !document.getElementById('tandem-local-preview')) {\n      console.log('[Content Script] Local preview missing, re-attaching');\n      uiManager.attachLocalPreview(localStream);\n    }\n    \n    // Check if remote videos exist\n    const remoteVideos = uiManager.getRemoteVideos();\n    const remoteStreams = uiManager.getRemoteStreams();\n    remoteStreams.forEach((stream, peerId) => {\n      const videoId = 'tandem-remote-' + peerId;\n      if (!document.getElementById(videoId)) {\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\n        const videoManager = webrtcManager.videoManager;\n        if (videoManager && videoManager.add) {\n          videoManager.add(peerId, stream);\n        }\n      }\n    });\n  }, 250); // Check every 250ms for faster restoration\n  \n  console.log('[Content Script] Started video element monitoring');\n}\n\nfunction stopVideoElementMonitoring() {\n  if (videoElementMonitor) {\n    clearInterval(videoElementMonitor);\n    videoElementMonitor = null;\n    console.log('[Content Script] Stopped video element monitoring');\n  }\n}\n\ncheckJoinFromLink();\n\n(function checkRestorePartyState() {\n  const restorationState = urlSync.getRestorationState();\n  if (restorationState) {\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\n    urlSync.clearState();\n    stateManager.setRestoringFlag(true);\n    \n    setTimeout(function() {\n      console.log('[Content Script] Sending RESTORE_PARTY message');\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\n        if (response && response.success) {\n          console.log('[Content Script] Party restoration successful - setting state with userId:', response.userId);\n          // Immediately set the userId and roomId so we can handle incoming messages\n          stateManager.startParty(response.userId, response.roomId);\n          \n          // Re-obtain media stream for WebRTC signaling\n          console.log('[Content Script] Re-obtaining media stream after navigation');\n          navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n            .then(stream => {\n              console.log('[Content Script] Media stream obtained after restoration');\n              localStream = stream;\n              webrtcManager.setLocalStream(stream);\n              webrtcManager.onLocalStreamAvailable(stream);\n              uiManager.attachLocalPreview(stream);\n              \n              // Re-setup sync manager\n              syncManager.teardown();\n              syncManager.setup().catch(err => {\n                console.error('[Content Script] Failed to setup sync manager after restoration:', err);\n              });\n              \n              // Start URL monitoring if not already started\n              urlSync.start();\n              startVideoElementMonitoring();\n            })\n            .catch(err => {\n              console.error('[Content Script] Failed to get media stream after restoration:', err);\n            });\n        } else {\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\n        }\n        setTimeout(function() {\n          stateManager.setRestoringFlag(false);\n        }, 2000);\n      });\n    }, 1000);\n  }\n})();\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('[Content Script] Received message:', request.type);\n  if (request.type === 'GET_MEDIA_STATE') {\n    const audioTrack = localStream ? localStream.getAudioTracks()[0] : null;\n    const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;\n    sendResponse({\n      success: true,\n      state: {\n        audioEnabled: audioTrack ? audioTrack.enabled : false,\n        videoEnabled: videoTrack ? videoTrack.enabled : false,\n        hasStream: !!localStream,\n      },\n    });\n    return true;\n  }\n\n  if (request.type === 'TOGGLE_MIC') {\n    if (!localStream) {\n      sendResponse({ success: false, error: 'No local stream' });\n      return true;\n    }\n    const tracks = localStream.getAudioTracks();\n    if (!tracks.length) {\n      sendResponse({ success: false, error: 'No audio track' });\n      return true;\n    }\n    const newEnabled = !tracks[0].enabled;\n    tracks.forEach(t => { t.enabled = newEnabled; });\n    sendResponse({\n      success: true,\n      state: {\n        audioEnabled: newEnabled,\n        videoEnabled: localStream.getVideoTracks()[0]?.enabled ?? false,\n        hasStream: true,\n      },\n    });\n    return true;\n  }\n\n  if (request.type === 'TOGGLE_CAMERA') {\n    if (!localStream) {\n      sendResponse({ success: false, error: 'No local stream' });\n      return true;\n    }\n    const tracks = localStream.getVideoTracks();\n    if (!tracks.length) {\n      sendResponse({ success: false, error: 'No video track' });\n      return true;\n    }\n    const newEnabled = !tracks[0].enabled;\n    tracks.forEach(t => { t.enabled = newEnabled; });\n    sendResponse({\n      success: true,\n      state: {\n        audioEnabled: localStream.getAudioTracks()[0]?.enabled ?? false,\n        videoEnabled: newEnabled,\n        hasStream: true,\n      },\n    });\n    return true;\n  }\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n      .then(stream => {\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\n        localStream = stream;\n        console.log('[Content Script] Setting local stream on WebRTC manager');\n        webrtcManager.setLocalStream(stream);\n        webrtcManager.onLocalStreamAvailable(stream);\n        console.log('[Content Script] Attaching local preview to UI');\n        uiManager.attachLocalPreview(stream);\n        console.log('[Content Script] Local preview attached, sending success response');\n        sendResponse({ success: true });\n      })\n      .catch(err => {\n        console.error('[Content Script] Failed to get media stream:', err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true;\n  }\n\n  if (request.type === 'PARTY_STARTED') {\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\n    stateManager.startParty(request.userId, request.roomId);\n    \n    // Show simple connection indicator\n    uiManager.showConnectionIndicator();\n    \n    // Set Netflix volume to 15%\n    setTimeout(() => {\n      netflixController.setVolume(0.15).then(() => {\n        console.log('[Content Script] Set Netflix volume to 15%');\n      }).catch(err => {\n        console.warn('[Content Script] Failed to set volume:', err);\n      });\n    }, 1000);\n    \n    // Teardown existing sync manager if already set up\n    syncManager.teardown();\n    \n    // Setup sync manager (will wait for video element)\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to setup sync manager:', err);\n    });\n    \n    urlSync.start();\n    startVideoElementMonitoring();\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'ROOM_STATE') {\n    if (request.hostUserId) {\n      console.log('[Content Script] Room state received - hostUserId:', request.hostUserId);\n      syncManager.setHostUserId(request.hostUserId);\n    }\n  }\n\n  if (request.type === 'PARTY_STOPPED') {\n    console.log('[Content Script] Stopping party');\n    stopVideoElementMonitoring();\n    stateManager.stopParty();\n    syncManager.teardown();\n    urlSync.stop();\n    urlSync.clearState();\n    webrtcManager.clearAll();\n    uiManager.removeLocalPreview();\n    uiManager.removeConnectionIndicator();\n    if (localStream) {\n      localStream.getTracks().forEach(t => t.stop());\n      localStream = null;\n    }\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SIGNAL') {\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\n    webrtcManager.handleSignal(request.message);\n  }\n\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\n    // Only apply playback controls if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring playback control - not on /watch page');\n      return;\n    }\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId, request.eventTimestamp);\n  }\n\n  // Passive sync removed - using event-based sync only\n\n  if (request.type === 'APPLY_SEEK') {\n    // Only apply seek if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring seek - not on /watch page');\n      return;\n    }\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId, request.eventTimestamp);\n  }\n\n  if (request.type === 'APPLY_SEEK_PAUSE') {\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring seek-pause - not on /watch page');\n      return;\n    }\n    syncManager.handleSeekPause(request.currentTime, request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_URL_CHANGE') {\n    console.log('[Content Script] Received URL change request:', request.url, 'time:', request.currentTime, 'from', request.fromUserId);\n    \n    // Mark this URL so we don't echo it back\n    try {\n      const normalized = urlSync.normalizeUrl(request.url);\n      sessionStorage.setItem('tandem_last_remote_url', normalized);\n      setTimeout(() => sessionStorage.removeItem('tandem_last_remote_url'), 2000);\n    } catch (e) {}\n    \n    if (stateManager.restoringPartyState) {\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\n      return;\n    }\n    \n    // Apply URL changes to all Netflix pages (browse, title, watch, etc.)\n    const incomingUrl = new URL(request.url);\n    const currentUrl = new URL(window.location.href);\n\n    // Prevent bouncing back to previous episode during auto-advance\n    if (window.location.pathname.startsWith('/watch')) {\n      try {\n        const transitionRaw = sessionStorage.getItem('tandem_watch_transition');\n        if (transitionRaw) {\n          const transition = JSON.parse(transitionRaw);\n          const withinWindow = Date.now() - transition.timestamp < 15000;\n          const isBounceBack = transition.from === request.url && transition.to === window.location.href;\n          if (withinWindow && isBounceBack) {\n            console.log('[Content Script] Ignoring URL change back to previous episode during auto-advance');\n            return;\n          }\n        }\n      } catch (e) {\n        console.warn('[Content Script] Failed to check watch transition state:', e);\n      }\n    }\n    \n    // For /watch pages, merge the video ID and trackId into current URL params\n    let targetUrl = request.url;\n    const incomingPath = incomingUrl.pathname;\n    const currentPath = currentUrl.pathname;\n    const bothAreWatch = currentPath.startsWith('/watch') && incomingPath.startsWith('/watch');\n    \n    if (bothAreWatch) {\n      // Preserve current URL params, just update video ID and trackId\n      const mergedUrl = new URL(currentUrl.href);\n      mergedUrl.pathname = incomingUrl.pathname; // Update video ID in path\n      \n      // Update or add trackId if present in incoming URL\n      const incomingTrackId = incomingUrl.searchParams.get('trackId');\n      if (incomingTrackId) {\n        mergedUrl.searchParams.set('trackId', incomingTrackId);\n      }\n      \n      targetUrl = mergedUrl.href;\n      console.log('[Content Script] Merged URL preserving params:', targetUrl);\n    }\n    \n    // Don't navigate if we're already on this URL (compare normalized versions)\n    const normalizedCurrent = urlSync.normalizeUrl(window.location.href);\n    const normalizedTarget = urlSync.normalizeUrl(targetUrl);\n    if (normalizedCurrent === normalizedTarget) {\n      console.log('[Content Script] Already on this URL (normalized), skipping navigation');\n      \n      // But still sync to initiator's time if provided\n      if (request.currentTime !== undefined && request.currentTime !== null) {\n        console.log('[Content Script] Syncing to initiator\\'s time:', request.currentTime);\n        syncManager.handleSeekPause(request.currentTime, request.fromUserId);\n      }\n      return;\n    }\n    \n    console.log('[Content Script] Navigating to:', targetUrl);\n    // Save state before navigating (for restoration if on /watch page)\n    if (currentPath.startsWith('/watch')) {\n      urlSync.saveState();\n    }\n    \n    // Store the initiator's time for post-navigation sync\n    if (request.currentTime !== undefined && request.currentTime !== null) {\n      sessionStorage.setItem('tandem_pending_seek_time', request.currentTime.toString());\n      console.log('[Content Script] Storing pending seek time:', request.currentTime);\n    }\n    \n    // For /watch to /watch navigation (episode changes), always force reload\n    // Netflix player doesn't respond to pushState for episode changes\n    if (bothAreWatch) {\n      console.log('[Content Script] Watch-to-watch navigation detected, forcing full reload');\n      window.location.href = targetUrl;\n      return;\n    }\n    \n    // For other navigation (browse to watch, etc), try SPA navigation\n    try {\n      window.history.pushState({}, '', targetUrl);\n      window.dispatchEvent(new PopStateEvent('popstate', { state: {} }));\n      console.log('[Content Script] SPA navigation triggered');\n    } catch (e) {\n      console.error('[Content Script] Failed to navigate via pushState, falling back to full reload:', e);\n      window.location.href = request.url;\n    }\n  }\n\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\n    // Only handle sync requests if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring sync request - not on /watch page');\n      return;\n    }\n    syncManager.handleRequestSync(request.fromUserId, request.respectAutoPlay);\n  }\n\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\n    // Only apply sync response if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring sync response - not on /watch page');\n      return;\n    }\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url, request.respectAutoPlay ? '(respecting auto-play)' : '');\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url, request.respectAutoPlay);\n  }\n\n  if (request.type === 'HOST_HEARTBEAT') {\n    if (!window.location.pathname.startsWith('/watch')) {\n      return;\n    }\n    syncManager.handleHostHeartbeat(request.currentTime, request.isPlaying, request.fromUserId, request.eventTimestamp);\n  }\n\n  if (request.type === 'REQUEST_INITIAL_SYNC_AND_PLAY') {\n    console.log('[Content Script] Requesting initial sync and will auto-play when synced');\n    // Request sync from other clients\n    stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\n  }\n\n  if (request.type === 'CONNECTION_STATUS') {\n    console.log('[Content Script] Connection status changed:', request.status);\n    uiManager.updateConnectionIndicator(request.status);\n  }\n\n  if (request.type === 'RECONNECTED') {\n    console.log('[Content Script] WebSocket reconnected, userId:', request.userId);\n  }\n\n  if (request.type === 'REQUEST_SYNC_AFTER_RECONNECT') {\n    // Only request sync if we're on a /watch page and party is active\n    if (window.location.pathname.startsWith('/watch') && stateManager.isActive()) {\n      console.log('[Content Script] Requesting sync after reconnection');\n      stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\n    }\n  }\n});\n\nwindow.addEventListener('beforeunload', () => {\n  if (stateManager.isActive()) {\n    urlSync.saveState();\n  }\n});\n","export class StateManager {\n  constructor() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    this.restoringPartyState = false;\n  }\n  startParty(userId, roomId) {\n    this.partyActive = true;\n    this.userId = userId;\n    this.roomId = roomId;\n    // Set flag so videos persist across navigation\n    sessionStorage.setItem('tandem_was_active', 'true');\n  }\n  stopParty() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    // Clear flag so videos are cleaned up\n    sessionStorage.removeItem('tandem_was_active');\n  }\n  isActive() { return this.partyActive; }\n  getUserId() { return this.userId; }\n  getRoomId() { return this.roomId; }\n  getState() {\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\n  }\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\n  setRestoringFlag(value) { this.restoringPartyState = value; }\n  isExtensionContextValid() {\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\n  }\n  safeSendMessage(message, callback) {\n    if (!this.isExtensionContextValid()) {\n      console.warn('[StateManager] Extension context invalid - page needs reload after extension update');\n      // Show user notification that they need to reload\n      if (!document.getElementById('tandem-reload-notice')) {\n        const notice = document.createElement('div');\n        notice.id = 'tandem-reload-notice';\n        notice.style.cssText = 'position:fixed;top:20px;right:20px;background:#e50914;color:white;padding:15px;border-radius:8px;z-index:99999;font-family:Arial;box-shadow:0 4px 6px rgba(0,0,0,0.3);';\n        notice.innerHTML = '<strong>tandem.watch:</strong> Extension updated. Please reload this page.';\n        document.body.appendChild(notice);\n      }\n      return;\n    }\n    console.log('[StateManager] Sending message:', message.type, message);\n    try { \n      chrome.runtime.sendMessage(message, (response) => {\n        if (chrome.runtime.lastError) {\n          console.error('[StateManager] Error sending message:', message.type, chrome.runtime.lastError.message);\n        } else {\n          console.log('[StateManager] Message sent successfully:', message.type, response);\n        }\n        if (callback) callback(response);\n      }); \n    } catch (e) { \n      console.error('[StateManager] Exception sending message:', message.type, e.message, e); \n    }\n  }\n}\n","export class UIManager {\n  constructor() {\n    this.localPreviewVideo = null;\n    this.remoteVideos = new Map();\n    this.remoteStreams = new Map();\n    this.streamMonitorInterval = null;\n  }\n\n  makeDraggable(element) {\n    let isDragging = false;\n    let currentX;\n    let currentY;\n    let initialX;\n    let initialY;\n    let xOffset = 0;\n    let yOffset = 0;\n\n    element.addEventListener('mousedown', dragStart);\n    element.addEventListener('mouseup', dragEnd);\n    element.addEventListener('mousemove', drag);\n    element.style.cursor = 'move';\n\n    function dragStart(e) {\n      // Get current position from style\n      const computedStyle = window.getComputedStyle(element);\n      const bottom = computedStyle.bottom;\n      const left = computedStyle.left;\n      const right = computedStyle.right;\n      \n      // Convert to absolute positioning from current position\n      const rect = element.getBoundingClientRect();\n      element.style.left = rect.left + 'px';\n      element.style.top = rect.top + 'px';\n      element.style.bottom = 'auto';\n      element.style.right = 'auto';\n      \n      initialX = e.clientX - rect.left;\n      initialY = e.clientY - rect.top;\n      isDragging = true;\n      element.style.opacity = '0.8';\n    }\n\n    function dragEnd(e) {\n      initialX = currentX;\n      initialY = currentY;\n      isDragging = false;\n      element.style.opacity = '1';\n    }\n\n    function drag(e) {\n      if (isDragging) {\n        e.preventDefault();\n        currentX = e.clientX - initialX;\n        currentY = e.clientY - initialY;\n        \n        // Keep within viewport bounds\n        const maxX = window.innerWidth - element.offsetWidth;\n        const maxY = window.innerHeight - element.offsetHeight;\n        currentX = Math.max(0, Math.min(currentX, maxX));\n        currentY = Math.max(0, Math.min(currentY, maxY));\n        \n        setTranslate(currentX, currentY, element);\n      }\n    }\n\n    function setTranslate(xPos, yPos, el) {\n      el.style.left = xPos + 'px';\n      el.style.top = yPos + 'px';\n    }\n  }\n  getRemoteVideos() { return this.remoteVideos; }\n  getRemoteStreams() { return this.remoteStreams; }\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\n  clearStreamMonitorInterval() {\n    if (this.streamMonitorInterval) {\n      clearInterval(this.streamMonitorInterval);\n      this.streamMonitorInterval = null;\n    }\n  }\n\n  attachLocalPreview(stream) {\n    console.log('[UIManager] Attaching local preview with stream:', stream);\n    this.removeLocalPreview();\n    \n    const v = document.createElement('video');\n    v.id = 'tandem-local-preview';\n    v.autoplay = true;\n    v.muted = true; // Always mute local preview to avoid feedback\n    v.playsInline = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '145px';\n    v.style.left = '20px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = '999999';\n    v.style.border = '2px solid #e50914';\n    v.style.borderRadius = '4px';\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\n\n    try {\n      v.srcObject = stream;\n      console.log('[UIManager] Set srcObject on local preview');\n    } catch (e) {\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream);\n    }\n\n    document.body.appendChild(v);\n    this.localPreviewVideo = v;\n    console.log('[UIManager] Local preview video appended to body');\n\n    // Make it draggable\n    this.makeDraggable(v);\n\n    v.play().catch(err => {\n      console.warn('[UIManager] Local preview play() failed:', err);\n    });\n  }\n\n  removeLocalPreview() {\n    if (this.localPreviewVideo) {\n      console.log('[UIManager] Removing local preview video');\n      try {\n        if (this.localPreviewVideo.srcObject) {\n          this.localPreviewVideo.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[UIManager] Error clearing srcObject:', e);\n      }\n      this.localPreviewVideo.remove();\n      this.localPreviewVideo = null;\n    }\n  }\n\n  clearAll() {\n    this.removeLocalPreview();\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    this.clearStreamMonitorInterval();\n    this.removeConnectionIndicator();\n  }\n\n  showConnectionIndicator() {\n    // Remove existing indicator if any\n    this.removeConnectionIndicator();\n\n    const indicator = document.createElement('div');\n    indicator.id = 'tandem-connection-indicator';\n    indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: rgba(0, 0, 0, 0.85);\n      color: white;\n      padding: 8px 16px;\n      border-radius: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      font-size: 13px;\n      font-weight: 500;\n      z-index: 999999;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);\n      backdrop-filter: blur(10px);\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      transition: all 0.3s ease;\n      cursor: pointer;\n    `;\n\n    // Add click handler to open extension popup\n    indicator.addEventListener('click', () => {\n      chrome.runtime.sendMessage({ type: 'OPEN_POPUP' });\n    });\n\n    const dot = document.createElement('div');\n    dot.id = 'tandem-connection-dot';\n    dot.style.cssText = `\n      width: 8px;\n      height: 8px;\n      border-radius: 50%;\n      background: #4ade80;\n      animation: pulse 2s ease-in-out infinite;\n    `;\n\n    const text = document.createElement('span');\n    text.id = 'tandem-connection-text';\n    text.textContent = 'Connected';\n\n    indicator.appendChild(dot);\n    indicator.appendChild(text);\n    document.body.appendChild(indicator);\n\n    // Add pulse animation\n    const style = document.createElement('style');\n    style.id = 'tandem-connection-style';\n    style.textContent = `\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    `;\n    document.head.appendChild(style);\n\n    return indicator;\n  }\n\n  updateConnectionIndicator(status) {\n    const dot = document.getElementById('tandem-connection-dot');\n    const text = document.getElementById('tandem-connection-text');\n    \n    if (dot && text) {\n      if (status === 'connected') {\n        dot.style.background = '#4ade80';\n        dot.style.animation = 'pulse 2s ease-in-out infinite';\n        text.textContent = 'Connected';\n      } else if (status === 'waiting') {\n        dot.style.background = '#a78bfa';\n        dot.style.animation = 'spin 1s linear infinite';\n        text.textContent = 'Waiting for others...';\n      } else if (status === 'reconnecting') {\n        dot.style.background = '#f59e0b';\n        dot.style.animation = 'spin 1s linear infinite';\n        text.textContent = 'Reconnecting...';\n      } else if (status === 'disconnected') {\n        dot.style.background = '#ef4444';\n        dot.style.animation = 'pulse 1s ease-in-out infinite';\n        text.textContent = 'Disconnected';\n      }\n    }\n  }\n\n  removeConnectionIndicator() {\n    const indicator = document.getElementById('tandem-connection-indicator');\n    if (indicator) {\n      indicator.remove();\n    }\n  }\n}\n","export class NetflixController {\n  constructor() { this.injectAPIBridge(); }\n  injectAPIBridge() {\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\n    (document.head || document.documentElement).appendChild(script);\n    script.onload = function() { script.remove(); };\n  }\n  _sendCommand(command, args = []) {\n    return new Promise(function(resolve) {\n      const handler = function(e) {\n        if (e.detail.command === command) {\n          document.removeEventListener('__tandem_response', handler);\n          resolve(e.detail.result);\n        }\n      };\n      document.addEventListener('__tandem_response', handler);\n      setTimeout(function() { resolve(null); }, 1000);\n      document.dispatchEvent(new CustomEvent('__tandem_command', { detail: { command, args } }));\n    });\n  }\n  play() { return this._sendCommand('play'); }\n  pause() { return this._sendCommand('pause'); }\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\n  getDuration() { return this._sendCommand('getDuration'); }\n  getPlayerState() { return this._sendCommand('getPlayerState'); }\n  isPaused() { return this._sendCommand('isPaused'); }\n  setVolume(level) { return this._sendCommand('setVolume', [level]); }\n  getVolume() { return this._sendCommand('getVolume'); }\n  getVideoElement() { \n    // Find Netflix main player video element\n    // On /watch pages, look for video in the watch-video container\n    // On other pages, don't return any video (we don't want to sync preview videos)\n    \n    if (!window.location.pathname.startsWith('/watch')) {\n      return null;\n    }\n    \n    // Find Netflix video element, excluding tandem videos\n    const videos = document.querySelectorAll('video');\n    for (const video of videos) {\n      if (!video.id || !video.id.startsWith('tandem-')) {\n        return video;\n      }\n    }\n    return null;\n  }\n}\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef, urlSync, shouldAcceptLateSync, onInitialSyncApplied }) {\n  async function applyRemote(actionName, durationMs, actionFn) {\n    lock.set(durationMs);\n    try { await actionFn(); } catch (err) {\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\n    }\n  }\n\n  function applyLatencyCompensation(currentTime, isPlaying, eventTimestamp) {\n    if (!Number.isFinite(currentTime)) return currentTime;\n    if (!eventTimestamp || !Number.isFinite(eventTimestamp)) return currentTime;\n    if (!isPlaying) return currentTime;\n    const elapsedMs = Math.max(0, Date.now() - eventTimestamp);\n    return currentTime + (elapsedMs / 1000);\n  }\n\n  return {\n    async handleRequestSync(fromUserId, respectAutoPlay = false) {\n      const currentUrl = window.location.href;\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\n\n      // If we're on browse page, don't send sync response\n      if (!isOnWatchPage) {\n        console.log('[SyncManager] On browse page, not sending sync response');\n        return;\n      }\n\n      const maxAttempts = 6;\n      const retryDelayMs = 500;\n\n      const attemptSyncResponse = async (attempt) => {\n        try {\n          const currentTime = await netflix.getCurrentTime();\n          const isPaused = await netflix.isPaused();\n\n          if (currentTime == null) {\n            if (attempt < maxAttempts) {\n              console.log('[SyncManager] Playback state not ready, retrying sync response (attempt', attempt + 1, ')');\n              setTimeout(() => attemptSyncResponse(attempt + 1), retryDelayMs);\n            } else {\n              console.log('[SyncManager] Playback state still not ready, giving up on sync response');\n            }\n            return;\n          }\n\n          const currentTimeSeconds = currentTime / 1000;\n          console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl, respectAutoPlay ? '(will respect auto-play)' : '');\n\n          state.safeSendMessage({\n            type: 'SYNC_RESPONSE',\n            targetUserId: fromUserId,\n            currentTime: currentTimeSeconds,\n            isPlaying: !isPaused,\n            url: currentUrl,\n            respectAutoPlay: respectAutoPlay\n          });\n        } catch (e) {\n          console.error('[SyncManager] Error handling sync request:', e);\n        }\n      };\n\n      if (!isInitializedRef.get()) {\n        console.log('[SyncManager] Not yet initialized, will still attempt to respond to sync request');\n      }\n\n      attemptSyncResponse(1);\n    },\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay = false) {\n      // Check if this sync would revert a recent auto-advance\n      const urlSyncInstance = urlSync?.();\n      if (urlSyncInstance && urlSyncInstance.shouldSuppressSyncResponse(url)) {\n        return;\n      }\n      \n      if (isInitializedRef.get() && !shouldAcceptLateSync?.()) {\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\n        return;\n      }\n\n      if (isInitializedRef.get() && shouldAcceptLateSync?.()) {\n        console.log('[SyncManager] Accepting late SYNC_RESPONSE within initial window');\n      }\n      \n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\n        return;\n      }\n      \n      if (respectAutoPlay) {\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's (respecting auto-play)');\n      } else {\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\n      }\n      \n      // Check if we need to navigate to a different URL\n      const currentUrl = window.location.href;\n      const currentPath = window.location.pathname;\n      const isOnWatch = currentPath.startsWith('/watch');\n      const isOnBrowse = currentPath.startsWith('/browse');\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\n      \n      // Only navigate if we're NOT on a /watch page and the other user IS on /watch\n      // This allows initial sync to pull you to the watch page, but won't pull you back if you leave\n      if (!isOnWatch && otherIsOnWatch && isOnBrowse) {\n        console.log('[SyncManager] On browse page during initial join, other user on /watch - navigating to their show');\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        window.location.href = url;\n        return;\n      }\n      \n      // If we're not on /watch at all, ignore this sync response\n      if (!isOnWatch) {\n        console.log('[SyncManager] Not on /watch page - ignoring sync response');\n        isInitializedRef.set(true); // Mark as initialized so we don't keep processing these\n        if (onInitialSyncApplied) onInitialSyncApplied();\n        return;\n      }\n      \n      // Regular URL mismatch handling\n      if (url && url !== currentUrl) {\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\n        // Store the sync state to apply after navigation\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        // Navigate to the correct URL\n        window.location.href = url;\n        return;\n      }\n\n      // If sync returns a near-zero timestamp AND is paused, wait briefly for Netflix resume\n      // and prefer local progress to avoid resetting watch history.\n      // This handles cases where room state is default or stale.\n      // But if remote is playing, trust their position even if low.\n      if (currentTime < 0.5 && !isPlaying) {\n        try {\n          console.log('[SyncManager] Received near-zero sync (', currentTime.toFixed(2) + 's), checking for local resume position from', fromUserId);\n          const waitForLocalResume = async () => {\n            const attempts = 8;\n            const delayMs = 500;\n            for (let i = 0; i < attempts; i++) {\n              const localTimeMs = await netflix.getCurrentTime();\n              console.log('[SyncManager] Resume check attempt', i + 1, '- local time:', localTimeMs != null ? (localTimeMs / 1000).toFixed(2) + 's' : 'null');\n              if (localTimeMs != null && localTimeMs > 5000) {\n                return localTimeMs;\n              }\n              await new Promise(r => setTimeout(r, delayMs));\n            }\n            return null;\n          };\n\n          const localTimeMs = await waitForLocalResume();\n          if (localTimeMs != null && localTimeMs > 5000) {\n            const localPaused = await netflix.isPaused();\n            const localSeconds = localTimeMs / 1000;\n            console.log('[SyncManager] Using local resume position instead of near-zero sync:', localSeconds.toFixed(2) + 's', localPaused ? 'paused' : 'playing');\n            isInitializedRef.set(true);\n            if (onInitialSyncApplied) onInitialSyncApplied();\n            state.safeSendMessage({\n              type: 'POSITION_UPDATE',\n              currentTime: localSeconds,\n              isPlaying: !localPaused\n            });\n            return;\n          } else {\n            console.log('[SyncManager] No local resume position found after waiting, applying sync at', currentTime.toFixed(2) + 's');\n          }\n        } catch (e) {\n          console.warn('[SyncManager] Error checking local resume position:', e);\n        }\n      }\n      \n      isInitializedRef.set(true);\n      if (onInitialSyncApplied) onInitialSyncApplied();\n      \n      await applyRemote('initial-sync', 1500, async () => {\n        await netflix.seek(currentTime * 1000);\n        \n        // If respecting auto-play, only sync timestamp, not play/pause state\n        if (respectAutoPlay) {\n          console.log('[SyncManager] Synced timestamp only, respecting Netflix auto-play');\n          // Report position to server\n          const finalPaused = await netflix.isPaused();\n          state.safeSendMessage({\n            type: 'POSITION_UPDATE',\n            currentTime: currentTime,\n            isPlaying: !finalPaused\n          });\n          return;\n        }\n        \n        const localPaused = await netflix.isPaused();\n        \n        // Sync to the remote play/pause state\n        if (isPlaying && localPaused) {\n          console.log('[SyncManager] Remote is playing, starting playback');\n          await netflix.play();\n        } else if (!isPlaying && !localPaused) {\n          console.log('[SyncManager] Remote is paused, pausing playback');\n          await netflix.pause();\n        }\n        \n        // Report final position to server after sync complete\n        state.safeSendMessage({\n          type: 'POSITION_UPDATE',\n          currentTime: currentTime,\n          isPlaying: isPlaying\n        });\n      });\n    },\n    async handlePlaybackControl(control, currentTime, fromUserId, eventTimestamp) {\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'from', fromUserId, 'at', currentTime?.toFixed(2) + 's');\n      const adjustedTime = applyLatencyCompensation(currentTime, control === 'play', eventTimestamp);\n\n      await applyRemote(control, 1000, async () => {\n        // Sync position first if provided\n        if (Number.isFinite(adjustedTime) && adjustedTime > 0) {\n          const localTimeMs = await netflix.getCurrentTime();\n          const localTime = Number.isFinite(localTimeMs) ? (localTimeMs / 1000) : null;\n          const drift = localTime != null ? Math.abs(localTime - adjustedTime) : 999;\n          \n          // Lower threshold to 0.5s for tighter sync\n          if (drift > 0.5) {\n            console.log('[SyncManager] Syncing position before', control, '- drift:', drift.toFixed(2) + 's, seeking to', adjustedTime.toFixed(2) + 's');\n            await netflix.seek(adjustedTime * 1000);\n          }\n        }\n        \n        // Then apply play/pause\n        if (control === 'play') {\n          await netflix.play();\n        } else {\n          await netflix.pause();\n        }\n      });\n    },\n    async handleSeek(currentTime, isPlaying, fromUserId, eventTimestamp) {\n      const adjustedTime = applyLatencyCompensation(currentTime, isPlaying, eventTimestamp);\n      console.log('[SyncManager] Remote SEEK to', adjustedTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\n\n      await applyRemote('seek', 1200, async () => {\n        await netflix.seek(adjustedTime * 1000);\n        const isPaused = await netflix.isPaused();\n        \n        if (isPlaying && isPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !isPaused) {\n          await netflix.pause();\n        }\n      });\n    },\n    async handleSeekPause(currentTime, fromUserId) {\n      console.log('[SyncManager] Remote SEEK_PAUSE to', currentTime.toFixed(2) + 's from', fromUserId);\n\n      await applyRemote('seek-pause', 1500, async () => {\n        await netflix.seek(currentTime * 1000);\n        await netflix.pause();\n\n        const waitForReady = () => new Promise((resolve) => {\n          const video = netflix.getVideoElement();\n          if (!video) {\n            setTimeout(resolve, 400);\n            return;\n          }\n          if (video.readyState >= 3) {\n            resolve();\n            return;\n          }\n          let settled = false;\n          const done = () => {\n            if (settled) return;\n            settled = true;\n            video.removeEventListener('canplaythrough', done);\n            video.removeEventListener('canplay', done);\n            resolve();\n          };\n          video.addEventListener('canplaythrough', done, { once: true });\n          video.addEventListener('canplay', done, { once: true });\n          setTimeout(done, 4000);\n        });\n\n        await waitForReady();\n        state.safeSendMessage({ type: 'READY', targetTime: currentTime });\n      });\n    },\n    async handleHostHeartbeat(currentTime, isPlaying, fromUserId, eventTimestamp) {\n      if (!Number.isFinite(currentTime)) return;\n      const adjustedTime = applyLatencyCompensation(currentTime, isPlaying, eventTimestamp);\n\n      const localTimeMs = await netflix.getCurrentTime();\n      const localTime = Number.isFinite(localTimeMs) ? (localTimeMs / 1000) : null;\n      if (localTime == null) return;\n\n      const drift = adjustedTime - localTime;\n      if (Math.abs(drift) < 0.5) return;\n\n      await applyRemote('heartbeat-catchup', 600, async () => {\n        console.log('[SyncManager] Host heartbeat correction:', drift.toFixed(2) + 's');\n        await netflix.seek(adjustedTime * 1000);\n        const localPaused = await netflix.isPaused();\n        if (isPlaying && localPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !localPaused) {\n          await netflix.pause();\n        }\n      });\n    }\n  };\n}\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek, onPositionUpdate }) {\n  const handlePlay = () => {\n    console.log('[EventListeners] Play event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring play - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring play - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring play - lock active'); return; }\n    console.log('[EventListeners] Play event detected - broadcasting');\n    onPlay(video);\n  };\n\n  const handlePause = () => {\n    console.log('[EventListeners] Pause event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring pause - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring pause - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring pause - lock active'); return; }\n    console.log('[EventListeners] Pause event detected - broadcasting');\n    onPause(video);\n  };\n\n  const handleSeeked = () => {\n    console.log('[EventListeners] Seek event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring seek - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring seek - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring seek - lock active'); return; }\n    console.log('[EventListeners] Seek event detected - broadcasting');\n    onSeek(video);\n  };\n\n  // Continuous position tracking (every 500ms)\n  const positionUpdateInterval = setInterval(() => {\n    // Only send position updates from /watch pages\n    if (window.location.pathname.startsWith('/watch') && state.isActive() && isInitializedRef.get() && !lock.isActive() && onPositionUpdate) {\n      onPositionUpdate(video);\n    }\n  }, 500);\n\n  video.addEventListener('play', handlePlay);\n  video.addEventListener('pause', handlePause);\n  video.addEventListener('seeked', handleSeeked);\n  console.log('[EventListeners] Event listeners attached to video element');\n\n  // Return cleanup function along with listeners\n  return { \n    video, \n    handlePlay, \n    handlePause, \n    handleSeeked,\n    cleanup: () => clearInterval(positionUpdateInterval)\n  };\n}\n","import { createSignalingHandlers } from './signaling.js';\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\nimport { createReconnectionManager } from './reconnect.js';\nimport { createRemoteVideoManager } from './ui.js';\n\nexport class WebRTCManager {\n  constructor(stateManager, uiManager) {\n    this.stateManager = stateManager;\n    this.uiManager = uiManager;\n    this.peerConnections = new Map();\n    this.remoteStreams = this.uiManager.getRemoteStreams();\n    this.remoteVideos = this.uiManager.getRemoteVideos();\n    this.peersThatLeft = new Set();\n    this.localStream = null;\n\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\n    \n    // Create a placeholder object for circular dependency resolution\n    const reconnectionManager = {};\n    \n    const createPeer = createPeerConnectionFactory({\n      stateManager: this.stateManager,\n      sendSignal: (msg) => this._sendSignal(msg),\n      remoteStreams: this.remoteStreams,\n      remoteVideos: this.remoteVideos,\n      addRemoteVideo: videoManager.add,\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      },\n      peersThatLeft: this.peersThatLeft,\n      showReconnecting: videoManager.showReconnecting,\n      hideOverlay: videoManager.hideOverlay,\n      showPlaceholder: videoManager.showPlaceholder\n    });\n\n    // Now create the actual reconnection manager with createPeer available\n    Object.assign(reconnectionManager, createReconnectionManager({\n      stateManager: this.stateManager,\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      localStream: () => this.localStream,\n      createPeer: createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack\n    }));\n\n    this.reconnectionManager = reconnectionManager;\n    this.createPeer = createPeer;\n    this.videoManager = videoManager;\n\n    this.signalingHandlers = createSignalingHandlers({\n      getState: () => this.stateManager.getState(),\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      getLocalStream: () => this.localStream,\n      createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack,\n      clearReconnection: reconnectionManager.clear,\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      }\n    });\n  }\n\n  setLocalStream(stream) { this.localStream = stream; }\n  getLocalStream() { return this.localStream; }\n  \n  onLocalStreamAvailable(stream) {\n    this.localStream = stream;\n    this.peerConnections.forEach((pc) => {\n      try {\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n      } catch (e) {}\n    });\n  }\n\n  async handleSignal(message) {\n    console.log('[WebRTCManager] handleSignal called with:', message);\n    if (!message || !message.type) {\n      console.warn('[WebRTCManager] Invalid message:', message);\n      return;\n    }\n    const type = message.type;\n    const from = message.userId || message.from;\n    const to = message.to;\n    const state = this.stateManager.getState();\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\n    \n    // Only check 'to' field for targeted messages (not broadcasts like JOIN)\n    // JOIN, LEAVE, and SYNC messages are broadcasts that don't have 'to' fields\n    const isTargetedMessage = type === 'OFFER' || type === 'ANSWER' || type === 'ICE_CANDIDATE' || type === 'SYNC_RESPONSE';\n    if (isTargetedMessage && to && to !== state.userId) {\n      console.log('[WebRTCManager] Ignoring targeted message not meant for me');\n      return;\n    }\n\n    if (type === 'JOIN' && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleJoin');\n      await this.signalingHandlers.handleJoin(from);\n    } else if (type === 'USER_JOINED' && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleJoin (USER_JOINED)');\n      await this.signalingHandlers.handleJoin(from);\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleOffer');\n      await this.signalingHandlers.handleOffer(from, message.offer);\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\n      await this.signalingHandlers.handleAnswer(from, message.answer);\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\n    } else if (type === 'LEAVE' && from) {\n      console.log('[WebRTCManager] Dispatching to handleLeave');\n      this.signalingHandlers.handleLeave(from);\n    } else {\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'fromSelf:', from === state.userId, 'reasons:', {\n        JOIN: type === 'JOIN' ? `from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        OFFER: type === 'OFFER' ? `hasOffer=${!!message.offer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        ANSWER: type === 'ANSWER' ? `hasAnswer=${!!message.answer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        ICE: type === 'ICE_CANDIDATE' ? `hasCandidate=${!!message.candidate}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        LEAVE: type === 'LEAVE' ? `from=${!!from}` : 'N/A'\n      });\n    }\n  }\n\n  attemptReconnection(peerId) {\n    return this.reconnectionManager.attempt(peerId);\n  }\n\n  _sendSignal(message) {\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\n  }\n\n  showWaitingIndicator() {\n    console.log('[WebRTCManager] Showing waiting indicator');\n    this.videoManager.showWaitingIndicator();\n  }\n  \n  hideWaitingIndicator() {\n    console.log('[WebRTCManager] Hiding waiting indicator');\n    this.videoManager.hideWaitingIndicator();\n  }\n  \n  clearAll() {\n    console.log('[WebRTCManager] Clearing all connections and videos');\n    \n    // Hide waiting indicator\n    this.hideWaitingIndicator();\n    \n    this.peerConnections.forEach((pc) => {\n      try { pc.close(); } catch (e) {}\n    });\n    this.peerConnections.clear();\n    this.peersThatLeft.clear();\n    \n    // Clean up video elements and their containers\n    this.remoteVideos.forEach((v, peerId) => {\n      try { \n        if (v.srcObject) {\n          v.srcObject.getTracks().forEach(track => track.stop());\n          v.srcObject = null;\n        }\n      } catch (e) {}\n      \n      // Remove the container (which includes the video)\n      const container = document.getElementById('tandem-container-' + peerId);\n      if (container) {\n        console.log('[WebRTCManager] Removing container for peer:', peerId);\n        container.remove();\n      } else if (v.parentElement) {\n        // Fallback: remove parent if it exists\n        v.parentElement.remove();\n      } else {\n        // Last resort: just remove the video\n        v.remove();\n      }\n    });\n    \n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    \n    // Extra cleanup: remove any orphaned tandem elements\n    document.querySelectorAll('[id^=\"tandem-container-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned container:', el.id);\n      el.remove();\n    });\n    document.querySelectorAll('[id^=\"tandem-remote-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned video:', el.id);\n      el.remove();\n    });\n    document.querySelectorAll('[id^=\"tandem-overlay-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned overlay:', el.id);\n      el.remove();\n    });\n    \n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n}\n","export function createRemoteVideoManager(remoteVideos) {\n  function ensureSpinnerStyles() {\n    if (document.getElementById('tandem-spinner-styles')) {\n      return;\n    }\n\n    const style = document.createElement('style');\n    style.id = 'tandem-spinner-styles';\n    style.textContent = `\n      @keyframes tandem-spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n      @keyframes tandem-pulse {\n        0%, 100% { opacity: 0.3; }\n        50% { opacity: 1; }\n      }\n      @keyframes tandem-dot {\n        0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }\n        40% { transform: scale(1); opacity: 1; }\n      }\n      .tandem-dots {\n        display: inline-flex;\n        gap: 4px;\n        align-items: center;\n        justify-content: center;\n      }\n      .tandem-dot {\n        width: 6px;\n        height: 6px;\n        border-radius: 50%;\n        background: #38bdf8;\n        animation: tandem-dot 1.2s infinite ease-in-out;\n      }\n      .tandem-dot:nth-child(2) { animation-delay: 0.2s; }\n      .tandem-dot:nth-child(3) { animation-delay: 0.4s; }\n    `;\n    document.head.appendChild(style);\n  }\n\n  function createLoadingSpinner() {\n    ensureSpinnerStyles();\n    // Create a more visually appealing spinner using CSS\n    const spinner = document.createElement('div');\n    spinner.className = 'tandem-spinner';\n    spinner.style.cssText = `\n      width: 40px;\n      height: 40px;\n      border: 4px solid rgba(255, 255, 255, 0.3);\n      border-top: 4px solid #00aaff;\n      border-radius: 50%;\n      animation: tandem-spin 1s linear infinite;\n      margin-bottom: 12px;\n    `;\n    return spinner;\n  }\n\n  function createWaitingDots() {\n    ensureSpinnerStyles();\n    const dots = document.createElement('div');\n    dots.className = 'tandem-dots';\n    dots.innerHTML = '<span class=\"tandem-dot\"></span><span class=\"tandem-dot\"></span><span class=\"tandem-dot\"></span>';\n    return dots;\n  }\n  \n  function makeDraggable(element) {\n    let isDragging = false;\n    let currentX;\n    let currentY;\n    let initialX;\n    let initialY;\n\n    element.addEventListener('mousedown', dragStart);\n    element.addEventListener('mouseup', dragEnd);\n    element.addEventListener('mousemove', drag);\n    element.style.cursor = 'move';\n\n    function dragStart(e) {\n      const computedStyle = window.getComputedStyle(element);\n      const rect = element.getBoundingClientRect();\n      \n      element.style.left = rect.left + 'px';\n      element.style.top = rect.top + 'px';\n      element.style.bottom = 'auto';\n      element.style.right = 'auto';\n      \n      initialX = e.clientX - rect.left;\n      initialY = e.clientY - rect.top;\n      isDragging = true;\n      element.style.opacity = '0.8';\n    }\n\n    function dragEnd(e) {\n      initialX = currentX;\n      initialY = currentY;\n      isDragging = false;\n      element.style.opacity = '1';\n    }\n\n    function drag(e) {\n      if (isDragging) {\n        e.preventDefault();\n        currentX = e.clientX - initialX;\n        currentY = e.clientY - initialY;\n        \n        const maxX = window.innerWidth - element.offsetWidth;\n        const maxY = window.innerHeight - element.offsetHeight;\n        currentX = Math.max(0, Math.min(currentX, maxX));\n        currentY = Math.max(0, Math.min(currentY, maxY));\n        \n        element.style.left = currentX + 'px';\n        element.style.top = currentY + 'px';\n      }\n    }\n  }\n\n  function add(peerId, stream) {\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\n    console.log('[RemoteVideoManager] Current remoteVideos map size:', remoteVideos.size, 'peers:', Array.from(remoteVideos.keys()));\n    \n    // First, aggressively clean up any existing elements for this peer to prevent duplicates\n    const existingInMap = remoteVideos.get(peerId);\n    const existingInDom = document.getElementById('tandem-remote-' + peerId);\n    const existingContainer = document.getElementById('tandem-container-' + peerId);\n    \n    if (existingInDom && existingInMap && existingInDom === existingInMap) {\n      console.log('[RemoteVideoManager] Video already exists for peer:', peerId, 'updating stream if needed');\n      if (existingInDom.srcObject !== stream) {\n        console.log('[RemoteVideoManager] Updating stream on existing video element');\n        if (existingInDom.srcObject) {\n          existingInDom.srcObject.getTracks().forEach(t => t.stop());\n        }\n        existingInDom.srcObject = stream;\n        const overlay = document.getElementById('tandem-overlay-' + peerId);\n        if (overlay) overlay.remove();\n      }\n      return;\n    }\n    \n    // Clean up any stale elements before creating new ones\n    if (existingInMap || existingInDom || existingContainer) {\n      console.log('[RemoteVideoManager] Found stale elements for peer:', peerId, 'cleaning up before creating new');\n      remove(peerId);\n    }\n    \n    // Create fresh container\n    const container = document.createElement('div');\n    container.id = 'tandem-container-' + peerId;\n    container.style.position = 'fixed';\n    container.style.bottom = '145px';\n    container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n    container.style.width = '240px';\n    container.style.height = '160px';\n    container.style.zIndex = 999999;\n    container.style.border = '2px solid #00aaff';\n    container.style.borderRadius = '4px';\n    container.style.backgroundColor = '#000';\n    \n    const v = document.createElement('video');\n    v.id = 'tandem-remote-' + peerId;\n    v.autoplay = true;\n    v.playsInline = true;\n    v.muted = true;\n    v.style.width = '100%';\n    v.style.height = '100%';\n    v.style.border = '2px solid #00aaff';\n    v.style.borderRadius = '4px';\n    v.style.backgroundColor = '#000';\n    \n    // Get or create overlay\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (!overlay) {\n      overlay = document.createElement('div');\n      overlay.id = 'tandem-overlay-' + peerId;\n      overlay.style.position = 'absolute';\n      overlay.style.top = '0';\n      overlay.style.left = '0';\n      overlay.style.width = '100%';\n      overlay.style.height = '100%';\n      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n      overlay.style.display = 'flex';\n      overlay.style.flexDirection = 'column';\n      overlay.style.alignItems = 'center';\n      overlay.style.justifyContent = 'center';\n      overlay.style.color = '#fff';\n      overlay.style.fontSize = '14px';\n      overlay.style.fontFamily = 'Arial, sans-serif';\n      overlay.style.borderRadius = '4px';\n      overlay.style.pointerEvents = 'none';\n      \n      const spinner = createLoadingSpinner();\n      const text = document.createElement('div');\n      text.textContent = 'Connecting...';\n      text.style.fontWeight = '500';\n      \n      overlay.appendChild(spinner);\n      overlay.appendChild(text);\n    }\n    \n    ensureSpinnerStyles();\n    \n    container.appendChild(v);\n    if (!overlay.parentElement) {\n      container.appendChild(overlay);\n    }\n    if (!container.parentElement) {\n      document.body.appendChild(container);\n      // Make container draggable if newly created\n      makeDraggable(container);\n    }\n    console.log('[RemoteVideoManager] Added video to container:', container.id);\n    \n    // Verify stream has active tracks\n    const activeTracks = stream.getTracks().filter(t => t.readyState === 'live');\n    console.log('[RemoteVideoManager] Stream has', activeTracks.length, 'active tracks:', \n      activeTracks.map(t => `${t.kind}:${t.id.substring(0,8)}`).join(', '));\n    \n    try { \n      v.srcObject = stream;\n      console.log('[RemoteVideoManager] Set srcObject successfully');\n    } catch (e) { \n      console.warn('[RemoteVideoManager] srcObject failed:', e);\n    }\n    \n    remoteVideos.set(peerId, v);\n    \n    // Handle video playback with better error handling\n    const playVideo = () => {\n      v.play().then(() => {\n        console.log('[RemoteVideoManager] Video playing, unmuting and removing overlay');\n        v.muted = false;\n        v.volume = 1.0;\n        // Remove loading overlay\n        overlay.remove();\n      }).catch((e) => { \n        console.warn('[RemoteVideoManager] Play failed:', e.name, e.message);\n        // Try unmuting anyway in case autoplay blocked\n        v.muted = false;\n        // Still remove overlay even if play failed\n        overlay.remove();\n      });\n    };\n    \n    // If stream already has tracks, play immediately\n    if (activeTracks.length > 0) {\n      playVideo();\n    } else {\n      // Wait for tracks to become active\n      console.log('[RemoteVideoManager] Waiting for stream tracks to become active');\n      overlay.innerHTML = '<div style=\"text-align: center;\"><div style=\"margin-bottom: 8px;\"></div><div>Waiting for stream...</div></div>';\n      const checkTracks = setInterval(() => {\n        const nowActive = stream.getTracks().filter(t => t.readyState === 'live');\n        if (nowActive.length > 0) {\n          clearInterval(checkTracks);\n          console.log('[RemoteVideoManager] Tracks now active, playing video');\n          playVideo();\n        }\n      }, 100);\n      // Give up after 5 seconds and remove overlay anyway\n      setTimeout(() => {\n        clearInterval(checkTracks);\n        if (overlay.parentNode) {\n          console.log('[RemoteVideoManager] Timeout waiting for tracks, removing overlay');\n          overlay.remove();\n        }\n      }, 5000);\n    }\n  }\n  \n  function remove(peerId) {\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\n    \n    // Remove from map\n    const v = remoteVideos.get(peerId);\n    if (v) {\n      try { \n        if (v.srcObject) {\n          v.srcObject.getTracks().forEach(track => track.stop());\n          v.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[RemoteVideoManager] Error cleaning up stream:', e);\n      }\n      // Remove the container (which includes the video)\n      const container = v.parentElement;\n      if (container && container.id === 'tandem-container-' + peerId) {\n        container.remove();\n      } else {\n        v.remove();\n      }\n      remoteVideos.delete(peerId);\n    }\n    \n    // Also check DOM for any orphaned elements (extra safety)\n    const domContainer = document.getElementById('tandem-container-' + peerId);\n    if (domContainer) {\n      console.log('[RemoteVideoManager] Found orphaned container, removing');\n      domContainer.remove();\n    }\n    \n    const domElement = document.getElementById('tandem-remote-' + peerId);\n    if (domElement && domElement !== v) {\n      console.log('[RemoteVideoManager] Found orphaned video element, removing');\n      try {\n        if (domElement.srcObject) {\n          domElement.srcObject = null;\n        }\n      } catch (e) {}\n      domElement.remove();\n    }\n    \n    // Clean up overlay if it exists\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      overlay.remove();\n    }\n  }\n  \n  function showReconnecting(peerId) {\n    console.log('[RemoteVideoManager] Showing reconnecting overlay for peer:', peerId);\n    \n    // Check if overlay already exists\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      // Update existing overlay content\n      overlay.innerHTML = '';\n      const spinner = createLoadingSpinner();\n      const text = document.createElement('div');\n      text.textContent = 'Reconnecting...';\n      text.style.fontWeight = '500';\n      overlay.appendChild(spinner);\n      overlay.appendChild(text);\n      overlay.style.display = 'flex';\n      return;\n    }\n    \n    // Create new overlay if it doesn't exist\n    const container = document.getElementById('tandem-container-' + peerId);\n    if (!container) {\n      console.warn('[RemoteVideoManager] Cannot show reconnecting - container not found');\n      return;\n    }\n    \n    overlay = document.createElement('div');\n    overlay.id = 'tandem-overlay-' + peerId;\n    overlay.style.position = 'absolute';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n    overlay.style.display = 'flex';\n    overlay.style.flexDirection = 'column';\n    overlay.style.alignItems = 'center';\n    overlay.style.justifyContent = 'center';\n    overlay.style.color = '#fff';\n    overlay.style.fontSize = '14px';\n    overlay.style.fontFamily = 'Arial, sans-serif';\n    overlay.style.borderRadius = '4px';\n    overlay.style.pointerEvents = 'none';\n    \n    const spinner = createLoadingSpinner();\n    const text = document.createElement('div');\n    text.textContent = 'Reconnecting...';\n    text.style.fontWeight = '500';\n    \n    overlay.appendChild(spinner);\n    overlay.appendChild(text);\n    container.appendChild(overlay);\n  }\n  \n  function hideOverlay(peerId) {\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      console.log('[RemoteVideoManager] Hiding overlay for peer:', peerId);\n      overlay.remove();\n    }\n  }\n  \n  function showWaitingIndicator() {\n    // Remove any existing waiting indicator first\n    hideWaitingIndicator();\n    \n    console.log('[RemoteVideoManager] Showing waiting indicator');\n    const container = document.createElement('div');\n    container.id = 'tandem-waiting-indicator';\n    container.style.position = 'fixed';\n    container.style.bottom = '24px';\n    container.style.right = '20px';\n    container.style.padding = '8px 12px';\n    container.style.zIndex = 999999;\n    container.style.border = '1px solid rgba(56, 189, 248, 0.4)';\n    container.style.borderRadius = '999px';\n    container.style.backgroundColor = 'rgba(15, 23, 42, 0.9)';\n    container.style.display = 'flex';\n    container.style.alignItems = 'center';\n    container.style.gap = '8px';\n    container.style.color = '#e2e8f0';\n    container.style.fontSize = '12px';\n    container.style.fontFamily = 'Arial, sans-serif';\n    container.style.pointerEvents = 'none';\n    container.style.boxShadow = '0 6px 18px rgba(0, 0, 0, 0.35)';\n    \n    const dots = createWaitingDots();\n    const text = document.createElement('div');\n    text.textContent = 'Party started  waiting for others';\n    text.style.fontWeight = '500';\n    text.style.letterSpacing = '0.2px';\n    \n    container.appendChild(dots);\n    container.appendChild(text);\n    document.body.appendChild(container);\n  }\n  \n  function hideWaitingIndicator() {\n    const indicator = document.getElementById('tandem-waiting-indicator');\n    if (indicator) {\n      console.log('[RemoteVideoManager] Hiding waiting indicator');\n      indicator.remove();\n    }\n  }\n  \n  function showPlaceholder(peerId) {\n    console.log('[RemoteVideoManager] Showing placeholder for peer:', peerId);\n    \n    // Hide waiting indicator when first peer connects\n    hideWaitingIndicator();\n    \n    // Check if container already exists\n    let container = document.getElementById('tandem-container-' + peerId);\n    if (container) {\n      console.log('[RemoteVideoManager] Placeholder already exists for peer:', peerId, '- reusing it');\n      return;\n    }\n    \n    console.log('[RemoteVideoManager] Creating NEW placeholder container for peer:', peerId);\n    \n    // Create container immediately\n    container = document.createElement('div');\n    container.id = 'tandem-container-' + peerId;\n    container.style.position = 'fixed';\n    container.style.bottom = '145px';\n    container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n    container.style.width = '240px';\n    container.style.height = '160px';\n    container.style.zIndex = 999999;\n    container.style.border = '2px solid #00aaff';\n    container.style.borderRadius = '4px';\n    container.style.backgroundColor = '#000';\n    \n    // Create loading overlay\n    const overlay = document.createElement('div');\n    overlay.id = 'tandem-overlay-' + peerId;\n    overlay.style.position = 'absolute';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n    overlay.style.display = 'flex';\n    overlay.style.flexDirection = 'column';\n    overlay.style.alignItems = 'center';\n    overlay.style.justifyContent = 'center';\n    overlay.style.color = '#fff';\n    overlay.style.fontSize = '14px';\n    overlay.style.fontFamily = 'Arial, sans-serif';\n    overlay.style.borderRadius = '4px';\n    overlay.style.pointerEvents = 'none';\n    \n    const spinner = createLoadingSpinner();\n    const text = document.createElement('div');\n    text.textContent = 'Connecting...';\n    text.style.fontWeight = '500';\n    \n    overlay.appendChild(spinner);\n    overlay.appendChild(text);\n    container.appendChild(overlay);\n    document.body.appendChild(container);\n    \n    // Make container draggable immediately\n    makeDraggable(container);\n    \n    console.log('[RemoteVideoManager] Created placeholder container:', container.id);\n  }\n  \n  return { add, remove, showReconnecting, hideOverlay, showPlaceholder, showWaitingIndicator, hideWaitingIndicator };\n}\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\n  const attempts = new Map();\n  const timeouts = new Map();\n  \n  function clear(peerId) {\n    attempts.delete(peerId);\n    const handle = timeouts.get(peerId);\n    if (handle) {\n      clearTimeout(handle);\n      timeouts.delete(peerId);\n    }\n  }\n  \n  async function attempt(peerId) {\n    if (!stateManager.isInParty()) return;\n    if (peersThatLeft.has(peerId)) {\n      clear(peerId);\n      return;\n    }\n    const count = attempts.get(peerId) || 0;\n    const maxAttempts = 5;\n    // Faster reconnection: 500ms, 1s, 2s, 4s, 8s (instead of 1s, 2s, 4s, 8s, 16s)\n    const backoffDelay = Math.min(500 * Math.pow(2, count), 10000);\n    if (count >= maxAttempts) {\n      console.log('[Reconnection] Max attempts reached for peer:', peerId);\n      clear(peerId);\n      return;\n    }\n    console.log('[Reconnection] Attempting reconnection for peer:', peerId, 'attempt:', count + 1, 'delay:', backoffDelay + 'ms');\n    attempts.set(peerId, count + 1);\n    const existing = timeouts.get(peerId);\n    if (existing) clearTimeout(existing);\n    const handle = setTimeout(async () => {\n      const oldPc = peerConnections.get(peerId);\n      if (oldPc) {\n        try { oldPc.close(); } catch (e) {}\n        peerConnections.delete(peerId);\n      }\n      try {\n        const pc = createPeer(peerId);\n        peerConnections.set(peerId, pc);\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\n        if (stream) {\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n        }\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        const state = stateManager.getState();\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[WebRTCManager] Reconnection failed:', err);\n        attempt(peerId);\n      }\n    }, backoffDelay);\n    timeouts.set(peerId, handle);\n  }\n  \n  return { attempt, clear };\n}\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\n  return {\n    async handleJoin(from) {\n      console.log('[Signaling] Handling JOIN from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring JOIN from self');\n        return;\n      }\n      \n      // First, clear any reconnection attempts - peer has explicitly rejoined\n      clearReconnection(from);\n      peersThatLeft.delete(from);\n      \n      let pc = peerConnections.get(from);\n      if (pc) {\n        const connectionState = pc.connectionState;\n        console.log('[Signaling] Already have peer connection for', from, 'state:', connectionState);\n        \n        // Only reuse if connection is fully connected AND tracks are present\n        // Otherwise clean up and start fresh to avoid duplicate videos\n        if (connectionState === 'connected') {\n          const receivers = pc.getReceivers();\n          const hasActiveStreams = receivers.some(r => r.track && r.track.readyState === 'live');\n          \n          if (hasActiveStreams) {\n            console.log('[Signaling] Reusing existing connected peer with active streams');\n            const stream = getLocalStream();\n            if (stream) {\n              let needsRenegotiation = false;\n              stream.getTracks().forEach(t => {\n                const senders = pc.getSenders();\n                const existingSender = senders.find(s => s.track && s.track.kind === t.kind);\n                if (!existingSender || existingSender.track.id !== t.id) {\n                  console.log('[Signaling] Track changed, replacing:', t.kind, t.id);\n                  addOrReplaceTrack(pc, t, stream);\n                  needsRenegotiation = true;\n                }\n              });\n              \n              if (needsRenegotiation && pc.signalingState === 'stable') {\n                console.log('[Signaling] Renegotiating due to track changes');\n                const offer = await pc.createOffer();\n                await pc.setLocalDescription(offer);\n                sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n              }\n            }\n            return;\n          }\n        }\n        \n        // For any other state or if no active streams, clean it up completely\n        console.log('[Signaling] Cleaning up existing connection in state:', connectionState, '- starting fresh');\n        clearReconnection(from);\n        removeRemoteVideo(from);\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n        pc = null;\n      }\n      \n      if (!pc) {\n        try {\n          console.log('[Signaling] Creating new peer connection for', from);\n          pc = createPeer(from);\n          peerConnections.set(from, pc);\n          const stream = getLocalStream();\n          console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n          if (stream) {\n            stream.getTracks().forEach(t => {\n              console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n              addOrReplaceTrack(pc, t, stream);\n            });\n          } else {\n            console.warn('[Signaling] No local stream available when handling JOIN');\n          }\n          console.log('[Signaling] Creating and sending OFFER to', from);\n          const offer = await pc.createOffer();\n          await pc.setLocalDescription(offer);\n          sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n        } catch (err) {\n          console.error('[Signaling] Error handling JOIN:', err);\n          peerConnections.delete(from);\n        }\n      }\n    },\n    async handleOffer(from, offer) {\n      console.log('[Signaling] Handling OFFER from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring OFFER from self');\n        return;\n      }\n      let pc = peerConnections.get(from);\n      if (pc) {\n        console.log('[Signaling] Existing peer connection state:', pc.signalingState);\n        if (pc.signalingState !== 'closed' && pc.signalingState !== 'stable') {\n          console.log('[Signaling] Closing existing peer connection in state:', pc.signalingState);\n          try { pc.close(); } catch (e) {}\n          peerConnections.delete(from);\n          pc = null;\n        } else if (pc.signalingState === 'stable') {\n          // If stable, this might be a renegotiation - close and recreate\n          console.log('[Signaling] Closing stable peer connection for renegotiation');\n          try { pc.close(); } catch (e) {}\n          peerConnections.delete(from);\n          pc = null;\n        }\n      }\n      if (!pc) {\n        console.log('[Signaling] Creating new peer connection for', from);\n        // Clear any reconnection attempts when receiving an offer\n        clearReconnection(from);\n        peersThatLeft.delete(from);\n        pc = createPeer(from);\n        peerConnections.set(from, pc);\n      }\n      try {\n        console.log('[Signaling] Setting remote description, current state:', pc.signalingState);\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling OFFER');\n        }\n        console.log('[Signaling] Creating and sending ANSWER to', from);\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling offer:', err.name, err.message);\n        console.error('[Signaling] Full error:', err);\n        peerConnections.delete(from);\n        try { pc.close(); } catch (e) {}\n      }\n    },\n    async handleAnswer(from, answer) {\n      console.log('[Signaling] Handling ANSWER from', from);\n      const pc = peerConnections.get(from);\n      if (!pc) {\n        console.warn('[Signaling] Cannot handle ANSWER - no peer connection found for', from);\n        return;\n      }\n      \n      console.log('[Signaling] Peer connection state:', {\n        signalingState: pc.signalingState,\n        connectionState: pc.connectionState,\n        iceConnectionState: pc.iceConnectionState\n      });\n      \n      if (pc.signalingState === 'have-local-offer') {\n        console.log('[Signaling] Setting remote description from ANSWER');\n        try {\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\n          console.log('[Signaling] Remote description set successfully');\n        } catch (err) {\n          console.error('[Signaling] Error handling answer:', err.name, err.message);\n          console.error('[Signaling] Full error:', err);\n          // If the peer connection is in a bad state, close it and remove it\n          if (err.name === 'InvalidStateError' || err.name === 'OperationError') {\n            console.log('[Signaling] Closing peer connection due to state error');\n            try { pc.close(); } catch (e) {}\n            peerConnections.delete(from);\n          }\n        }\n      } else if (pc.signalingState === 'stable') {\n        console.log('[Signaling] Received ANSWER but already in stable state (connection:', pc.connectionState + ') - likely duplicate, ignoring');\n      } else if (pc.signalingState === 'have-remote-offer') {\n        console.warn('[Signaling] Received ANSWER but expecting to send one (have-remote-offer) - might be glare, ignoring');\n      } else if (pc.signalingState === 'closed') {\n        console.warn('[Signaling] Received ANSWER but peer connection is closed - ignoring');\n      } else {\n        console.warn('[Signaling] Cannot handle ANSWER - unexpected state:', pc.signalingState);\n      }\n    },\n    async handleIceCandidate(from, candidate) {\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log('[Signaling] ICE candidate added successfully');\n        } catch (err) {\n          console.warn('[Signaling] Error adding ICE candidate', err);\n        }\n      } else {\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\n      }\n    },\n    handleLeave(from) {\n      console.log('[Signaling] Handling LEAVE from', from);\n      peersThatLeft.add(from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n      }\n      clearReconnection(from);\n      removeRemoteVideo(from);\n    }\n  };\n}\n","export class URLSync {\n  constructor(stateManager, onWatchPageChange, onNavigateToWatch, onLeaveWatch, netflixController) {\n    this.stateManager = stateManager;\n    this.netflixController = netflixController;\n    this.urlMonitorInterval = null;\n    this.lastUrl = null;\n    this.lastNormalizedUrl = null;\n    this.lastVideoEndedTime = 0;\n    this.videoEndListener = null;\n    this.recentAutoAdvanceUrl = null; // Track recent auto-advance to suppress conflicting sync\n    this.recentAutoAdvanceTime = 0;\n    this.pendingAutoAdvanceUrl = null;\n    this.pendingAutoAdvanceTime = 0;\n    this.nextEpisodeObserver = null;\n    this.onWatchPageChange = onWatchPageChange || (() => {});\n    this.onNavigateToWatch = onNavigateToWatch || (() => {});\n    this.onLeaveWatch = onLeaveWatch || (() => {});\n    this.handleUrlChange = this.handleUrlChange.bind(this);\n  }\n  \n  handleUrlChange() {\n    const currentUrl = window.location.href;\n    const normalizedCurrentUrl = this.normalizeUrl(currentUrl);\n    const normalizedPreviousUrl = this.lastNormalizedUrl;\n    if (normalizedCurrentUrl !== normalizedPreviousUrl) {\n      const previousUrl = this.lastUrl;\n      console.log('[URLSync] URL changed from', previousUrl, 'to', currentUrl);\n      const lastPath = normalizedPreviousUrl ? new URL(normalizedPreviousUrl).pathname : '';\n      const currentPath = new URL(normalizedCurrentUrl).pathname;\n      const lastWatchKey = this.getWatchKey(normalizedPreviousUrl);\n      const currentWatchKey = this.getWatchKey(normalizedCurrentUrl);\n      \n      // Check if we navigated to a different /watch page or left /watch\n      const wasOnWatch = lastPath.startsWith('/watch');\n      const wasOnBrowse = lastPath.startsWith('/browse');\n      const nowOnWatch = currentPath.startsWith('/watch');\n      const watchPageChanged = wasOnWatch && nowOnWatch && lastWatchKey !== currentWatchKey;\n      const navigatedToWatch = !wasOnWatch && nowOnWatch;\n      const navigatedFromBrowseToWatch = wasOnBrowse && nowOnWatch;\n      const leftWatch = wasOnWatch && !nowOnWatch;\n      \n      this.lastUrl = currentUrl;\n      this.lastNormalizedUrl = normalizedCurrentUrl;\n      \n      // If we navigated from browse to watch, set flag to respect Netflix auto-play\n      if (navigatedFromBrowseToWatch) {\n        console.log('[URLSync] Navigated from browse to /watch - setting auto-play flag');\n        sessionStorage.setItem('tandem_from_browse', 'true');\n      }\n      \n      // If we changed to a different /watch page, reinitialize sync\n      if (watchPageChanged) {\n        console.log('[URLSync] Watch page changed - triggering sync reinitialization');\n        try {\n          sessionStorage.setItem('tandem_watch_transition', JSON.stringify({\n            from: normalizedPreviousUrl || previousUrl,\n            to: normalizedCurrentUrl || currentUrl,\n            timestamp: Date.now()\n          }));\n        } catch (e) {\n          console.warn('[URLSync] Failed to record watch transition:', e);\n        }\n        this.onWatchPageChange();\n      }\n      \n      // If we navigated TO a /watch page from elsewhere, initialize sync\n      if (navigatedToWatch) {\n        console.log('[URLSync] Navigated to /watch page - triggering sync initialization');\n        this.onNavigateToWatch();\n      }\n      \n      // If we left a /watch page, teardown sync\n      if (leftWatch) {\n        console.log('[URLSync] Left /watch page - triggering sync teardown');\n        this.onLeaveWatch();\n      }\n      \n      const state = this.stateManager.getState();\n      \n      // For watch-to-watch transitions, check if this is auto-advance\n      // Auto-advance happens either:\n      // 1. Within 5 seconds of video ended event (credits skipped)\n      // 2. When URL changes and video is >90% through (near end)\n      const recentlyEnded = Date.now() - this.lastVideoEndedTime < 5000;\n      const recentlyPrompted = this.pendingAutoAdvanceUrl === normalizedPreviousUrl && (Date.now() - this.pendingAutoAdvanceTime < 60000);\n      let isLikelyAutoAdvance = recentlyEnded || recentlyPrompted;\n      \n      // Also check if video is near the end when URL changes\n      if (!isLikelyAutoAdvance && watchPageChanged && this.netflixController) {\n        this.netflixController.getPlayerState().then(playerState => {\n          if (playerState && playerState.duration && playerState.currentTime) {\n            const percentComplete = playerState.currentTime / playerState.duration;\n            if (percentComplete > 0.9) {\n              console.log('[URLSync] URL changed at', (percentComplete * 100).toFixed(1) + '% of video - likely auto-advance');\n              this.lastVideoEndedTime = Date.now();\n              this.recentAutoAdvanceUrl = normalizedPreviousUrl || previousUrl;\n              this.recentAutoAdvanceTime = Date.now();\n            }\n          }\n        }).catch(() => {});\n      }\n      \n      if (isLikelyAutoAdvance) {\n        this.recentAutoAdvanceUrl = normalizedPreviousUrl || previousUrl;\n        this.recentAutoAdvanceTime = Date.now();\n      }\n      \n      let shouldBroadcastUrl = !watchPageChanged || (watchPageChanged && !isLikelyAutoAdvance);\n      \n      if (watchPageChanged && isLikelyAutoAdvance) {\n        console.log('[URLSync] Auto-advance detected, not broadcasting');\n      }\n      \n      // Don't broadcast URL if we're in the middle of restoration or if this was triggered by a remote URL change\n      const isRestoring = sessionStorage.getItem('tandem_pending_sync') !== null;\n      const recentRemoteUrlChange = sessionStorage.getItem('tandem_last_remote_url');\n      const isEchoingRemoteUrl = recentRemoteUrlChange === normalizedCurrentUrl;\n      \n      if (state.partyActive && shouldBroadcastUrl && !isRestoring && !isEchoingRemoteUrl) {\n        console.log('[URLSync] Broadcasting URL change to party:', currentPath);\n        \n        // Get current time to sync all members to initiator's position\n        this.netflixController.getPlayerState().then(playerState => {\n          const currentTime = playerState?.currentTime || 0;\n          this.stateManager.safeSendMessage({ \n            type: 'URL_CHANGE', \n            url: normalizedCurrentUrl || currentUrl,\n            currentTime: currentTime\n          });\n        }).catch(err => {\n          console.warn('[URLSync] Failed to get current time, broadcasting without it:', err);\n          this.stateManager.safeSendMessage({ \n            type: 'URL_CHANGE', \n            url: normalizedCurrentUrl || currentUrl\n          });\n        });\n      } else if (isRestoring) {\n        console.log('[URLSync] Skipping URL broadcast - restoration in progress');\n      } else if (isEchoingRemoteUrl) {\n        console.log('[URLSync] Skipping URL broadcast - echoing remote URL change');\n        sessionStorage.removeItem('tandem_last_remote_url');\n      }\n      \n      // If someone leaves /watch, pause the video for everyone\n      if (state.partyActive && leftWatch) {\n        console.log('[URLSync] Left /watch page - sending pause to all clients');\n        this.stateManager.safeSendMessage({ \n          type: 'PLAY_PAUSE', \n          control: 'pause',\n          timestamp: 0\n        });\n      }\n    }\n  }\n  \n  start() { \n    this.lastUrl = window.location.href;\n    this.lastNormalizedUrl = this.normalizeUrl(this.lastUrl);\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\n    \n    // Clear any existing interval and listeners\n    this.stop();\n    \n    // Listen for popstate events (back/forward button, pushState)\n    window.addEventListener('popstate', this.handleUrlChange);\n    \n    // Listen for pushState/replaceState by monkey-patching\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.handleUrlChange();\n    };\n    \n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.handleUrlChange();\n    };\n    \n    // Also poll as a fallback (in case Netflix uses some other navigation method)\n    this.urlMonitorInterval = setInterval(() => {\n      this.handleUrlChange();\n    }, 500);\n    \n    // Listen for video ended event to detect auto-advance\n    const setupVideoListener = () => {\n      const video = document.querySelector('video');\n      if (video) {\n        if (this.videoEndListener) {\n          video.removeEventListener('ended', this.videoEndListener);\n        }\n        this.videoEndListener = () => {\n          console.log('[URLSync] Video ended - recording timestamp for auto-advance detection');\n          this.lastVideoEndedTime = Date.now();\n        };\n        video.addEventListener('ended', this.videoEndListener);\n        console.log('[URLSync] Attached ended listener to video element');\n      } else {\n        // Try again in a moment\n        setTimeout(setupVideoListener, 1000);\n      }\n    };\n    setupVideoListener();\n\n    const recordNextEpisodePrompt = () => {\n      const button = document.querySelector('[data-uia=\"next-episode-seamless-button\"]');\n      if (!button) return;\n      const now = Date.now();\n      if (now - this.pendingAutoAdvanceTime < 2000) return;\n      this.pendingAutoAdvanceUrl = this.lastNormalizedUrl || this.lastUrl;\n      this.pendingAutoAdvanceTime = now;\n      console.log('[URLSync] Next episode prompt detected - marking pending auto-advance');\n    };\n\n    // Observe DOM for the next-episode prompt button\n    if (this.nextEpisodeObserver) {\n      this.nextEpisodeObserver.disconnect();\n    }\n    this.nextEpisodeObserver = new MutationObserver(() => recordNextEpisodePrompt());\n    if (document.body) {\n      this.nextEpisodeObserver.observe(document.body, { childList: true, subtree: true, attributes: true });\n    }\n    recordNextEpisodePrompt();\n  }\n  \n  stop() {\n    console.log('[URLSync] Stopping URL monitoring');\n    \n    if (this.urlMonitorInterval) { \n      clearInterval(this.urlMonitorInterval); \n      this.urlMonitorInterval = null; \n    }\n    \n    if (this.videoEndListener) {\n      const videos = document.querySelectorAll('video');\n      videos.forEach(video => video.removeEventListener('ended', this.videoEndListener));\n      this.videoEndListener = null;\n    }\n\n    if (this.nextEpisodeObserver) {\n      this.nextEpisodeObserver.disconnect();\n      this.nextEpisodeObserver = null;\n    }\n    \n    window.removeEventListener('popstate', this.handleUrlChange);\n    \n    this.lastUrl = null;\n    this.lastNormalizedUrl = null;\n  }\n\n  normalizeUrl(url) {\n    if (!url) return null;\n    try {\n      const parsed = new URL(url);\n      const path = parsed.pathname;\n      if (!path.startsWith('/watch')) {\n        return parsed.origin + path;\n      }\n      const trackId = parsed.searchParams.get('trackId');\n      const normalized = trackId ? `${path}?trackId=${encodeURIComponent(trackId)}` : path;\n      return parsed.origin + normalized;\n    } catch (e) {\n      return url;\n    }\n  }\n\n  getWatchKey(url) {\n    if (!url) return '';\n    try {\n      const parsed = new URL(url);\n      if (!parsed.pathname.startsWith('/watch')) return parsed.pathname;\n      const trackId = parsed.searchParams.get('trackId');\n      return trackId ? `${parsed.pathname}?trackId=${trackId}` : parsed.pathname;\n    } catch (e) {\n      return url;\n    }\n  }\n  saveState() {\n    const state = this.stateManager.getState();\n    if (!state.partyActive) return;\n    const existing = this.getRestorationState() || {};\n    const payload = {\n      roomId: state.roomId,\n      currentTime: existing.currentTime || null,\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\n      timestamp: Date.now()\n    };\n    sessionStorage.setItem('tandem_restore', JSON.stringify(payload));\n  }\n  clearState() { sessionStorage.removeItem('tandem_restore'); }\n  getRestorationState() {\n    const stored = sessionStorage.getItem('tandem_restore');\n    if (!stored) return null;\n    try {\n      const state = JSON.parse(stored);\n      if (Date.now() - state.timestamp < 30000) { return state; }\n    } catch (e) { console.error('[tandem] Failed to parse restoration state:', e); }\n    return null;\n  }\n  \n  shouldSuppressSyncResponse(incomingUrl) {\n    if (!this.recentAutoAdvanceUrl || !incomingUrl) return false;\n    \n    const timeSinceAutoAdvance = Date.now() - this.recentAutoAdvanceTime;\n    if (timeSinceAutoAdvance > 30000) return false; // Auto-advance window expired\n    \n    // Extract episode IDs to compare\n    const incomingEpisodeId = this.extractEpisodeId(incomingUrl);\n    const autoAdvancedFromId = this.extractEpisodeId(this.recentAutoAdvanceUrl);\n    \n    if (incomingEpisodeId === autoAdvancedFromId) {\n      console.log(`[URLSync] Suppressing sync response - would revert auto-advance from ${incomingEpisodeId} (${timeSinceAutoAdvance}ms old)`);\n      return true;\n    }\n    return false;\n  }\n  \n  extractEpisodeId(url) {\n    if (!url) return null;\n    try {\n      const urlObj = new URL(url);\n      return urlObj.searchParams.get('trackId') || urlObj.pathname;\n    } catch (e) {\n      return null;\n    }\n  }\n}\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","MutableRef","value","get","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","console","warn","addTrack","log","wasPartyActive","sessionStorage","getItem","staleContainers","document","querySelectorAll","staleVideos","staleOverlays","staleLocalVideo","getElementById","staleWaitingIndicator","forEach","el","id","remove","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","setItem","stopParty","removeItem","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","safeSendMessage","message","callback","type","sendMessage","response","lastError","error","notice","createElement","style","cssText","innerHTML","body","appendChild","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","makeDraggable","element","currentX","currentY","initialX","initialY","isDragging","addEventListener","computedStyle","window","getComputedStyle","rect","bottom","left","right","getBoundingClientRect","top","clientX","clientY","opacity","preventDefault","maxX","innerWidth","offsetWidth","maxY","innerHeight","offsetHeight","Math","max","min","xPos","yPos","cursor","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","video","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","autoplay","muted","playsInline","position","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","play","err","clearAll","clear","removeConnectionIndicator","showConnectionIndicator","indicator","dot","text","textContent","head","updateConnectionIndicator","status","background","animation","netflixController","injectAPIBridge","script","getURL","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","getDuration","getPlayerState","isPaused","setVolume","level","getVolume","getVideoElement","location","pathname","startsWith","videos","syncManager","state","netflix","lock","isInitializedRef","listeners","initialSyncRequestAt","initialSyncWindowMs","lastKnownTimeSeconds","videoMonitorInterval","activeVideo","urlSync","hostUserId","heartbeatInterval","remote","shouldAcceptLateSync","onInitialSyncApplied","async","applyRemote","actionName","actionFn","applyLatencyCompensation","currentTime","isPlaying","eventTimestamp","Number","isFinite","handleRequestSync","fromUserId","respectAutoPlay","currentUrl","href","attemptSyncResponse","attempt","currentTimeSeconds","toFixed","targetUserId","url","handleSyncResponse","urlSyncInstance","shouldSuppressSyncResponse","currentPath","isOnWatch","isOnBrowse","otherIsOnWatch","JSON","stringify","timestamp","waitForLocalResume","i","localTimeMs","r","localPaused","localSeconds","finalPaused","handlePlaybackControl","control","toUpperCase","adjustedTime","localTime","drift","abs","handleSeek","handleSeekPause","readyState","settled","done","once","targetTime","handleHostHeartbeat","createRemoteHandlers","setUrlSync","setup","waitForVideo","pendingSeekTime","seekTime","parseFloat","waitForVideoReady","pendingSyncStr","pendingSync","parse","attachListeners","startVideoMonitor","broadcastAfterResume","resumed","timeoutId","broadcast","source","onSeeked","onTimeUpdate","clearTimeout","then","onVideoReady","requestSyncWhenReady","cleanup","handlePlay","handlePause","handleSeeked","onPlay","onPause","onSeek","onPositionUpdate","isInitialized","lockActive","positionUpdateInterval","setInterval","attachPlaybackListeners","vid","broadcastPlay","broadcastPause","broadcastSeek","broadcastPosition","isOnWatchPage","currentVideo","teardown","stopHostHeartbeat","reject","timeout","Error","check","currentTimeMs","paused","setHostUserId","updateHostHeartbeat","localUserId","startHostHeartbeat","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","ensureSpinnerStyles","createLoadingSpinner","spinner","className","peerId","getTracks","stop","container","parentElement","delete","domContainer","domElement","overlay","hideWaitingIndicator","add","size","Array","from","keys","existingInMap","existingInDom","existingContainer","t","backgroundColor","display","flexDirection","alignItems","justifyContent","color","fontSize","fontFamily","pointerEvents","fontWeight","activeTracks","filter","length","map","substring","join","playVideo","volume","name","checkTracks","parentNode","showReconnecting","hideOverlay","showPlaceholder","showWaitingIndicator","padding","gap","boxShadow","dots","createWaitingDots","letterSpacing","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","to","ontrack","streams","MediaStream","hasVideoInMap","has","hasVideoInDom","existingVideo","tracks","hasAudio","some","hasVideo","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","Object","assign","attempts","timeouts","handle","count","backoffDelay","pow","existing","oldPc","close","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","getReceivers","needsRenegotiation","signalingState","handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","iceConnectionState","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","JOIN","OFFER","ANSWER","ICE","LEAVE","onWatchPageChange","onNavigateToWatch","onLeaveWatch","urlMonitorInterval","lastUrl","lastNormalizedUrl","lastVideoEndedTime","videoEndListener","recentAutoAdvanceUrl","recentAutoAdvanceTime","pendingAutoAdvanceUrl","pendingAutoAdvanceTime","nextEpisodeObserver","handleUrlChange","bind","normalizedCurrentUrl","normalizeUrl","normalizedPreviousUrl","previousUrl","lastPath","lastWatchKey","getWatchKey","currentWatchKey","wasOnWatch","wasOnBrowse","nowOnWatch","watchPageChanged","navigatedToWatch","navigatedFromBrowseToWatch","leftWatch","recentlyEnded","recentlyPrompted","isLikelyAutoAdvance","playerState","duration","percentComplete","shouldBroadcastUrl","isRestoring","isEchoingRemoteUrl","start","originalPushState","history","pushState","originalReplaceState","replaceState","apply","setupVideoListener","querySelector","recordNextEpisodePrompt","disconnect","MutationObserver","observe","childList","subtree","attributes","parsed","path","origin","trackId","searchParams","normalized","encodeURIComponent","saveState","getRestorationState","payload","clearState","stored","incomingUrl","timeSinceAutoAdvance","incomingEpisodeId","extractEpisodeId","urlObj","videoElementMonitor","startVideoElementMonitoring","videoId","pin","title","toString","success","checkJoinFromLink","restorationState","navigator","mediaDevices","getUserMedia","audio","onMessage","addListener","request","sender","sendResponse","audioTrack","getAudioTracks","videoTrack","getVideoTracks","audioEnabled","enabled","videoEnabled","hasStream","newEnabled","transitionRaw","transition","withinWindow","isBounceBack","targetUrl","incomingPath","bothAreWatch","mergedUrl","incomingTrackId","undefined","PopStateEvent"],"ignoreList":[],"sourceRoot":""}