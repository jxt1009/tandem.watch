{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/src/managers/sync/lock.js","webpack://toperparty/./chrome-extension/src/managers/sync/eventListeners.js","webpack://toperparty/./chrome-extension/src/managers/sync/SyncManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://toperparty/./chrome-extension/src/content/main.js","webpack://toperparty/./chrome-extension/src/managers/state/StateManager.js","webpack://toperparty/./chrome-extension/src/ui/UIManager.js","webpack://toperparty/./chrome-extension/src/content/netflix/NetflixController.js","webpack://toperparty/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://toperparty/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://toperparty/./chrome-extension/src/services/webrtc/ui.js","webpack://toperparty/./chrome-extension/src/services/webrtc/reconnect.js","webpack://toperparty/./chrome-extension/src/services/webrtc/signaling.js","webpack://toperparty/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\r\n  constructor() {\r\n    this.suppressLocalUntil = 0;\r\n  }\r\n  set(durationMs) {\r\n    this.suppressLocalUntil = Date.now() + durationMs;\r\n  }\r\n  isActive() {\r\n    return Date.now() < this.suppressLocalUntil;\r\n  }\r\n}\r\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek }) {\r\n  const handlePlay = () => {\r\n    console.log('[EventListeners] Play event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring play - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring play - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring play - lock active'); return; }\r\n    console.log('[EventListeners] Play event detected - broadcasting');\r\n    onPlay(video);\r\n  };\r\n\r\n  const handlePause = () => {\r\n    console.log('[EventListeners] Pause event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring pause - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring pause - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring pause - lock active'); return; }\r\n    console.log('[EventListeners] Pause event detected - broadcasting');\r\n    onPause(video);\r\n  };\r\n\r\n  const handleSeeked = () => {\r\n    console.log('[EventListeners] Seek event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring seek - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring seek - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring seek - lock active'); return; }\r\n    console.log('[EventListeners] Seek event detected - broadcasting');\r\n    onSeek(video);\r\n  };\r\n\r\n  video.addEventListener('play', handlePlay);\r\n  video.addEventListener('pause', handlePause);\r\n  video.addEventListener('seeked', handleSeeked);\r\n  console.log('[EventListeners] Event listeners attached to video element');\r\n\r\n  return { video, handlePlay, handlePause, handleSeeked };\r\n}\r\n","import { SyncLock } from './lock.js';\r\nimport { attachPlaybackListeners } from './eventListeners.js';\r\nimport { createRemoteHandlers } from './remoteHandlers.js';\r\n\r\nclass MutableRef {\r\n  constructor(value) { this.value = value; }\r\n  get() { return this.value; }\r\n  set(v) { this.value = v; }\r\n}\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n    this.lock = new SyncLock();\r\n    this.isInitializedRef = new MutableRef(false);\r\n    this.listeners = null;\r\n\r\n    this.remote = createRemoteHandlers({\r\n      state: this.state,\r\n      netflix: this.netflix,\r\n      lock: this.lock,\r\n      isInitializedRef: this.isInitializedRef,\r\n    });\r\n  }\r\n\r\n  async setup() {\r\n    try {\r\n      console.log('[SyncManager] Starting setup - waiting for video element...');\r\n      const video = await this.waitForVideo();\r\n      if (!video) { \r\n        console.warn('[SyncManager] Netflix video element not found'); \r\n        return; \r\n      }\r\n      \r\n      console.log('[SyncManager] Video element found, setting up event listeners');\r\n      \r\n      // Check for pending sync from URL navigation\r\n      const pendingSyncStr = sessionStorage.getItem('toperparty_pending_sync');\r\n      if (pendingSyncStr) {\r\n        try {\r\n          const pendingSync = JSON.parse(pendingSyncStr);\r\n          if (Date.now() - pendingSync.timestamp < 10000) {\r\n            console.log('[SyncManager] Applying pending sync from URL navigation');\r\n            sessionStorage.removeItem('toperparty_pending_sync');\r\n            this.isInitializedRef.set(true);\r\n            \r\n            // Apply the pending sync state\r\n            this.lock.set(1500);\r\n            await this.netflix.seek(pendingSync.currentTime * 1000);\r\n            const isPaused = await this.netflix.isPaused();\r\n            if (pendingSync.isPlaying && isPaused) {\r\n              await this.netflix.play();\r\n            } else if (!pendingSync.isPlaying && !isPaused) {\r\n              await this.netflix.pause();\r\n            }\r\n            \r\n            const listeners = attachPlaybackListeners({\r\n              video,\r\n              state: this.state,\r\n              isInitializedRef: this.isInitializedRef,\r\n              lock: this.lock,\r\n              onPlay: (vid) => this.broadcastPlay(vid),\r\n              onPause: (vid) => this.broadcastPause(vid),\r\n              onSeek: (vid) => this.broadcastSeek(vid)\r\n            });\r\n            this.listeners = listeners;\r\n            console.log('[SyncManager] Setup complete with pending sync applied');\r\n            return;\r\n          } else {\r\n            console.log('[SyncManager] Pending sync expired, ignoring');\r\n            sessionStorage.removeItem('toperparty_pending_sync');\r\n          }\r\n        } catch (e) {\r\n          console.error('[SyncManager] Error applying pending sync:', e);\r\n          sessionStorage.removeItem('toperparty_pending_sync');\r\n        }\r\n      }\r\n      \r\n      this.isInitializedRef.set(false);\r\n      \r\n      // Request initial sync from other clients\r\n      console.log('[SyncManager] Requesting initial sync from other clients');\r\n      this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n      \r\n      // If no response after 2 seconds, consider ourselves initialized\r\n      setTimeout(() => {\r\n        if (!this.isInitializedRef.get()) {\r\n          console.log('[SyncManager] No sync response received after 2s, marking as initialized');\r\n          this.isInitializedRef.set(true);\r\n          console.log('[SyncManager] isInitialized is now:', this.isInitializedRef.get());\r\n        } else {\r\n          console.log('[SyncManager] Already initialized, skipping timeout initialization');\r\n        }\r\n      }, 2000);\r\n      \r\n      const listeners = attachPlaybackListeners({\r\n        video,\r\n        state: this.state,\r\n        isInitializedRef: this.isInitializedRef,\r\n        lock: this.lock,\r\n        onPlay: (vid) => this.broadcastPlay(vid),\r\n        onPause: (vid) => this.broadcastPause(vid),\r\n        onSeek: (vid) => this.broadcastSeek(vid)\r\n      });\r\n      this.listeners = listeners;\r\n      console.log('[SyncManager] Setup complete - ready to sync');\r\n    } catch (err) { \r\n      console.error('[SyncManager] Error setting up playback sync:', err); \r\n    }\r\n  }\r\n\r\n  teardown() {\r\n    console.log('[SyncManager] Tearing down sync manager');\r\n    if (this.listeners && this.listeners.video) {\r\n      const { video, handlePlay, handlePause, handleSeeked } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', handlePlay);\r\n        video.removeEventListener('pause', handlePause);\r\n        video.removeEventListener('seeked', handleSeeked);\r\n        console.log('[SyncManager] Event listeners removed');\r\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\r\n      this.listeners = null;\r\n    }\r\n    this.isInitializedRef.set(false);\r\n  }\r\n\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) { clearTimeout(timeout); resolve(video); }\r\n        else { setTimeout(check, 100); }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n\r\n  isOnWatchPage() {\r\n    return window.location.pathname.startsWith('/watch');\r\n  }\r\n\r\n  broadcastPlay(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PLAY event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'play', \r\n      currentTime: video.currentTime \r\n    });\r\n  }\r\n\r\n  broadcastPause(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PAUSE event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'pause', \r\n      currentTime: video.currentTime \r\n    });\r\n  }\r\n\r\n  broadcastSeek(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\r\n    this.state.safeSendMessage({ \r\n      type: 'SEEK', \r\n      currentTime: video.currentTime, \r\n      isPlaying: !video.paused \r\n    });\r\n  }\r\n\r\n  // Remote event handlers\r\n  handleRequestSync(fromUserId) { return this.remote.handleRequestSync(fromUserId); }\r\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url) { return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url); }\r\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\r\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\r\n}\r\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft }) {\r\n  return function createPeerConnection(peerId) {\r\n    const state = stateManager.getState();\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: [\r\n        { urls: ['stun:stun.l.google.com:19302'] },\r\n        { urls: ['stun:stun1.l.google.com:19302'] }\r\n      ]\r\n    });\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\r\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n      }\r\n    };\r\n    pc.ontrack = (event) => {\r\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\r\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\r\n      if (!stream) {\r\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\r\n        stream = new MediaStream();\r\n        remoteStreams.set(peerId, stream);\r\n      }\r\n      if (event.track) {\r\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\r\n        try { stream.addTrack(event.track); } catch (e) {\r\n          console.warn('[PeerConnection] Error adding track:', e);\r\n        }\r\n      }\r\n      if (!remoteVideos.has(peerId)) {\r\n        console.log('[PeerConnection] Adding remote video for peer:', peerId, 'stream tracks:', stream.getTracks().length);\r\n        addRemoteVideo(peerId, stream);\r\n      }\r\n    };\r\n    pc.onconnectionstatechange = () => {\r\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, 'â†’', pc.connectionState);\r\n      if (pc.connectionState === 'connected') {\r\n        clearReconnection(peerId);\r\n      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\r\n        if (peersThatLeft.has(peerId)) {\r\n          removeRemoteVideo(peerId);\r\n          clearReconnection(peerId);\r\n        } else {\r\n          removeRemoteVideo(peerId);\r\n          attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'closed') {\r\n        removeRemoteVideo(peerId);\r\n        clearReconnection(peerId);\r\n      }\r\n    };\r\n    return pc;\r\n  };\r\n}\r\n\r\nexport function addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\r\n  } else {\r\n    try { pc.addTrack(track, stream); } catch (e) {}\r\n  }\r\n}\r\n","import { StateManager } from '../managers/state/StateManager.js';\r\nimport { NetflixController } from './netflix/NetflixController.js';\r\nimport { SyncManager } from '../managers/sync/SyncManager.js';\r\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\r\nimport { UIManager } from '../ui/UIManager.js';\r\nimport { URLSync } from '../managers/url/URLSync.js';\r\n\r\nconsole.log('[Content Script] Initializing managers...');\r\nconst stateManager = new StateManager();\r\nconst uiManager = new UIManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\r\n\r\n// Callback when we navigate to a different /watch page\r\nconst handleWatchPageChange = () => {\r\n  console.log('[Content Script] Watch page changed - reinitializing sync manager');\r\n  syncManager.teardown();\r\n  syncManager.setup().catch(err => {\r\n    console.error('[Content Script] Failed to reinitialize sync manager:', err);\r\n  });\r\n};\r\n\r\nconst urlSync = new URLSync(stateManager, handleWatchPageChange);\r\nconsole.log('[Content Script] Managers initialized');\r\n\r\nlet localStream = null;\r\nlet videoElementMonitor = null;\r\n\r\n// Monitor and restore video elements if they get removed during navigation\r\nfunction startVideoElementMonitoring() {\r\n  if (videoElementMonitor) return;\r\n  \r\n  videoElementMonitor = setInterval(() => {\r\n    const state = stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    \r\n    // Check if local preview exists\r\n    if (localStream && !document.getElementById('toperparty-local-preview')) {\r\n      console.log('[Content Script] Local preview missing, re-attaching');\r\n      uiManager.attachLocalPreview(localStream);\r\n    }\r\n    \r\n    // Check if remote videos exist\r\n    const remoteVideos = uiManager.getRemoteVideos();\r\n    const remoteStreams = uiManager.getRemoteStreams();\r\n    remoteStreams.forEach((stream, peerId) => {\r\n      const videoId = 'toperparty-remote-' + peerId;\r\n      if (!document.getElementById(videoId)) {\r\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\r\n        const videoManager = webrtcManager.videoManager;\r\n        if (videoManager && videoManager.add) {\r\n          videoManager.add(peerId, stream);\r\n        }\r\n      }\r\n    });\r\n  }, 1000); // Check every second\r\n  \r\n  console.log('[Content Script] Started video element monitoring');\r\n}\r\n\r\nfunction stopVideoElementMonitoring() {\r\n  if (videoElementMonitor) {\r\n    clearInterval(videoElementMonitor);\r\n    videoElementMonitor = null;\r\n    console.log('[Content Script] Stopped video element monitoring');\r\n  }\r\n}\r\n\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\r\n    urlSync.clearState();\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    setTimeout(function() {\r\n      console.log('[Content Script] Sending RESTORE_PARTY message');\r\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\r\n        if (response && response.success) {\r\n          console.log('[Content Script] Party restoration successful - media stream and sync will be re-initialized');\r\n        } else {\r\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\r\n        }\r\n        setTimeout(function() {\r\n          stateManager.setRestoringFlag(false);\r\n        }, 2000);\r\n      });\r\n    }, 1000);\r\n  }\r\n})();\r\n\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  console.log('[Content Script] Received message:', request.type);\r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\r\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n      .then(stream => {\r\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\r\n        localStream = stream;\r\n        console.log('[Content Script] Setting local stream on WebRTC manager');\r\n        webrtcManager.setLocalStream(stream);\r\n        webrtcManager.onLocalStreamAvailable(stream);\r\n        console.log('[Content Script] Attaching local preview to UI');\r\n        uiManager.attachLocalPreview(stream);\r\n        console.log('[Content Script] Local preview attached, sending success response');\r\n        sendResponse({ success: true });\r\n      })\r\n      .catch(err => {\r\n        console.error('[Content Script] Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    \r\n    // Teardown existing sync manager if already set up\r\n    syncManager.teardown();\r\n    \r\n    // Setup sync manager (will wait for video element)\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to setup sync manager:', err);\r\n    });\r\n    \r\n    urlSync.start();\r\n    startVideoElementMonitoring();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    console.log('[Content Script] Stopping party');\r\n    stopVideoElementMonitoring();\r\n    stateManager.stopParty();\r\n    syncManager.teardown();\r\n    urlSync.stop();\r\n    urlSync.clearState();\r\n    webrtcManager.clearAll();\r\n    uiManager.removeLocalPreview();\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(t => t.stop());\r\n      localStream = null;\r\n    }\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SIGNAL') {\r\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\r\n    webrtcManager.handleSignal(request.message);\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\r\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\r\n  }\r\n\r\n  // Passive sync removed - using event-based sync only\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('[Content Script] Received URL change request:', request.url, 'from', request.fromUserId);\r\n    \r\n    if (stateManager.restoringPartyState) {\r\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\r\n      return;\r\n    }\r\n    \r\n    // Only apply URL changes to /watch pages\r\n    const incomingUrl = new URL(request.url);\r\n    const currentPath = window.location.pathname;\r\n    const isOnWatch = currentPath.startsWith('/watch');\r\n    const incomingIsWatch = incomingUrl.pathname.startsWith('/watch');\r\n    \r\n    if (!incomingIsWatch) {\r\n      console.log('[Content Script] Ignoring URL change - incoming URL is not a /watch page:', incomingUrl.pathname);\r\n      return;\r\n    }\r\n    \r\n    if (!isOnWatch) {\r\n      console.log('[Content Script] Ignoring URL change - not currently on a /watch page (on:', currentPath + ')');\r\n      return;\r\n    }\r\n    \r\n    console.log('[Content Script] Navigating to new watch page:', request.url);\r\n    // Save state before navigating\r\n    urlSync.saveState();\r\n    window.location.href = request.url;\r\n  }\r\n\r\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\r\n    syncManager.handleRequestSync(request.fromUserId);\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\r\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url);\r\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url);\r\n  }\r\n\r\n  if (request.type === 'REQUEST_INITIAL_SYNC_AND_PLAY') {\r\n    console.log('[Content Script] Requesting initial sync and will auto-play when synced');\r\n    // Request sync from other clients\r\n    stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n  }\r\n});\r\n\r\nwindow.addEventListener('beforeunload', () => {\r\n  if (stateManager.isActive()) {\r\n    urlSync.saveState();\r\n  }\r\n});\r\n","export class StateManager {\r\n  constructor() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n  }\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n  }\r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n  }\r\n  isActive() { return this.partyActive; }\r\n  getUserId() { return this.userId; }\r\n  getRoomId() { return this.roomId; }\r\n  getState() {\r\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\r\n  }\r\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\r\n  setRestoringFlag(value) { this.restoringPartyState = value; }\r\n  isExtensionContextValid() {\r\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\r\n  }\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('[StateManager] Extension context invalid - page needs reload after extension update');\r\n      // Show user notification that they need to reload\r\n      if (!document.getElementById('toperparty-reload-notice')) {\r\n        const notice = document.createElement('div');\r\n        notice.id = 'toperparty-reload-notice';\r\n        notice.style.cssText = 'position:fixed;top:20px;right:20px;background:#e50914;color:white;padding:15px;border-radius:8px;z-index:99999;font-family:Arial;box-shadow:0 4px 6px rgba(0,0,0,0.3);';\r\n        notice.innerHTML = '<strong>ToperParty:</strong> Extension updated. Please reload this page.';\r\n        document.body.appendChild(notice);\r\n      }\r\n      return;\r\n    }\r\n    console.log('[StateManager] Sending message:', message.type, message);\r\n    try { \r\n      chrome.runtime.sendMessage(message, callback); \r\n    } catch (e) { \r\n      console.warn('[StateManager] Failed to send message:', e.message); \r\n    }\r\n  }\r\n}\r\n","export class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n  getRemoteVideos() { return this.remoteVideos; }\r\n  getRemoteStreams() { return this.remoteStreams; }\r\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\r\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\r\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\r\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n\r\n  attachLocalPreview(stream) {\r\n    console.log('[UIManager] Attaching local preview with stream:', stream);\r\n    this.removeLocalPreview();\r\n    \r\n    const v = document.createElement('video');\r\n    v.id = 'toperparty-local-preview';\r\n    v.autoplay = true;\r\n    v.muted = true; // Always mute local preview to avoid feedback\r\n    v.playsInline = true;\r\n    v.style.position = 'fixed';\r\n    v.style.bottom = '20px';\r\n    v.style.left = '20px';\r\n    v.style.width = '240px';\r\n    v.style.height = '160px';\r\n    v.style.zIndex = '10001';\r\n    v.style.border = '2px solid #e50914';\r\n    v.style.borderRadius = '4px';\r\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n    try {\r\n      v.srcObject = stream;\r\n      console.log('[UIManager] Set srcObject on local preview');\r\n    } catch (e) {\r\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\r\n      v.src = URL.createObjectURL(stream);\r\n    }\r\n\r\n    document.body.appendChild(v);\r\n    this.localPreviewVideo = v;\r\n    console.log('[UIManager] Local preview video appended to body');\r\n\r\n    v.play().catch(err => {\r\n      console.warn('[UIManager] Local preview play() failed:', err);\r\n    });\r\n  }\r\n\r\n  removeLocalPreview() {\r\n    if (this.localPreviewVideo) {\r\n      console.log('[UIManager] Removing local preview video');\r\n      try {\r\n        if (this.localPreviewVideo.srcObject) {\r\n          this.localPreviewVideo.srcObject = null;\r\n        }\r\n      } catch (e) {\r\n        console.warn('[UIManager] Error clearing srcObject:', e);\r\n      }\r\n      this.localPreviewVideo.remove();\r\n      this.localPreviewVideo = null;\r\n    }\r\n  }\r\n\r\n  clearAll() {\r\n    this.removeLocalPreview();\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n  }\r\n}\r\n","export class NetflixController {\r\n  constructor() { this.injectAPIBridge(); }\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() { script.remove(); };\r\n  }\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__toperparty_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__toperparty_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000);\r\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  play() { return this._sendCommand('play'); }\r\n  pause() { return this._sendCommand('pause'); }\r\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\r\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\r\n  isPaused() { return this._sendCommand('isPaused'); }\r\n  getVideoElement() { return document.querySelector('video'); }\r\n}\r\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef }) {\r\n  async function applyRemote(actionName, durationMs, actionFn) {\r\n    lock.set(durationMs);\r\n    try { await actionFn(); } catch (err) {\r\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\r\n    }\r\n  }\r\n\r\n  return {\r\n    async handleRequestSync(fromUserId) {\r\n      if (!isInitializedRef.get()) {\r\n        console.log('[SyncManager] Not yet initialized, ignoring sync request');\r\n        return;\r\n      }\r\n      \r\n      const currentUrl = window.location.href;\r\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\r\n      \r\n      // If we're on browse page, don't send sync response\r\n      if (!isOnWatchPage) {\r\n        console.log('[SyncManager] On browse page, not sending sync response');\r\n        return;\r\n      }\r\n      \r\n      try {\r\n        const currentTime = await netflix.getCurrentTime();\r\n        const isPaused = await netflix.isPaused();\r\n        \r\n        if (currentTime == null) {\r\n          console.log('[SyncManager] Invalid playback state, ignoring sync request');\r\n          return;\r\n        }\r\n        \r\n        const currentTimeSeconds = currentTime / 1000;\r\n        console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl);\r\n        \r\n        state.safeSendMessage({\r\n          type: 'SYNC_RESPONSE',\r\n          targetUserId: fromUserId,\r\n          currentTime: currentTimeSeconds,\r\n          isPlaying: !isPaused,\r\n          url: currentUrl\r\n        });\r\n      } catch (e) { console.error('[SyncManager] Error handling sync request:', e); }\r\n    },\r\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url) {\r\n      if (isInitializedRef.get()) {\r\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\r\n        return;\r\n      }\r\n      \r\n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\r\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\r\n        return;\r\n      }\r\n      \r\n      console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\r\n      \r\n      // Check if we need to navigate to a different URL\r\n      const currentUrl = window.location.href;\r\n      const currentPath = window.location.pathname;\r\n      const isOnWatch = currentPath.startsWith('/watch');\r\n      const isOnBrowse = currentPath.startsWith('/browse');\r\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\r\n      \r\n      // Only navigate if we're NOT on a /watch page and the other user IS on /watch\r\n      // This allows initial sync to pull you to the watch page, but won't pull you back if you leave\r\n      if (!isOnWatch && otherIsOnWatch && isOnBrowse) {\r\n        console.log('[SyncManager] On browse page during initial join, other user on /watch - navigating to their show');\r\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n      \r\n      // If we're not on /watch at all, ignore this sync response\r\n      if (!isOnWatch) {\r\n        console.log('[SyncManager] Not on /watch page - ignoring sync response');\r\n        isInitializedRef.set(true); // Mark as initialized so we don't keep processing these\r\n        return;\r\n      }\r\n      \r\n      // Regular URL mismatch handling\r\n      if (url && url !== currentUrl) {\r\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\r\n        // Store the sync state to apply after navigation\r\n        sessionStorage.setItem('toperparty_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        // Navigate to the correct URL\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n      \r\n      isInitializedRef.set(true);\r\n      \r\n      await applyRemote('initial-sync', 1500, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        const localPaused = await netflix.isPaused();\r\n        \r\n        // Always sync to the remote state\r\n        if (isPlaying && localPaused) {\r\n          console.log('[SyncManager] Remote is playing, starting playback');\r\n          await netflix.play();\r\n        } else if (!isPlaying && !localPaused) {\r\n          console.log('[SyncManager] Remote is paused, pausing playback');\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    },\r\n    async handlePlaybackControl(control, currentTime, fromUserId) {\r\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'at', currentTime, 'from', fromUserId);\r\n      \r\n      await applyRemote(control, 1000, async () => {\r\n        // Seek to the exact position first\r\n        if (currentTime != null) {\r\n          const currentTimeMs = currentTime * 1000;\r\n          await netflix.seek(currentTimeMs);\r\n          console.log('[SyncManager] Seeked to', currentTime.toFixed(2) + 's before', control);\r\n        }\r\n        \r\n        // Then apply play/pause\r\n        if (control === 'play') {\r\n          await netflix.play();\r\n        } else {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    },\r\n    async handleSeek(currentTime, isPlaying, fromUserId) {\r\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\r\n      \r\n      await applyRemote('seek', 1200, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        const isPaused = await netflix.isPaused();\r\n        \r\n        if (isPlaying && isPaused) {\r\n          await netflix.play();\r\n        } else if (!isPlaying && !isPaused) {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    }\r\n  };\r\n}\r\n","import { createSignalingHandlers } from './signaling.js';\r\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\r\nimport { createReconnectionManager } from './reconnect.js';\r\nimport { createRemoteVideoManager } from './ui.js';\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager, uiManager) {\r\n    this.stateManager = stateManager;\r\n    this.uiManager = uiManager;\r\n    this.peerConnections = new Map();\r\n    this.remoteStreams = this.uiManager.getRemoteStreams();\r\n    this.remoteVideos = this.uiManager.getRemoteVideos();\r\n    this.peersThatLeft = new Set();\r\n    this.localStream = null;\r\n\r\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\r\n    \r\n    // Create a placeholder object for circular dependency resolution\r\n    const reconnectionManager = {};\r\n    \r\n    const createPeer = createPeerConnectionFactory({\r\n      stateManager: this.stateManager,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      remoteStreams: this.remoteStreams,\r\n      remoteVideos: this.remoteVideos,\r\n      addRemoteVideo: videoManager.add,\r\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\r\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      },\r\n      peersThatLeft: this.peersThatLeft\r\n    });\r\n\r\n    // Now create the actual reconnection manager with createPeer available\r\n    Object.assign(reconnectionManager, createReconnectionManager({\r\n      stateManager: this.stateManager,\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      localStream: () => this.localStream,\r\n      createPeer: createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack\r\n    }));\r\n\r\n    this.reconnectionManager = reconnectionManager;\r\n    this.createPeer = createPeer;\r\n    this.videoManager = videoManager;\r\n\r\n    this.signalingHandlers = createSignalingHandlers({\r\n      getState: () => this.stateManager.getState(),\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      getLocalStream: () => this.localStream,\r\n      createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack,\r\n      clearReconnection: reconnectionManager.clear,\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      }\r\n    });\r\n  }\r\n\r\n  setLocalStream(stream) { this.localStream = stream; }\r\n  getLocalStream() { return this.localStream; }\r\n  \r\n  onLocalStreamAvailable(stream) {\r\n    this.localStream = stream;\r\n    this.peerConnections.forEach((pc) => {\r\n      try {\r\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n      } catch (e) {}\r\n    });\r\n  }\r\n\r\n  async handleSignal(message) {\r\n    console.log('[WebRTCManager] handleSignal called with:', message);\r\n    if (!message || !message.type) {\r\n      console.warn('[WebRTCManager] Invalid message:', message);\r\n      return;\r\n    }\r\n    const type = message.type;\r\n    const from = message.userId || message.from;\r\n    const to = message.to;\r\n    const state = this.stateManager.getState();\r\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\r\n    \r\n    if (to && to !== state.userId) {\r\n      console.log('[WebRTCManager] Ignoring message not meant for me');\r\n      return;\r\n    }\r\n\r\n    if (type === 'JOIN' && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleJoin');\r\n      await this.signalingHandlers.handleJoin(from);\r\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleOffer');\r\n      await this.signalingHandlers.handleOffer(from, message.offer);\r\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\r\n      await this.signalingHandlers.handleAnswer(from, message.answer);\r\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\r\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\r\n    } else if (type === 'LEAVE' && from) {\r\n      console.log('[WebRTCManager] Dispatching to handleLeave');\r\n      this.signalingHandlers.handleLeave(from);\r\n    } else {\r\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'conditions not met');\r\n    }\r\n  }\r\n\r\n  attemptReconnection(peerId) {\r\n    return this.reconnectionManager.attempt(peerId);\r\n  }\r\n\r\n  _sendSignal(message) {\r\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\r\n  }\r\n\r\n  clearAll() {\r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n    this.peersThatLeft.clear();\r\n    this.remoteVideos.forEach((v) => {\r\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\r\n      v.remove();\r\n    });\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","export function createRemoteVideoManager(remoteVideos) {\r\n  function add(peerId, stream) {\r\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\r\n    remove(peerId);\r\n    const v = document.createElement('video');\r\n    v.id = 'toperparty-remote-' + peerId;\r\n    v.autoplay = true;\r\n    v.playsInline = true;\r\n    v.muted = true;\r\n    v.style.position = 'fixed';\r\n    v.style.bottom = '20px';\r\n    v.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n    v.style.width = '240px';\r\n    v.style.height = '160px';\r\n    v.style.zIndex = 10001;\r\n    v.style.border = '2px solid #00aaff';\r\n    v.style.borderRadius = '4px';\r\n    console.log('[RemoteVideoManager] Created video element:', v.id, 'at position:', v.style.right);\r\n    try { \r\n      v.srcObject = stream;\r\n      console.log('[RemoteVideoManager] Set srcObject successfully');\r\n    } catch (e) { \r\n      console.warn('[RemoteVideoManager] srcObject failed, trying createObjectURL:', e);\r\n      v.src = URL.createObjectURL(stream); \r\n    }\r\n    document.body.appendChild(v);\r\n    console.log('[RemoteVideoManager] Appended video to body');\r\n    remoteVideos.set(peerId, v);\r\n    try {\r\n      v.play().then(() => {\r\n        console.log('[RemoteVideoManager] Video playing, unmuting');\r\n        v.muted = false;\r\n        v.volume = 1.0;\r\n      }).catch((e) => { \r\n        console.warn('[RemoteVideoManager] Play failed:', e);\r\n        v.muted = false; \r\n      });\r\n    } catch (e) {\r\n      console.warn('[RemoteVideoManager] Error calling play:', e);\r\n    }\r\n  }\r\n  \r\n  function remove(peerId) {\r\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\r\n    const v = remoteVideos.get(peerId);\r\n    if (v) {\r\n      try { if (v.srcObject) v.srcObject = null; } catch (e) {}\r\n      v.remove();\r\n      remoteVideos.delete(peerId);\r\n    }\r\n  }\r\n  \r\n  return { add, remove };\r\n}\r\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\r\n  const attempts = new Map();\r\n  const timeouts = new Map();\r\n  \r\n  function clear(peerId) {\r\n    attempts.delete(peerId);\r\n    const handle = timeouts.get(peerId);\r\n    if (handle) {\r\n      clearTimeout(handle);\r\n      timeouts.delete(peerId);\r\n    }\r\n  }\r\n  \r\n  async function attempt(peerId) {\r\n    if (!stateManager.isInParty()) return;\r\n    if (peersThatLeft.has(peerId)) {\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    const count = attempts.get(peerId) || 0;\r\n    const maxAttempts = 5;\r\n    const backoffDelay = Math.min(1000 * Math.pow(2, count), 30000);\r\n    if (count >= maxAttempts) {\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    attempts.set(peerId, count + 1);\r\n    const existing = timeouts.get(peerId);\r\n    if (existing) clearTimeout(existing);\r\n    const handle = setTimeout(async () => {\r\n      const oldPc = peerConnections.get(peerId);\r\n      if (oldPc) {\r\n        try { oldPc.close(); } catch (e) {}\r\n        peerConnections.delete(peerId);\r\n      }\r\n      try {\r\n        const pc = createPeer(peerId);\r\n        peerConnections.set(peerId, pc);\r\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n        }\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        const state = stateManager.getState();\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[WebRTCManager] Reconnection failed:', err);\r\n        attempt(peerId);\r\n      }\r\n    }, backoffDelay);\r\n    timeouts.set(peerId, handle);\r\n  }\r\n  \r\n  return { attempt, clear };\r\n}\r\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\r\n  return {\r\n    async handleJoin(from) {\r\n      console.log('[Signaling] Handling JOIN from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring JOIN from self');\r\n        return;\r\n      }\r\n      peersThatLeft.delete(from);\r\n      if (peerConnections.has(from)) {\r\n        console.log('[Signaling] Already have peer connection for', from);\r\n        return;\r\n      }\r\n      try {\r\n        console.log('[Signaling] Creating peer connection for', from);\r\n        const pc = createPeer(from);\r\n        peerConnections.set(from, pc);\r\n        const stream = getLocalStream();\r\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => {\r\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n            addOrReplaceTrack(pc, t, stream);\r\n          });\r\n        } else {\r\n          console.warn('[Signaling] No local stream available when handling JOIN');\r\n        }\r\n        console.log('[Signaling] Creating and sending OFFER to', from);\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[Signaling] Error handling JOIN:', err);\r\n        peerConnections.delete(from);\r\n      }\r\n    },\r\n    async handleOffer(from, offer) {\r\n      console.log('[Signaling] Handling OFFER from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring OFFER from self');\r\n        return;\r\n      }\r\n      let pc = peerConnections.get(from);\r\n      if (pc && pc.signalingState !== 'closed') {\r\n        console.log('[Signaling] Closing existing peer connection');\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n        pc = null;\r\n      }\r\n      if (!pc) {\r\n        console.log('[Signaling] Creating new peer connection for', from);\r\n        pc = createPeer(from);\r\n        peerConnections.set(from, pc);\r\n      }\r\n      try {\r\n        console.log('[Signaling] Setting remote description');\r\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n        const stream = getLocalStream();\r\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => {\r\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n            addOrReplaceTrack(pc, t, stream);\r\n          });\r\n        } else {\r\n          console.warn('[Signaling] No local stream available when handling OFFER');\r\n        }\r\n        console.log('[Signaling] Creating and sending ANSWER to', from);\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[Signaling] Error handling offer:', err);\r\n        peerConnections.delete(from);\r\n        try { pc.close(); } catch (e) {}\r\n      }\r\n    },\r\n    async handleAnswer(from, answer) {\r\n      console.log('[Signaling] Handling ANSWER from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc && pc.signalingState === 'have-local-offer') {\r\n        console.log('[Signaling] Setting remote description from ANSWER');\r\n        try {\r\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n          console.log('[Signaling] Remote description set successfully');\r\n        } catch (err) {\r\n          console.error('[Signaling] Error handling answer:', err);\r\n        }\r\n      } else {\r\n        console.warn('[Signaling] Cannot handle ANSWER - pc:', !!pc, 'signalingState:', pc?.signalingState);\r\n      }\r\n    },\r\n    async handleIceCandidate(from, candidate) {\r\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try {\r\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n          console.log('[Signaling] ICE candidate added successfully');\r\n        } catch (err) {\r\n          console.warn('[Signaling] Error adding ICE candidate', err);\r\n        }\r\n      } else {\r\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\r\n      }\r\n    },\r\n    handleLeave(from) {\r\n      console.log('[Signaling] Handling LEAVE from', from);\r\n      peersThatLeft.add(from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n      }\r\n      clearReconnection(from);\r\n      removeRemoteVideo(from);\r\n    }\r\n  };\r\n}\r\n","export class URLSync {\r\n  constructor(stateManager, onWatchPageChange) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n    this.onWatchPageChange = onWatchPageChange || (() => {});\r\n  }\r\n  \r\n  start() { \r\n    this.lastUrl = window.location.href;\r\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\r\n    \r\n    // Clear any existing interval\r\n    if (this.urlMonitorInterval) {\r\n      clearInterval(this.urlMonitorInterval);\r\n    }\r\n    \r\n    // Monitor for URL changes every 500ms\r\n    this.urlMonitorInterval = setInterval(() => {\r\n      const currentUrl = window.location.href;\r\n      if (currentUrl !== this.lastUrl) {\r\n        console.log('[URLSync] URL changed from', this.lastUrl, 'to', currentUrl);\r\n        const lastPath = this.lastUrl ? new URL(this.lastUrl).pathname : '';\r\n        const currentPath = new URL(currentUrl).pathname;\r\n        \r\n        // Check if we navigated to a different /watch page or left /watch\r\n        const wasOnWatch = lastPath.startsWith('/watch');\r\n        const nowOnWatch = currentPath.startsWith('/watch');\r\n        const watchPageChanged = wasOnWatch && nowOnWatch && lastPath !== currentPath;\r\n        const leftWatch = wasOnWatch && !nowOnWatch;\r\n        \r\n        this.lastUrl = currentUrl;\r\n        \r\n        // If we changed to a different /watch page, reinitialize sync\r\n        if (watchPageChanged) {\r\n          console.log('[URLSync] Watch page changed - triggering sync reinitialization');\r\n          this.onWatchPageChange();\r\n        }\r\n        \r\n        const state = this.stateManager.getState();\r\n        \r\n        // If someone leaves /watch, pause the video for everyone\r\n        if (state.partyActive && leftWatch) {\r\n          console.log('[URLSync] Left /watch page - sending pause to all clients');\r\n          this.stateManager.safeSendMessage({ \r\n            type: 'PLAY_PAUSE', \r\n            control: 'pause',\r\n            timestamp: 0\r\n          });\r\n        }\r\n        \r\n        // Only broadcast URL changes if navigating to a /watch page\r\n        // This allows users to browse without forcing others to follow\r\n        if (state.partyActive && nowOnWatch && (watchPageChanged || (!wasOnWatch && nowOnWatch))) {\r\n          console.log('[URLSync] Broadcasting /watch URL change to party');\r\n          this.stateManager.safeSendMessage({ \r\n            type: 'URL_CHANGE', \r\n            url: currentUrl \r\n          });\r\n        } else if (!nowOnWatch && !leftWatch) {\r\n          console.log('[URLSync] Not broadcasting - not on /watch page (on:', currentPath + ')');\r\n        }\r\n      }\r\n    }, 500);\r\n  }\r\n  \r\n  stop() {\r\n    console.log('[URLSync] Stopping URL monitoring');\r\n    if (this.urlMonitorInterval) { \r\n      clearInterval(this.urlMonitorInterval); \r\n      this.urlMonitorInterval = null; \r\n    }\r\n    this.lastUrl = null;\r\n  }\r\n  saveState() {\r\n    const state = this.stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    const existing = this.getRestorationState() || {};\r\n    const payload = {\r\n      roomId: state.roomId,\r\n      currentTime: existing.currentTime || null,\r\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\r\n      timestamp: Date.now()\r\n    };\r\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\r\n  }\r\n  clearState() { sessionStorage.removeItem('toperparty_restore'); }\r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('toperparty_restore');\r\n    if (!stored) return null;\r\n    try {\r\n      const state = JSON.parse(stored);\r\n      if (Date.now() - state.timestamp < 30000) { return state; }\r\n    } catch (e) { console.error('[toperparty] Failed to parse restoration state:', e); }\r\n    return null;\r\n  }\r\n}\r\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","attachPlaybackListeners","video","state","isInitializedRef","lock","onPlay","onPause","onSeek","handlePlay","console","log","isInitialized","get","lockActive","handlePause","handleSeeked","addEventListener","MutableRef","value","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","warn","addTrack","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","stopParty","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","id","safeSendMessage","message","callback","type","sendMessage","document","getElementById","notice","createElement","style","cssText","innerHTML","body","appendChild","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","autoplay","muted","playsInline","position","bottom","left","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","play","err","remove","clearAll","clear","netflixController","injectAPIBridge","script","getURL","head","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","getVideoElement","querySelector","syncManager","netflix","listeners","remote","async","applyRemote","actionName","actionFn","error","handleRequestSync","fromUserId","currentUrl","window","location","href","pathname","startsWith","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","url","handleSyncResponse","currentPath","isOnWatch","isOnBrowse","otherIsOnWatch","sessionStorage","setItem","JSON","stringify","timestamp","localPaused","handlePlaybackControl","control","toUpperCase","currentTimeMs","handleSeek","createRemoteHandlers","setup","waitForVideo","pendingSyncStr","getItem","pendingSync","parse","removeItem","vid","broadcastPlay","broadcastPause","broadcastSeek","teardown","reject","timeout","Error","check","clearTimeout","isOnWatchPage","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","peerId","delete","add","getTracks","right","size","then","volume","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","from","to","ontrack","streams","MediaStream","has","length","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","attempt","Object","assign","attempts","timeouts","handle","count","backoffDelay","Math","min","pow","existing","oldPc","close","forEach","t","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","handleOffer","signalingState","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","stop","urlSync","onWatchPageChange","urlMonitorInterval","lastUrl","start","setInterval","lastPath","wasOnWatch","nowOnWatch","watchPageChanged","leftWatch","saveState","getRestorationState","payload","clearState","stored","videoElementMonitor","restorationState","response","success","onMessage","addListener","request","sender","sendResponse","navigator","mediaDevices","getUserMedia","audio","videoId","incomingUrl"],"ignoreList":[],"sourceRoot":""}