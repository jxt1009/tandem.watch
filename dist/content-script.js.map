{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/content-script.js","webpack://toperparty/./chrome-extension/modules/state-manager.js","webpack://toperparty/./chrome-extension/modules/ui-manager.js","webpack://toperparty/./chrome-extension/modules/netflix-controller.js","webpack://toperparty/./chrome-extension/modules/sync-manager.js","webpack://toperparty/./chrome-extension/modules/webrtc-manager.js","webpack://toperparty/./chrome-extension/modules/url-sync.js"],"sourcesContent":["// content-script.js - Modular version with ES6 imports\n\nimport { StateManager } from './modules/state-manager.js';\nimport { NetflixController } from './modules/netflix-controller.js';\nimport { SyncManager } from './modules/sync-manager.js';\nimport { WebRTCManager } from './modules/webrtc-manager.js';\nimport { UIManager } from './modules/ui-manager.js';\nimport { URLSync } from './modules/url-sync.js';\n\n// Initialize managers\nconst stateManager = new StateManager();\nconst uiManager = new UIManager();\nconst netflixController = new NetflixController();\nconst syncManager = new SyncManager(stateManager, netflixController);\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\nconst urlSync = new URLSync(stateManager);\n\n// Local media stream (still tracked here, but WebRTCManager knows about it too)\nlet localStream = null;\n\n// Check if we need to restore party state after navigation\n(function checkRestorePartyState() {\n  const restorationState = urlSync.getRestorationState();\n  if (restorationState) {\n    console.log('Detected party state after navigation, will restore:', restorationState);\n    \n    // Clear the stored state\n    urlSync.clearState();\n    \n    // Set flag to prevent URL broadcast during restoration\n    stateManager.setRestoringFlag(true);\n    \n    // Notify background that we need to rejoin\n    setTimeout(function() {\n      console.log('Triggering party reset and restoration...');\n      chrome.runtime.sendMessage({\n        type: 'RESTORE_PARTY',\n        roomId: restorationState.roomId\n        // userId is omitted to force a fresh ID generation\n      });\n      \n      // Clear restoration flag after party is restored\n      setTimeout(function() {\n        stateManager.setRestoringFlag(false);\n        console.log('Party restoration complete, URL monitoring active');\n      }, 2000);\n    }, 1000); // Wait 1s for page to stabilize\n  }\n})();\n\n// Inject Netflix API access script into page context\nnetflixController.injectAPIBridge();\n\n// Find Netflix video player (fallback for monitoring)\nfunction getVideoElement() {\n  return document.querySelector('video');\n}\n\n// URL monitoring - check for navigation changes\nlet lastKnownUrl = window.location.href;\n\nfunction startUrlMonitoring() {\n  // Save party state and inform server/peers that THIS tab is leaving on hard navigations\n  window.addEventListener('beforeunload', function savePartyStateBeforeUnload() {\n    const currentState = stateManager.getState();\n    if (stateManager.isInParty()) {\n      // Persist enough info so the refreshed tab can rejoin cleanly\n      urlSync.saveState();\n\n      // Send a LEAVE over the signaling channel for this user only, without\n      // stopping the entire party for other tabs.\n      try {\n        stateManager.safeSendMessage({\n          type: 'SIGNAL_SEND',\n          message: {\n            type: 'LEAVE',\n            userId: currentState.userId,\n            roomId: currentState.roomId,\n            timestamp: Date.now()\n          }\n        });\n      } catch (e) {\n        console.warn('Error sending LEAVE on beforeunload:', e);\n      }\n\n      // Local, immediate cleanup to avoid dangling timers/PCs during unload\n      try {\n        webrtcManager.clearAll();\n      } catch (e) {\n        console.warn('Error clearing WebRTC state on beforeunload:', e);\n      }\n    }\n  });\n  \n  // Also monitor for soft navigations (client-side routing)\n  setInterval(function checkUrlChange() {\n    const currentUrl = window.location.href;\n    const state = stateManager.getState();\n    \n    // Check if URL changed and party is active (but not during restoration)\n    if (currentUrl !== lastKnownUrl && state.partyActive && !state.restoringPartyState) {\n      console.log('URL changed from', lastKnownUrl, 'to', currentUrl);\n      lastKnownUrl = currentUrl;\n      \n      // Broadcast URL change to other clients\n      stateManager.safeSendMessage({\n        type: 'URL_CHANGE',\n        url: currentUrl\n      });\n    } else if (!state.restoringPartyState) {\n      // Silently update lastKnownUrl if we're not in restoration mode\n      lastKnownUrl = currentUrl;\n    }\n  }, 500); // Check every 500ms\n}\n\nfunction stopUrlMonitoring() {\n  lastKnownUrl = window.location.href;\n  urlSync.stop();\n}\n\n// Listen for messages from background script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  // Signaling messages forwarded from background\n  if (request.type === 'SIGNAL' && request.message) {\n    webrtcManager.handleSignal(request.message).catch(err => console.error('Signal handling error:', err));\n    return; // no sendResponse needed\n  }\n  \n  if (request.type === 'REQUEST_MEDIA_STREAM') {\n    // Get media stream for webcam/mic\n    navigator.mediaDevices.getUserMedia({\n      video: { width: { ideal: 640 }, height: { ideal: 480 } },\n      audio: true\n    })\n      .then((stream) => {\n        localStream = stream;\n        webrtcManager.setLocalStream(stream);\n        console.log('Media stream obtained in content script');\n        \n        // Monitor stream tracks for unexpected ending\n        stream.getTracks().forEach(function(track) {\n          console.log('Local stream track obtained:', track.kind, 'id=', track.id, 'readyState=', track.readyState);\n          track.onended = function() {\n            console.error('LOCAL STREAM TRACK ENDED UNEXPECTEDLY:', track.kind, 'id=', track.id);\n          };\n          track.onmute = function() {\n            console.warn('Local stream track muted:', track.kind);\n          };\n          track.onunmute = function() {\n            console.log('Local stream track unmuted:', track.kind);\n          };\n        });\n        \n        // Create or update local preview\n        attachLocalPreview(stream);\n        \n        // Start monitoring local stream health\n        startLocalStreamMonitor(stream);\n      \n        // Let WebRTC manager attach tracks to existing peer connections\n        webrtcManager.onLocalStreamAvailable(stream);\n        sendResponse({ success: true, message: 'Media stream obtained' });\n      })\n      .catch((err) => {\n        console.error('Failed to get media stream:', err);\n        sendResponse({ success: false, error: err.message });\n      });\n    \n    return true; // Keep channel open for async response\n  }\n\n  if (request.type === 'PARTY_STARTED') {\n    stateManager.startParty(request.userId, request.roomId);\n    console.log('Party started! Room:', request.roomId, 'User:', request.userId);\n    \n    // Start monitoring URL changes\n    startUrlMonitoring();\n    \n    // Setup playback sync, then attempt to restore prior playback state (if any)\n    Promise.resolve(syncManager.setup())\n      .then(() => {\n        tryRestorePlaybackState();\n      })\n      .catch((err) => {\n        console.error('[ContentScript] Error setting up sync manager:', err);\n      });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'PARTY_STOPPED') {\n    stateManager.stopParty();\n    \n    // Stop URL monitoring\n    stopUrlMonitoring();\n    \n    // Teardown sync\n    syncManager.teardown();\n    \n    // Stop stream monitor\n    stopLocalStreamMonitor();\n    \n    // Stop media stream\n    if (localStream) {\n      localStream.getTracks().forEach(track => track.stop());\n      localStream = null;\n      webrtcManager.setLocalStream(null);\n    }\n    \n    // Remove local preview UI\n    removeLocalPreview();\n    \n    // Remove injected controls\n    removeInjectedControls();\n    \n    // Let WebRTC manager fully clean up connections, reconnection state, and remote UI\n    webrtcManager.clearAll();\n    \n    console.log('Party stopped');\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\n    syncManager.handlePlaybackControl(request.control, request.fromUserId);\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'APPLY_SYNC_PLAYBACK') {\n    syncManager.handlePassiveSync(request.currentTime, request.isPlaying, request.fromUserId, request.timestamp);\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'APPLY_SEEK') {\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'APPLY_URL_CHANGE') {\n    console.log('Applying URL change from remote user:', request.url, 'from user:', request.fromUserId);\n    \n    // Save party state before navigation so we can restore after reload\n    const state = stateManager.getState();\n    if (state.partyActive && state.userId && state.roomId) {\n      // Capture approximate playback state so refreshed tab rejoins near same position\n      netflixController.getCurrentTime()\n        .then((ms) => {\n          const currentTime = ms != null ? ms / 1000 : null;\n          return netflixController.isPaused().then((paused) => ({ currentTime, isPlaying: !paused }));\n        })\n        .then((playback) => {\n          const existing = urlSync.getRestorationState() || {};\n          const payload = {\n            // userId: state.userId, // Do not save userId\n            roomId: state.roomId,\n            currentTime: playback.currentTime != null ? playback.currentTime : existing.currentTime || null,\n            isPlaying: typeof playback.isPlaying === 'boolean' ? playback.isPlaying : (typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null),\n            timestamp: Date.now()\n          };\n          sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\n          console.log('Saved party + playback state before navigation', payload);\n        })\n        .catch((e) => {\n          console.warn('Failed to capture playback state before navigation, falling back to basic party state:', e);\n          urlSync.saveState();\n        });\n    }\n    \n    // Always use hard navigation to ensure Netflix properly loads the new video\n    // This will cause a page reload, but state will be restored automatically\n    window.location.href = request.url;\n    \n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\n    syncManager.handleRequestSync(request.fromUserId);\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId);\n    sendResponse({ success: true });\n  }\n});\n\n// --- UI Functions (kept in main file for now) ---\n\nfunction removeInjectedControls() {\n  const controls = document.getElementById('netflix-party-controls');\n  if (controls) {\n    controls.remove();\n  }\n}\n\nfunction attachLocalPreview(stream) {\n  let localPreviewVideo = uiManager.getLocalPreviewVideo();\n  \n  // Remove existing preview if any\n  if (localPreviewVideo) {\n    try {\n      if (localPreviewVideo.srcObject) {\n        localPreviewVideo.srcObject = null;\n      }\n    } catch (e) {}\n    localPreviewVideo.remove();\n    localPreviewVideo = null;\n  }\n\n  // Create new video element for local preview\n  const v = document.createElement('video');\n  v.id = 'toperparty-local-preview';\n  v.autoplay = true;\n  v.muted = true; // Always mute local preview to avoid feedback\n  v.playsInline = true;\n  v.style.position = 'fixed';\n  v.style.bottom = '20px';\n  v.style.left = '20px';\n  v.style.width = '240px';\n  v.style.height = '160px';\n  v.style.zIndex = 10001;\n  v.style.border = '2px solid #e50914';\n  v.style.borderRadius = '4px';\n  v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\n\n  try {\n    v.srcObject = stream;\n  } catch (e) {\n    v.src = URL.createObjectURL(stream);\n  }\n\n  document.body.appendChild(v);\n  uiManager.setLocalPreviewVideo(v);\n\n  v.play().catch(function(err) {\n    console.warn('Local preview play() failed (this is usually fine):', err);\n  });\n}\n\nfunction removeLocalPreview() {\n  const localPreviewVideo = uiManager.getLocalPreviewVideo();\n  if (localPreviewVideo) {\n    try {\n      // Stop the tracks managed by this video's srcObject (only if we own them)\n      if (localPreviewVideo.srcObject) {\n        localPreviewVideo.srcObject.getTracks().forEach(function(track) {\n          track.stop();\n        });\n        localPreviewVideo.srcObject = null;\n      }\n    } catch (e) {\n      console.warn('Error stopping local preview tracks:', e);\n    }\n    localPreviewVideo.remove();\n    uiManager.setLocalPreviewVideo(null);\n  }\n}\n\nfunction startLocalStreamMonitor(stream) {\n  uiManager.clearStreamMonitorInterval();\n  \n  const interval = setInterval(function monitorLocalStream() {\n    if (!stream) {\n      console.warn('Local stream is null, stopping monitor');\n      uiManager.clearStreamMonitorInterval();\n      return;\n    }\n\n    const tracks = stream.getTracks();\n    if (tracks.length === 0) {\n      console.warn('Local stream has no tracks');\n      uiManager.clearStreamMonitorInterval();\n      return;\n    }\n\n    let allActive = true;\n    tracks.forEach(function(track) {\n      if (track.readyState !== 'live') {\n        console.error('Local stream track not live:', track.kind, 'readyState=', track.readyState);\n        allActive = false;\n      }\n    });\n\n    if (!allActive) {\n      console.warn('Some local stream tracks are not active - may need to restart stream');\n    }\n  }, 5000); // Check every 5 seconds\n  \n  uiManager.setStreamMonitorInterval(interval);\n}\n\nfunction stopLocalStreamMonitor() {\n  uiManager.clearStreamMonitorInterval();\n}\n\n// After RESTORE_PARTY and PARTY_STARTED, attempt to restore playback state\n// captured before navigation so the refreshed tab doesn't start from 0.\nfunction tryRestorePlaybackState() {\n  const restorationState = urlSync.getRestorationState();\n  if (!restorationState || restorationState.currentTime == null) return;\n\n  const targetSeconds = restorationState.currentTime;\n  const shouldPlay = typeof restorationState.isPlaying === 'boolean' ? restorationState.isPlaying : null;\n\n  // Clear the restoration state so we don't re-apply on subsequent operations\n  urlSync.clearState();\n\n  // Apply a local, non-broadcast correction using NetflixController\n  // We wait a moment to ensure the player is ready to accept seeks\n  setTimeout(() => {\n    netflixController.getCurrentTime()\n      .then((ms) => {\n        const currentSeconds = ms != null ? ms / 1000 : 0;\n        const drift = Math.abs(currentSeconds - targetSeconds);\n\n        // Only correct if we're meaningfully off\n        if (drift > 2) {\n          console.log('[ContentScript] Restoring playback position after navigation from', currentSeconds, 'to', targetSeconds);\n          return netflixController.seek(targetSeconds * 1000);\n        }\n      })\n      .then(() => {\n        if (shouldPlay === null) return;\n        return netflixController.isPaused().then((paused) => {\n          if (shouldPlay && paused) {\n            console.log('[ContentScript] Resuming playback after navigation');\n            return netflixController.play();\n          }\n          if (!shouldPlay && !paused) {\n            console.log('[ContentScript] Pausing playback after navigation');\n            return netflixController.pause();\n          }\n        });\n      })\n      .catch((e) => {\n        console.warn('[ContentScript] Failed to restore playback state after navigation:', e);\n      });\n  }, 1000); // 1s delay before applying restore\n}\n\nfunction addOrReplaceTrack(pc, track, stream) {\n  const senders = pc.getSenders();\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n  if (existingSender) {\n    existingSender.replaceTrack(track).catch(e => console.warn('Error replacing track', e));\n  } else {\n    try {\n      pc.addTrack(track, stream);\n    } catch (e) {\n      console.warn('Error adding track', e);\n    }\n  }\n}\n\n// WebRTC signaling and connection details now live in WebRTCManager\n","// state-manager.js - Manages party state and action tracking\n\nexport class StateManager {\n  constructor() {\n    // Party state\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    this.restoringPartyState = false;\n  }\n  \n  // Party state management\n  startParty(userId, roomId) {\n    this.partyActive = true;\n    this.userId = userId;\n    this.roomId = roomId;\n    console.log('Party started! Room:', roomId, 'User:', userId);\n  }\n  \n  stopParty() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    console.log('Party stopped');\n  }\n  \n  isActive() {\n    return this.partyActive;\n  }\n  \n  getUserId() {\n    return this.userId;\n  }\n  \n  getRoomId() {\n    return this.roomId;\n  }\n  \n  getState() {\n    return {\n      partyActive: this.partyActive,\n      userId: this.userId,\n      roomId: this.roomId,\n      restoringPartyState: this.restoringPartyState\n    };\n  }\n\n   // Convenience: are we currently in a valid party session?\n  isInParty() {\n    return !!(this.partyActive && this.userId && this.roomId);\n  }\n  \n  setRestoringFlag(value) {\n    this.restoringPartyState = value;\n  }\n  \n  // Extension context validation\n  isExtensionContextValid() {\n    try {\n      return chrome.runtime && chrome.runtime.id;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  // Safe message sending\n  safeSendMessage(message, callback) {\n    if (!this.isExtensionContextValid()) {\n      console.warn('Extension context invalidated - please reload the page');\n      return;\n    }\n    try {\n      chrome.runtime.sendMessage(message, callback);\n    } catch (e) {\n      console.warn('Failed to send message, extension may have been reloaded:', e.message);\n    }\n  }\n}\n","// ui-manager.js - Manages UI components (preview videos)\n// Note: Keeping this simple for now, full extraction in future refactor\n\nexport class UIManager {\n  constructor() {\n    this.localPreviewVideo = null;\n    this.remoteVideos = new Map();\n    this.remoteStreams = new Map();\n    this.streamMonitorInterval = null;\n  }\n  \n  getRemoteVideos() {\n    return this.remoteVideos;\n  }\n  \n  getRemoteStreams() {\n    return this.remoteStreams;\n  }\n  \n  setLocalPreviewVideo(video) {\n    this.localPreviewVideo = video;\n  }\n  \n  getLocalPreviewVideo() {\n    return this.localPreviewVideo;\n  }\n  \n  setStreamMonitorInterval(interval) {\n    this.streamMonitorInterval = interval;\n  }\n  \n  getStreamMonitorInterval() {\n    return this.streamMonitorInterval;\n  }\n  \n  clearStreamMonitorInterval() {\n    if (this.streamMonitorInterval) {\n      clearInterval(this.streamMonitorInterval);\n      this.streamMonitorInterval = null;\n    }\n  }\n  \n  clearAll() {\n    this.localPreviewVideo = null;\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    this.clearStreamMonitorInterval();\n  }\n}\n","// netflix-controller.js - Netflix player API wrapper\n\nexport class NetflixController {\n  constructor() {\n    this.injectAPIBridge();\n  }\n  \n  // Inject Netflix API access script into page context\n  injectAPIBridge() {\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\n    (document.head || document.documentElement).appendChild(script);\n    script.onload = function() {\n      console.log('Netflix API bridge loaded');\n      script.remove();\n    };\n  }\n  \n  // Send command to Netflix API via custom events\n  _sendCommand(command, args = []) {\n    return new Promise(function(resolve) {\n      const handler = function(e) {\n        if (e.detail.command === command) {\n          document.removeEventListener('__toperparty_response', handler);\n          resolve(e.detail.result);\n        }\n      };\n      document.addEventListener('__toperparty_response', handler);\n      setTimeout(function() { resolve(null); }, 1000); // timeout fallback\n      document.dispatchEvent(new CustomEvent('__toperparty_command', { detail: { command, args } }));\n    });\n  }\n  \n  play() {\n    return this._sendCommand('play');\n  }\n  \n  pause() {\n    return this._sendCommand('pause');\n  }\n  \n  seek(timeMs) {\n    return this._sendCommand('seek', [timeMs]);\n  }\n  \n  getCurrentTime() {\n    return this._sendCommand('getCurrentTime');\n  }\n  \n  isPaused() {\n    return this._sendCommand('isPaused');\n  }\n  \n  // Find Netflix video element (fallback)\n  getVideoElement() {\n    return document.querySelector('video');\n  }\n}\n","// sync-manager.js - Robust, debounced playback synchronization\n\nexport class SyncManager {\n  constructor(stateManager, netflixController) {\n    this.state = stateManager;\n    this.netflix = netflixController;\n\n    this.listeners = null;\n\n    // Suppression system: Timestamp until which local events are ignored\n    // Used to prevent echo when applying remote commands or during initialization\n    this.suppressLocalUntil = 0;\n\n    // Debounce system: Coalesce rapid events (e.g. pause+seek+play) into one broadcast\n    this.debounceTimer = null;\n    this.recentLocalEvents = new Set();\n    \n    // Context for passive sync\n    this.lastUserInteractionAt = 0;\n    \n    // Initialization state\n    this.isInitialized = false;\n  }\n\n  // ---- Public lifecycle -------------------------------------------------\n\n  async setup() {\n    try {\n      const video = await this.waitForVideo();\n      if (!video) {\n        console.warn('[SyncManager] Netflix video element not found');\n        return;\n      }\n\n      // Reset initialization state\n      this.isInitialized = false;\n      \n      // Request initial state from peers\n      console.log('[SyncManager] Requesting initial sync state from peers...');\n      this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\n\n      // Fallback: If no response within 2s, assume we are alone or first, and unlock.\n      setTimeout(() => {\n        if (!this.isInitialized) {\n          console.log('[SyncManager] No sync response received (timeout). Assuming self-authority.');\n          this.isInitialized = true;\n        }\n      }, 2000);\n\n      this.attachEventListeners(video);\n      console.log('[SyncManager] Setup complete. Waiting for sync response...');\n    } catch (err) {\n      console.error('[SyncManager] Error setting up playback sync:', err);\n    }\n  }\n\n  teardown() {\n    if (this.listeners && this.listeners.video) {\n      const { video, handleLocalEvent, handleTimeUpdate } = this.listeners;\n      try {\n        video.removeEventListener('play', handleLocalEvent);\n        video.removeEventListener('pause', handleLocalEvent);\n        video.removeEventListener('seeked', handleLocalEvent);\n        video.removeEventListener('timeupdate', handleTimeUpdate);\n      } catch (e) {\n        console.warn('[SyncManager] Error removing listeners:', e);\n      }\n      this.listeners = null;\n    }\n    if (this.debounceTimer) {\n      clearTimeout(this.debounceTimer);\n      this.debounceTimer = null;\n    }\n  }\n\n  // ---- DOM wiring -------------------------------------------------------\n\n  waitForVideo() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\n      const check = () => {\n        const video = this.netflix.getVideoElement();\n        if (video) {\n          clearTimeout(timeout);\n          resolve(video);\n        } else {\n          setTimeout(check, 100);\n        }\n      };\n      check();\n    });\n  }\n\n  attachEventListeners(video) {\n    // Unified handler for user interactions\n    const handleLocalEvent = (e) => {\n      if (!this.state.isActive()) return;\n\n      // Ignore events until we are initialized (synced with room)\n      if (!this.isInitialized) {\n        console.log(`[SyncManager] Suppressed local ${e.type} (waiting for init)`);\n        return;\n      }\n\n      const now = Date.now();\n      if (now < this.suppressLocalUntil) {\n        console.log(`[SyncManager] Suppressed local ${e.type} (lock active)`);\n        return;\n      }\n\n      this.lastUserInteractionAt = now;\n      this.recentLocalEvents.add(e.type);\n\n      // Debounce: Wait for the dust to settle before broadcasting\n      if (this.debounceTimer) clearTimeout(this.debounceTimer);\n\n      this.debounceTimer = setTimeout(() => {\n        this.broadcastLocalState(video);\n      }, 200); // 200ms window to capture complex interactions like seek\n    };\n\n    // Passive sync sender\n    let lastPassiveSentAt = 0;\n    const handleTimeUpdate = () => {\n      if (!this.state.isActive()) return;\n      \n      const now = Date.now();\n      // Don't send if we are currently suppressing local events (remote command active)\n      if (now < this.suppressLocalUntil) return;\n      \n      // Don't send if user recently interacted (let the explicit events handle it)\n      if (now - this.lastUserInteractionAt < 5000) return;\n\n      // Rate limit: once every 10s\n      if (now - lastPassiveSentAt < 10000) return;\n\n      if (video.paused) return; // Only sync while playing\n\n      lastPassiveSentAt = now;\n      const payload = {\n        type: 'SYNC_TIME',\n        currentTime: video.currentTime,\n        isPlaying: !video.paused,\n        timestamp: now,\n      };\n      console.log('[SyncManager] Sending passive sync:', payload.currentTime.toFixed(2));\n      this.state.safeSendMessage(payload);\n    };\n\n    video.addEventListener('play', handleLocalEvent);\n    video.addEventListener('pause', handleLocalEvent);\n    video.addEventListener('seeked', handleLocalEvent);\n    video.addEventListener('timeupdate', handleTimeUpdate);\n\n    this.listeners = { video, handleLocalEvent, handleTimeUpdate };\n  }\n\n  broadcastLocalState(video) {\n    const events = this.recentLocalEvents;\n    this.recentLocalEvents = new Set();\n    this.debounceTimer = null;\n\n    const currentTime = video.currentTime;\n    const isPlaying = !video.paused;\n\n    // Priority: Seek > Play/Pause\n    if (events.has('seeked')) {\n      console.log('[SyncManager] Broadcasting SEEK:', currentTime.toFixed(2));\n      this.state.safeSendMessage({ \n        type: 'SEEK', \n        currentTime, \n        isPlaying \n      });\n    } else if (events.has('play') || events.has('pause')) {\n      const control = isPlaying ? 'play' : 'pause';\n      console.log('[SyncManager] Broadcasting PLAY_PAUSE:', control);\n      this.state.safeSendMessage({ \n        type: 'PLAY_PAUSE', \n        control, \n        timestamp: currentTime \n      });\n    }\n  }\n\n  // ---- Remote Command Handlers ------------------------------------------\n\n  async handleRequestSync(fromUserId) {\n    // Only respond if we are initialized and stable\n    if (!this.isInitialized) return;\n    \n    try {\n      const currentTime = await this.netflix.getCurrentTime();\n      const isPaused = await this.netflix.isPaused();\n      \n      console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId);\n      this.state.safeSendMessage({\n        type: 'SYNC_RESPONSE',\n        targetUserId: fromUserId,\n        currentTime: currentTime / 1000,\n        isPlaying: !isPaused\n      });\n    } catch (e) {\n      console.error('[SyncManager] Error handling sync request:', e);\n    }\n  }\n\n  async handleSyncResponse(currentTime, isPlaying, fromUserId) {\n    if (this.isInitialized) {\n      console.log('[SyncManager] Received late SYNC_RESPONSE, ignoring.');\n      return;\n    }\n\n    console.log('[SyncManager] Received initial state from', fromUserId, 'Time:', currentTime, 'Playing:', isPlaying);\n    \n    // Apply the state immediately\n    this.isInitialized = true; // Mark initialized so we can apply actions\n    \n    // Use the standard remote application logic (locks local events)\n    await this._applyRemoteAction('initial-sync', 2000, async () => {\n      await this.netflix.seek(currentTime * 1000);\n      \n      const localPaused = await this.netflix.isPaused();\n      if (isPlaying && localPaused) await this.netflix.play();\n      else if (!isPlaying && !localPaused) await this.netflix.pause();\n    });\n  }\n\n  // Helper to lock local events while applying remote changes\n  async _applyRemoteAction(actionName, lockDurationMs, actionFn) {\n    console.log(`[SyncManager] Applying remote ${actionName}...`);\n    \n    // Set lock\n    this.suppressLocalUntil = Date.now() + lockDurationMs;\n    \n    try {\n      await actionFn();\n    } catch (err) {\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\n    }\n  }\n\n  async handlePlaybackControl(control, fromUserId) {\n    await this._applyRemoteAction(control, 1000, async () => {\n      if (control === 'play') await this.netflix.play();\n      else await this.netflix.pause();\n    });\n  }\n\n  async handleSeek(currentTime, isPlaying, fromUserId) {\n    await this._applyRemoteAction('seek', 2000, async () => {\n      await this.netflix.seek(currentTime * 1000);\n      \n      // Ensure play state matches\n      const isPaused = await this.netflix.isPaused();\n      if (isPlaying && isPaused) await this.netflix.play();\n      else if (!isPlaying && !isPaused) await this.netflix.pause();\n    });\n  }\n\n  async handlePassiveSync(currentTime, isPlaying, fromUserId, timestamp) {\n    const now = Date.now();\n    \n    // Ignore stale messages (>5s old)\n    if (timestamp && (now - timestamp > 5000)) return;\n\n    // Ignore if we recently interacted locally\n    if (now - this.lastUserInteractionAt < 10000) {\n      console.log('[SyncManager] Ignoring passive sync (recent local interaction)');\n      return;\n    }\n\n    // Ignore if we are currently locked (applying another remote command)\n    if (now < this.suppressLocalUntil) return;\n\n    try {\n      const localTimeMs = await this.netflix.getCurrentTime();\n      const targetMs = currentTime * 1000;\n      const driftMs = Math.abs(localTimeMs - targetMs);\n\n      // Only correct if drift is significant (>3s)\n      if (driftMs <= 3000) return;\n\n      console.log(`[SyncManager] Drift detected (${(driftMs/1000).toFixed(2)}s). Correcting...`);\n\n      // Apply correction without broadcasting back\n      await this._applyRemoteAction('passive-correction', 1500, async () => {\n        await this.netflix.seek(targetMs);\n        \n        const localPaused = await this.netflix.isPaused();\n        if (isPlaying && localPaused) await this.netflix.play();\n        else if (!isPlaying && !localPaused) await this.netflix.pause();\n      });\n\n    } catch (err) {\n      console.error('[SyncManager] Error handling passive sync:', err);\n    }\n  }\n}\n","// webrtc-manager.js - Centralised WebRTC peer connection management for the content script\n\nexport class WebRTCManager {\n  constructor(stateManager, uiManager) {\n    this.stateManager = stateManager;\n    this.uiManager = uiManager;\n\n    this.peerConnections = new Map();\n    this.reconnectionAttempts = new Map();\n    this.reconnectionTimeouts = new Map();\n    this.remoteStreams = this.uiManager.getRemoteStreams();\n    this.remoteVideos = this.uiManager.getRemoteVideos();\n\n    this.peersThatLeft = new Set();\n    this.localStream = null;\n  }\n\n  // --- Local media ------------------------------------------------------\n\n  setLocalStream(stream) {\n    this.localStream = stream;\n  }\n\n  getLocalStream() {\n    return this.localStream;\n  }\n\n  // Called when we obtain/refresh local media so we can attach to existing PCs\n  onLocalStreamAvailable(stream) {\n    this.localStream = stream;\n    this.peerConnections.forEach((pc) => {\n      try {\n        stream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, stream));\n      } catch (e) {\n        console.warn('[WebRTCManager] Error adding tracks to peer connection', e);\n      }\n    });\n  }\n\n  // --- Signaling entrypoint --------------------------------------------\n\n  async handleSignal(message) {\n    if (!message || !message.type) return;\n\n    const type = message.type;\n    const from = message.userId || message.from;\n    const to = message.to;\n    const state = this.stateManager.getState();\n\n    // Ignore messages not for us (if addressed)\n    if (to && to !== state.userId) return;\n\n    if (type === 'JOIN' && from && from !== state.userId) {\n      // Another user joined the room  initiate P2P if we have local media\n      this.peersThatLeft.delete(from);\n      if (!this.peerConnections.has(from)) {\n        try {\n          const pc = this._createPeerConnection(from);\n          this.peerConnections.set(from, pc);\n          if (this.localStream) {\n            this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\n          }\n          const offer = await pc.createOffer();\n          await pc.setLocalDescription(offer);\n          this._sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n        } catch (err) {\n          console.error('[WebRTCManager] Error handling JOIN and creating offer:', err);\n          this.peerConnections.delete(from);\n        }\n      }\n      return;\n    }\n\n    if (type === 'OFFER' && message.offer && from && from !== state.userId) {\n      let pc = this.peerConnections.get(from);\n\n      if (pc) {\n        const pcState = pc.signalingState;\n        if (pcState !== 'closed') {\n          console.log('[WebRTCManager] Received new offer while in state:', pcState, '- recreating connection for', from);\n          try { pc.close(); } catch (e) {}\n          this.peerConnections.delete(from);\n          pc = null;\n        }\n      }\n\n      if (!pc) {\n        pc = this._createPeerConnection(from);\n        this.peerConnections.set(from, pc);\n      }\n\n      try {\n        await pc.setRemoteDescription(new RTCSessionDescription(message.offer));\n        if (this.localStream) {\n          this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\n        }\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        this._sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\n      } catch (err) {\n        console.error('[WebRTCManager] Error handling offer:', err);\n        this.peerConnections.delete(from);\n        try { pc.close(); } catch (e) {}\n      }\n      return;\n    }\n\n    if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\n      const pc = this.peerConnections.get(from);\n      if (pc) {\n        try {\n          if (pc.signalingState === 'have-local-offer') {\n            await pc.setRemoteDescription(new RTCSessionDescription(message.answer));\n          } else {\n            console.warn('[WebRTCManager] Received answer in unexpected state:', pc.signalingState);\n          }\n        } catch (err) {\n          console.error('[WebRTCManager] Error handling answer:', err);\n        }\n      }\n      return;\n    }\n\n    if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\n      const pc = this.peerConnections.get(from);\n      if (pc) {\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(message.candidate));\n        } catch (err) {\n          console.warn('[WebRTCManager] Error adding received ICE candidate', err);\n        }\n      }\n      return;\n    }\n\n    if (type === 'LEAVE' && from) {\n      this.peersThatLeft.add(from);\n      const pc = this.peerConnections.get(from);\n      if (pc) {\n        try { pc.close(); } catch (e) {}\n        this.peerConnections.delete(from);\n      }\n      this._clearReconnectionState(from);\n      this._removeRemoteVideo(from);\n      return;\n    }\n  }\n\n  // --- Reconnection logic ----------------------------------------------\n\n  async attemptReconnection(peerId) {\n    const state = this.stateManager.getState();\n    if (!this.stateManager.isInParty()) {\n      console.log('[WebRTCManager] Cannot reconnect - party not active');\n      return;\n    }\n\n    if (this.peersThatLeft.has(peerId)) {\n      console.log('[WebRTCManager] Not attempting reconnection to peer that has explicitly left:', peerId);\n      this._clearReconnectionState(peerId);\n      return;\n    }\n\n    const attempts = this.reconnectionAttempts.get(peerId) || 0;\n    const maxAttempts = 5;\n    const backoffDelay = Math.min(1000 * Math.pow(2, attempts), 30000);\n\n    if (attempts >= maxAttempts) {\n      console.log('[WebRTCManager] Max reconnection attempts reached for', peerId);\n      this.reconnectionAttempts.delete(peerId);\n      this.reconnectionTimeouts.delete(peerId);\n      return;\n    }\n\n    console.log(`[WebRTCManager] Attempting reconnection to ${peerId} (attempt ${attempts + 1}/${maxAttempts}) in ${backoffDelay}ms`);\n    this.reconnectionAttempts.set(peerId, attempts + 1);\n\n    const existingTimeout = this.reconnectionTimeouts.get(peerId);\n    if (existingTimeout) {\n      clearTimeout(existingTimeout);\n    }\n\n    const timeoutHandle = setTimeout(async () => {\n      console.log('[WebRTCManager] Reconnecting to', peerId);\n\n      const oldPc = this.peerConnections.get(peerId);\n      if (oldPc) {\n        try { oldPc.close(); } catch (e) { console.warn('[WebRTCManager] Error closing old peer connection:', e); }\n        this.peerConnections.delete(peerId);\n      }\n\n      try {\n        const pc = this._createPeerConnection(peerId);\n        this.peerConnections.set(peerId, pc);\n\n        if (this.localStream) {\n          this.localStream.getTracks().forEach(t => this._addOrReplaceTrack(pc, t, this.localStream));\n        }\n\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        this._sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\n\n        console.log('[WebRTCManager] Reconnection offer sent to', peerId);\n      } catch (err) {\n        console.error('[WebRTCManager] Failed to create reconnection offer:', err);\n        this.attemptReconnection(peerId);\n      }\n    }, backoffDelay);\n\n    this.reconnectionTimeouts.set(peerId, timeoutHandle);\n  }\n\n  _clearReconnectionState(peerId) {\n    this.reconnectionAttempts.delete(peerId);\n    const timeoutHandle = this.reconnectionTimeouts.get(peerId);\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle);\n      this.reconnectionTimeouts.delete(peerId);\n    }\n  }\n\n  // --- Peer connection helpers -----------------------------------------\n\n  _createPeerConnection(peerId) {\n    const state = this.stateManager.getState();\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: ['stun:stun.l.google.com:19302'] },\n        { urls: ['stun:stun1.l.google.com:19302'] }\n      ]\n    });\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        this._sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\n      }\n    };\n\n    pc.ontrack = (event) => {\n      console.log('[WebRTCManager] Received remote track from', peerId, 'track=', event.track && event.track.kind);\n      let stream = (event.streams && event.streams[0]) || this.remoteStreams.get(peerId);\n      if (!stream) {\n        stream = new MediaStream();\n        this.remoteStreams.set(peerId, stream);\n      }\n      if (event.track) {\n        try {\n          stream.addTrack(event.track);\n          event.track.onended = () => {\n            console.warn('[WebRTCManager] Remote track ended from', peerId, 'kind=', event.track.kind);\n          };\n          console.log('[WebRTCManager] Added remote track to stream, kind=', event.track.kind, 'readyState=', event.track.readyState);\n        } catch (e) {\n          console.warn('[WebRTCManager] Failed to add remote track to stream', e);\n        }\n      }\n      if (!this.remoteVideos.has(peerId)) {\n        this._addRemoteVideo(peerId, stream);\n      }\n    };\n\n    pc.onconnectionstatechange = () => {\n      console.log('[WebRTCManager] PC state', pc.connectionState, 'for', peerId);\n\n      if (pc.connectionState === 'connected') {\n        console.log('[WebRTCManager] Connection established successfully with', peerId);\n        this._clearReconnectionState(peerId);\n      } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {\n        if (this.peersThatLeft.has(peerId)) {\n          console.warn('[WebRTCManager] Connection', pc.connectionState, 'with peer that has left', peerId, '- not reconnecting');\n          this.peerConnections.delete(peerId);\n          this._removeRemoteVideo(peerId);\n          this._clearReconnectionState(peerId);\n        } else {\n          console.warn('[WebRTCManager] Connection', pc.connectionState, 'with', peerId, '- attempting reconnection');\n          this.peerConnections.delete(peerId);\n          this._removeRemoteVideo(peerId);\n          this.attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'closed') {\n        console.log('[WebRTCManager] Connection closed with', peerId);\n        this.peerConnections.delete(peerId);\n        this._removeRemoteVideo(peerId);\n        this._clearReconnectionState(peerId);\n      }\n    };\n\n    return pc;\n  }\n\n  _addOrReplaceTrack(pc, track, stream) {\n    const senders = pc.getSenders();\n    const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n    if (existingSender) {\n      existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\n    } else {\n      try {\n        pc.addTrack(track, stream);\n      } catch (e) {\n        console.warn('[WebRTCManager] Error adding track', e);\n      }\n    }\n  }\n\n  // --- UI helpers -------------------------------------------------------\n\n  _addRemoteVideo(peerId, stream) {\n    this._removeRemoteVideo(peerId);\n    const v = document.createElement('video');\n    v.id = 'toperparty-remote-' + peerId;\n    v.autoplay = true;\n    v.playsInline = true;\n    v.muted = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '20px';\n    v.style.right = (20 + (this.remoteVideos.size * 180)) + 'px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = 10001;\n    v.style.border = '2px solid #00aaff';\n    v.style.borderRadius = '4px';\n\n    const audioTracks = stream.getAudioTracks();\n    console.log('[WebRTCManager] Remote stream audio tracks:', audioTracks.length);\n    audioTracks.forEach((track) => {\n      console.log('[WebRTCManager] Audio track:', track.id, 'enabled=', track.enabled, 'readyState=', track.readyState);\n    });\n\n    try {\n      v.srcObject = stream;\n    } catch (e) {\n      v.src = URL.createObjectURL(stream);\n    }\n    document.body.appendChild(v);\n    this.remoteVideos.set(peerId, v);\n\n    try {\n      v.play().then(() => {\n        console.log('[WebRTCManager] Remote video playing, unmuting audio for', peerId);\n        v.muted = false;\n        v.volume = 1.0;\n      }).catch((err) => {\n        console.warn('[WebRTCManager] Remote video play() failed:', err);\n        v.muted = false;\n      });\n    } catch (e) {\n      console.error('[WebRTCManager] Exception calling play():', e);\n    }\n  }\n\n  _removeRemoteVideo(peerId) {\n    const v = this.remoteVideos.get(peerId);\n    if (v) {\n      try {\n        if (v.srcObject) {\n          v.srcObject = null;\n        }\n      } catch (e) {}\n      v.remove();\n      this.remoteVideos.delete(peerId);\n    }\n    this.remoteStreams.delete(peerId);\n  }\n\n  // --- Messaging to background -----------------------------------------\n\n  _sendSignal(message) {\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\n  }\n\n  // --- Teardown ---------------------------------------------------------\n\n  clearAll() {\n    this.peerConnections.forEach((pc) => {\n      try { pc.close(); } catch (e) {}\n    });\n    this.peerConnections.clear();\n\n    this.reconnectionTimeouts.forEach((timeoutHandle) => {\n      clearTimeout(timeoutHandle);\n    });\n    this.reconnectionTimeouts.clear();\n    this.reconnectionAttempts.clear();\n    this.peersThatLeft.clear();\n\n    this.remoteVideos.forEach((v, id) => {\n      try {\n        if (v.srcObject) {\n          v.srcObject = null;\n        }\n      } catch (e) {}\n      v.remove();\n    });\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n\n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n}\n","// url-sync.js - Manages URL monitoring and party state persistence\n// Note: Keeping this simple for now, full extraction in future refactor\n\nexport class URLSync {\n  constructor(stateManager) {\n    this.stateManager = stateManager;\n    this.urlMonitorInterval = null;\n    this.lastUrl = null;\n  }\n  \n  start() {\n    this.lastUrl = window.location.href;\n    // URL monitoring logic will be moved here in full extraction\n  }\n  \n  stop() {\n    if (this.urlMonitorInterval) {\n      clearInterval(this.urlMonitorInterval);\n      this.urlMonitorInterval = null;\n    }\n  }\n  \n  saveState() {\n    const state = this.stateManager.getState();\n    if (!state.partyActive) return;\n\n    // Persist basic party info; playback state will be updated separately by content-script\n    const existing = this.getRestorationState() || {};\n    const payload = {\n      // We intentionally DO NOT save userId anymore to force a fresh identity on reload\n      // userId: state.userId, \n      roomId: state.roomId,\n      // keep any playback info that may have been written just before navigation\n      currentTime: existing.currentTime || null,\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\n      timestamp: Date.now()\n    };\n\n    sessionStorage.setItem('toperparty_restore', JSON.stringify(payload));\n  }\n  \n  clearState() {\n    sessionStorage.removeItem('toperparty_restore');\n  }\n  \n  getRestorationState() {\n    const stored = sessionStorage.getItem('toperparty_restore');\n    if (!stored) return null;\n    \n    try {\n      const state = JSON.parse(stored);\n      // Check if restoration state is recent (within 30 seconds)\n      if (Date.now() - state.timestamp < 30000) {\n        return state;\n      }\n    } catch (e) {\n      console.error('[toperparty] Failed to parse restoration state:', e);\n    }\n    \n    return null;\n  }\n}\n"],"names":["stateManager","constructor","this","partyActive","userId","roomId","restoringPartyState","startParty","console","log","stopParty","isActive","getUserId","getRoomId","getState","isInParty","setRestoringFlag","value","isExtensionContextValid","chrome","runtime","id","e","safeSendMessage","message","callback","sendMessage","warn","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","video","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","clearAll","clear","netflixController","injectAPIBridge","script","document","createElement","src","getURL","head","documentElement","appendChild","onload","remove","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","addEventListener","setTimeout","dispatchEvent","CustomEvent","play","pause","seek","timeMs","getCurrentTime","isPaused","getVideoElement","querySelector","syncManager","state","netflix","listeners","suppressLocalUntil","debounceTimer","recentLocalEvents","Set","lastUserInteractionAt","isInitialized","setup","waitForVideo","type","attachEventListeners","err","error","teardown","handleLocalEvent","handleTimeUpdate","clearTimeout","reject","timeout","Error","check","now","Date","add","broadcastLocalState","lastPassiveSentAt","paused","payload","currentTime","isPlaying","timestamp","toFixed","events","has","control","handleRequestSync","fromUserId","targetUserId","handleSyncResponse","_applyRemoteAction","async","localPaused","actionName","lockDurationMs","actionFn","handlePlaybackControl","handleSeek","handlePassiveSync","localTimeMs","targetMs","driftMs","Math","abs","webrtcManager","peerConnections","reconnectionAttempts","reconnectionTimeouts","peersThatLeft","localStream","setLocalStream","stream","getLocalStream","onLocalStreamAvailable","forEach","pc","getTracks","t","_addOrReplaceTrack","handleSignal","from","to","delete","_createPeerConnection","set","offer","createOffer","setLocalDescription","_sendSignal","localDescription","get","pcState","signalingState","close","setRemoteDescription","RTCSessionDescription","answer","createAnswer","candidate","addIceCandidate","RTCIceCandidate","_clearReconnectionState","_removeRemoteVideo","attemptReconnection","peerId","attempts","backoffDelay","min","pow","existingTimeout","timeoutHandle","oldPc","RTCPeerConnection","iceServers","urls","onicecandidate","event","ontrack","track","kind","streams","MediaStream","addTrack","onended","readyState","_addRemoteVideo","onconnectionstatechange","connectionState","existingSender","getSenders","find","s","replaceTrack","catch","v","autoplay","playsInline","muted","style","position","bottom","right","size","width","height","zIndex","border","borderRadius","audioTracks","getAudioTracks","length","enabled","srcObject","URL","createObjectURL","body","then","volume","stop","urlSync","urlMonitorInterval","lastUrl","start","window","location","href","saveState","existing","getRestorationState","sessionStorage","setItem","JSON","stringify","clearState","removeItem","stored","getItem","parse","restorationState","lastKnownUrl","onMessage","addListener","request","sender","sendResponse","navigator","mediaDevices","getUserMedia","ideal","audio","onmute","onunmute","left","transform","attachLocalPreview","setInterval","tracks","allActive","startLocalStreamMonitor","success","currentState","currentUrl","url","targetSeconds","shouldPlay","ms","currentSeconds","tryRestorePlaybackState","removeLocalPreview","controls","getElementById","removeInjectedControls","playback"],"ignoreList":[],"sourceRoot":""}