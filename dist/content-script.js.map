{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://tandem.watch/./chrome-extension/src/managers/sync/lock.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/eventListeners.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/SyncManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://tandem.watch/./chrome-extension/src/content/main.js","webpack://tandem.watch/./chrome-extension/src/managers/state/StateManager.js","webpack://tandem.watch/./chrome-extension/src/ui/UIManager.js","webpack://tandem.watch/./chrome-extension/src/content/netflix/NetflixController.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/ui.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/reconnect.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/signaling.js","webpack://tandem.watch/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\n  constructor() {\n    this.suppressLocalUntil = 0;\n  }\n  set(durationMs) {\n    this.suppressLocalUntil = Date.now() + durationMs;\n  }\n  isActive() {\n    return Date.now() < this.suppressLocalUntil;\n  }\n}\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek }) {\n  const handlePlay = () => {\n    console.log('[EventListeners] Play event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring play - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring play - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring play - lock active'); return; }\n    console.log('[EventListeners] Play event detected - broadcasting');\n    onPlay(video);\n  };\n\n  const handlePause = () => {\n    console.log('[EventListeners] Pause event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring pause - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring pause - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring pause - lock active'); return; }\n    console.log('[EventListeners] Pause event detected - broadcasting');\n    onPause(video);\n  };\n\n  const handleSeeked = () => {\n    console.log('[EventListeners] Seek event fired - checking conditions:', {\n      isActive: state.isActive(),\n      isInitialized: isInitializedRef.get(),\n      lockActive: lock.isActive()\n    });\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring seek - party not active'); return; }\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring seek - not initialized'); return; }\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring seek - lock active'); return; }\n    console.log('[EventListeners] Seek event detected - broadcasting');\n    onSeek(video);\n  };\n\n  video.addEventListener('play', handlePlay);\n  video.addEventListener('pause', handlePause);\n  video.addEventListener('seeked', handleSeeked);\n  console.log('[EventListeners] Event listeners attached to video element');\n\n  return { video, handlePlay, handlePause, handleSeeked };\n}\n","import { SyncLock } from './lock.js';\nimport { attachPlaybackListeners } from './eventListeners.js';\nimport { createRemoteHandlers } from './remoteHandlers.js';\n\nclass MutableRef {\n  constructor(value) { this.value = value; }\n  get() { return this.value; }\n  set(v) { this.value = v; }\n}\n\nexport class SyncManager {\n  constructor(stateManager, netflixController) {\n    this.state = stateManager;\n    this.netflix = netflixController;\n    this.lock = new SyncLock();\n    this.isInitializedRef = new MutableRef(false);\n    this.listeners = null;\n\n    this.remote = createRemoteHandlers({\n      state: this.state,\n      netflix: this.netflix,\n      lock: this.lock,\n      isInitializedRef: this.isInitializedRef,\n    });\n  }\n\n  async setup() {\n    try {\n      // Only setup sync manager on /watch pages\n      if (!window.location.pathname.startsWith('/watch')) {\n        console.log('[SyncManager] Not on /watch page, skipping setup');\n        return;\n      }\n      \n      console.log('[SyncManager] Starting setup - waiting for video element...');\n      const video = await this.waitForVideo();\n      if (!video) { \n        console.warn('[SyncManager] Netflix video element not found'); \n        return; \n      }\n      \n      console.log('[SyncManager] Video element found, setting up event listeners');\n      \n      // Check for pending sync from URL navigation\n      const pendingSyncStr = sessionStorage.getItem('tandem_pending_sync');\n      if (pendingSyncStr) {\n        try {\n          const pendingSync = JSON.parse(pendingSyncStr);\n          if (Date.now() - pendingSync.timestamp < 10000) {\n            console.log('[SyncManager] Applying pending sync from URL navigation');\n            sessionStorage.removeItem('tandem_pending_sync');\n            this.isInitializedRef.set(true);\n            \n            // Apply the pending sync state\n            this.lock.set(1500);\n            await this.netflix.seek(pendingSync.currentTime * 1000);\n            const isPaused = await this.netflix.isPaused();\n            if (pendingSync.isPlaying && isPaused) {\n              await this.netflix.play();\n            } else if (!pendingSync.isPlaying && !isPaused) {\n              await this.netflix.pause();\n            }\n            \n            const listeners = attachPlaybackListeners({\n              video,\n              state: this.state,\n              isInitializedRef: this.isInitializedRef,\n              lock: this.lock,\n              onPlay: (vid) => this.broadcastPlay(vid),\n              onPause: (vid) => this.broadcastPause(vid),\n              onSeek: (vid) => this.broadcastSeek(vid)\n            });\n            this.listeners = listeners;\n            console.log('[SyncManager] Setup complete with pending sync applied');\n            return;\n          } else {\n            console.log('[SyncManager] Pending sync expired, ignoring');\n            sessionStorage.removeItem('tandem_pending_sync');\n          }\n        } catch (e) {\n          console.error('[SyncManager] Error applying pending sync:', e);\n          sessionStorage.removeItem('tandem_pending_sync');\n        }\n      }\n      \n      this.isInitializedRef.set(false);\n      \n      // Check if we just navigated from browse - if so, respect Netflix's natural behavior\n      // and become the leader that others sync to\n      const fromBrowse = sessionStorage.getItem('tandem_from_browse');\n      if (fromBrowse === 'true') {\n        console.log('[SyncManager] Just navigated from browse - becoming leader, will broadcast state once video is ready');\n        sessionStorage.removeItem('tandem_from_browse');\n        // Mark as initialized immediately so we start broadcasting our state\n        this.isInitializedRef.set(true);\n        \n        // Wait for video to be ready before broadcasting state\n        const broadcastLeaderState = async () => {\n          try {\n            const currentTime = await this.netflix.getCurrentTime();\n            const isPaused = await this.netflix.isPaused();\n            if (currentTime != null) {\n              const currentTimeSeconds = currentTime / 1000;\n              console.log('[SyncManager] Video ready - broadcasting initial state as leader:', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing');\n              \n              // Broadcast our current state\n              if (isPaused) {\n                this.state.safeSendMessage({ \n                  type: 'PLAY_PAUSE', \n                  control: 'pause', \n                  currentTime: currentTimeSeconds \n                });\n              } else {\n                this.state.safeSendMessage({ \n                  type: 'PLAY_PAUSE', \n                  control: 'play', \n                  currentTime: currentTimeSeconds \n                });\n              }\n            }\n          } catch (e) {\n            console.error('[SyncManager] Error broadcasting leader state:', e);\n          }\n        };\n        \n        // Listen for video ready event (canplay fires when video has buffered enough to play)\n        const onVideoReady = () => {\n          console.log('[SyncManager] Video canplay event fired');\n          video.removeEventListener('canplay', onVideoReady);\n          broadcastLeaderState();\n        };\n        \n        // If video is already ready, broadcast immediately\n        if (video.readyState >= 3) { // HAVE_FUTURE_DATA or better\n          console.log('[SyncManager] Video already ready (readyState:', video.readyState + ')');\n          broadcastLeaderState();\n        } else {\n          console.log('[SyncManager] Waiting for video to be ready (readyState:', video.readyState + ')');\n          video.addEventListener('canplay', onVideoReady);\n          // Fallback timeout in case canplay never fires\n          setTimeout(() => {\n            video.removeEventListener('canplay', onVideoReady);\n            console.log('[SyncManager] Timeout reached, broadcasting anyway');\n            broadcastLeaderState();\n          }, 5000);\n        }\n      } else {\n        // Wait for video to be ready before requesting sync\n        const requestSyncWhenReady = () => {\n          console.log('[SyncManager] Video ready - requesting initial sync from other clients');\n          this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\n          \n          // If no response after 2 seconds, consider ourselves initialized\n          setTimeout(() => {\n            if (!this.isInitializedRef.get()) {\n              console.log('[SyncManager] No sync response received after 2s, marking as initialized');\n              this.isInitializedRef.set(true);\n              console.log('[SyncManager] isInitialized is now:', this.isInitializedRef.get());\n            } else {\n              console.log('[SyncManager] Already initialized, skipping timeout initialization');\n            }\n          }, 2000);\n        };\n        \n        const onVideoReady = () => {\n          console.log('[SyncManager] Video canplay event fired');\n          video.removeEventListener('canplay', onVideoReady);\n          requestSyncWhenReady();\n        };\n        \n        // If video is already ready, request sync immediately\n        if (video.readyState >= 3) { // HAVE_FUTURE_DATA or better\n          console.log('[SyncManager] Video already ready (readyState:', video.readyState + ')');\n          requestSyncWhenReady();\n        } else {\n          console.log('[SyncManager] Waiting for video to be ready before requesting sync (readyState:', video.readyState + ')');\n          video.addEventListener('canplay', onVideoReady);\n          // Fallback timeout\n          setTimeout(() => {\n            video.removeEventListener('canplay', onVideoReady);\n            console.log('[SyncManager] Timeout reached, requesting sync anyway');\n            requestSyncWhenReady();\n          }, 5000);\n        }\n      }\n      \n      const listeners = attachPlaybackListeners({\n        video,\n        state: this.state,\n        isInitializedRef: this.isInitializedRef,\n        lock: this.lock,\n        onPlay: (vid) => this.broadcastPlay(vid),\n        onPause: (vid) => this.broadcastPause(vid),\n        onSeek: (vid) => this.broadcastSeek(vid)\n      });\n      this.listeners = listeners;\n      console.log('[SyncManager] Setup complete - ready to sync');\n    } catch (err) { \n      console.error('[SyncManager] Error setting up playback sync:', err); \n    }\n  }\n\n  teardown() {\n    console.log('[SyncManager] Tearing down sync manager');\n    if (this.listeners && this.listeners.video) {\n      const { video, handlePlay, handlePause, handleSeeked } = this.listeners;\n      try {\n        video.removeEventListener('play', handlePlay);\n        video.removeEventListener('pause', handlePause);\n        video.removeEventListener('seeked', handleSeeked);\n        console.log('[SyncManager] Event listeners removed');\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\n      this.listeners = null;\n    }\n    this.isInitializedRef.set(false);\n  }\n\n  waitForVideo() {\n    return new Promise((resolve, reject) => {\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\n      const check = () => {\n        const video = this.netflix.getVideoElement();\n        if (video) { clearTimeout(timeout); resolve(video); }\n        else { setTimeout(check, 100); }\n      };\n      check();\n    });\n  }\n\n  isOnWatchPage() {\n    return window.location.pathname.startsWith('/watch');\n  }\n\n  broadcastPlay(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting PLAY event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'play', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastPause(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting PAUSE event');\n    this.state.safeSendMessage({ \n      type: 'PLAY_PAUSE', \n      control: 'pause', \n      currentTime: video.currentTime \n    });\n  }\n\n  broadcastSeek(video) {\n    if (!this.isOnWatchPage()) {\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\n      return;\n    }\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\n    this.state.safeSendMessage({ \n      type: 'SEEK', \n      currentTime: video.currentTime, \n      isPlaying: !video.paused \n    });\n  }\n\n  // Remote event handlers\n  handleRequestSync(fromUserId, respectAutoPlay) { return this.remote.handleRequestSync(fromUserId, respectAutoPlay); }\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay) { return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay); }\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\n}\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft, showReconnecting, hideOverlay, showPlaceholder }) {\n  return function createPeerConnection(peerId) {\n    console.log('[PeerConnection] Creating peer connection for peerId:', peerId);\n    \n    // Ensure any existing video/container AND stream is removed before creating placeholder\n    // This prevents duplicates when rapidly recreating connections (like force refresh)\n    removeRemoteVideo(peerId);\n    remoteStreams.delete(peerId); // Also clear the stream\n    \n    // Show placeholder immediately when peer connection is created\n    showPlaceholder(peerId);\n    \n    const state = stateManager.getState();\n    const pc = new RTCPeerConnection({\n      iceServers: [\n        { urls: ['stun:stun.l.google.com:19302'] },\n        { urls: ['stun:stun1.l.google.com:19302'] }\n      ]\n    });\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\n      }\n    };\n    pc.ontrack = (event) => {\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\n      if (!stream) {\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\n        stream = new MediaStream();\n        remoteStreams.set(peerId, stream);\n      }\n      if (event.track) {\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\n        try { \n          // Check if track already exists in stream to prevent duplicates\n          const existingTrack = stream.getTracks().find(t => t.id === event.track.id);\n          if (!existingTrack) {\n            stream.addTrack(event.track);\n          } else {\n            console.log('[PeerConnection] Track already in stream, skipping');\n          }\n        } catch (e) {\n          console.warn('[PeerConnection] Error adding track:', e);\n        }\n      }\n      \n      // Check if video element exists\n      const hasVideoInMap = remoteVideos.has(peerId);\n      const hasVideoInDom = !!document.getElementById('tandem-remote-' + peerId);\n      const videoExists = hasVideoInMap || hasVideoInDom;\n      \n      if (videoExists) {\n        console.log('[PeerConnection] Video already exists for peer:', peerId, 'inMap:', hasVideoInMap, 'inDom:', hasVideoInDom);\n        // Update the existing video element's stream if it's different\n        const existingVideo = remoteVideos.get(peerId) || document.getElementById('tandem-remote-' + peerId);\n        if (existingVideo && existingVideo.srcObject !== stream) {\n          console.log('[PeerConnection] Updating existing video element with new stream');\n          existingVideo.srcObject = stream;\n          // Ensure it's tracked in the map\n          if (!hasVideoInMap) {\n            remoteVideos.set(peerId, existingVideo);\n          }\n        }\n      } else {\n        // Wait for both audio and video tracks before creating video element\n        const tracks = stream.getTracks();\n        const hasAudio = tracks.some(t => t.kind === 'audio');\n        const hasVideo = tracks.some(t => t.kind === 'video');\n        \n        console.log('[PeerConnection] Stream status - audio:', hasAudio, 'video:', hasVideo, 'total tracks:', tracks.length);\n        \n        // Only create video element when we have both tracks\n        if (hasAudio && hasVideo) {\n          console.log('[PeerConnection] Both tracks present, adding remote video for peer:', peerId);\n          addRemoteVideo(peerId, stream);\n        } else {\n          console.log('[PeerConnection] Waiting for more tracks before creating video element');\n        }\n      }\n    };\n    pc.onconnectionstatechange = () => {\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, '', pc.connectionState);\n      if (pc.connectionState === 'connected') {\n        clearReconnection(peerId);\n        hideOverlay(peerId);\n      } else if (pc.connectionState === 'disconnected') {\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          // Keep video visible while reconnecting - don't remove immediately\n          console.log('[PeerConnection] Connection disconnected, attempting reconnection while keeping video visible');\n          showReconnecting(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'failed') {\n        console.log('[PeerConnection] Connection failed for peer:', peerId);\n        if (peersThatLeft.has(peerId)) {\n          removeRemoteVideo(peerId);\n          clearReconnection(peerId);\n        } else {\n          // Remove video on failed state and try to reconnect\n          removeRemoteVideo(peerId);\n          attemptReconnection(peerId);\n        }\n      } else if (pc.connectionState === 'closed') {\n        removeRemoteVideo(peerId);\n        clearReconnection(peerId);\n      }\n    };\n    return pc;\n  };\n}\n\nexport function addOrReplaceTrack(pc, track, stream) {\n  const senders = pc.getSenders();\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\n  if (existingSender) {\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\n  } else {\n    try { pc.addTrack(track, stream); } catch (e) {}\n  }\n}\n","import { StateManager } from '../managers/state/StateManager.js';\nimport { NetflixController } from './netflix/NetflixController.js';\nimport { SyncManager } from '../managers/sync/SyncManager.js';\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\nimport { UIManager } from '../ui/UIManager.js';\nimport { URLSync } from '../managers/url/URLSync.js';\n\nconsole.log('[Content Script] Initializing managers...');\n\n// Don't clean up stale elements on navigation - they should persist\n// Only clean up if party is not active\nconst wasPartyActive = sessionStorage.getItem('tandem_was_active') === 'true';\nif (!wasPartyActive) {\n  console.log('[Content Script] No active party detected, cleaning up stale elements...');\n  const staleContainers = document.querySelectorAll('[id^=\"tandem-container-\"]');\n  const staleVideos = document.querySelectorAll('[id^=\"tandem-remote-\"]');\n  const staleOverlays = document.querySelectorAll('[id^=\"tandem-overlay-\"]');\n  const staleLocalVideo = document.getElementById('tandem-local-preview');\n  const staleWaitingIndicator = document.getElementById('tandem-waiting-indicator');\n\n  staleContainers.forEach(el => {\n    console.log('[Content Script] Removing stale container:', el.id);\n    el.remove();\n  });\n  staleVideos.forEach(el => {\n    console.log('[Content Script] Removing stale video:', el.id);\n    el.remove();\n  });\n  staleOverlays.forEach(el => {\n    console.log('[Content Script] Removing stale overlay:', el.id);\n    el.remove();\n  });\n  if (staleLocalVideo) {\n    console.log('[Content Script] Removing stale local video');\n    staleLocalVideo.remove();\n  }\n  if (staleWaitingIndicator) {\n    console.log('[Content Script] Removing stale waiting indicator');\n    staleWaitingIndicator.remove();\n  }\n} else {\n  console.log('[Content Script] Party is active, keeping existing video elements');\n}\n\nconst stateManager = new StateManager();\nconst uiManager = new UIManager();\nconst netflixController = new NetflixController();\nconst syncManager = new SyncManager(stateManager, netflixController);\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\n\n// Callback when we navigate to a different /watch page\nconst handleWatchPageChange = () => {\n  console.log('[Content Script] Watch page changed - reinitializing sync manager');\n  const state = stateManager.getState();\n  if (state.partyActive) {\n    console.log('[Content Script] Party is active, reinitializing sync manager');\n    syncManager.teardown();\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to reinitialize sync manager:', err);\n    });\n  } else {\n    console.log('[Content Script] Party not active, skipping sync manager reinitialization');\n  }\n};\n\n// Also initialize sync manager when navigating TO a watch page (not just between watch pages)\nconst handleNavigationToWatch = () => {\n  console.log('[Content Script] Navigated to /watch page');\n  const state = stateManager.getState();\n  if (state.partyActive) {\n    console.log('[Content Script] Party is active, initializing sync manager');\n    syncManager.teardown();\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to initialize sync manager:', err);\n    });\n  }\n};\n\n// Teardown sync manager when leaving a watch page\nconst handleLeaveWatch = () => {\n  console.log('[Content Script] Left /watch page');\n  syncManager.teardown();\n};\n\nconst urlSync = new URLSync(stateManager, handleWatchPageChange, handleNavigationToWatch, handleLeaveWatch);\nconsole.log('[Content Script] Managers initialized');\n\nlet localStream = null;\nlet videoElementMonitor = null;\n\n// If party was active before this page load, try to restore videos immediately\nif (wasPartyActive) {\n  console.log('[Content Script] Party was active, checking for restoration state...');\n  setTimeout(() => {\n    // Give the page a moment to initialize\n    const state = stateManager.getState();\n    if (state.partyActive && localStream) {\n      console.log('[Content Script] Restoring local preview video after navigation');\n      const existingPreview = document.getElementById('tandem-local-preview');\n      if (!existingPreview) {\n        uiManager.attachLocalPreview(localStream);\n      }\n    }\n  }, 100);\n}\n\n// Monitor and restore video elements if they get removed during navigation\nfunction startVideoElementMonitoring() {\n  if (videoElementMonitor) return;\n  \n  videoElementMonitor = setInterval(() => {\n    const state = stateManager.getState();\n    if (!state.partyActive) return;\n    \n    // Check if local preview exists\n    if (localStream && !document.getElementById('tandem-local-preview')) {\n      console.log('[Content Script] Local preview missing, re-attaching');\n      uiManager.attachLocalPreview(localStream);\n    }\n    \n    // Check if remote videos exist\n    const remoteVideos = uiManager.getRemoteVideos();\n    const remoteStreams = uiManager.getRemoteStreams();\n    remoteStreams.forEach((stream, peerId) => {\n      const videoId = 'tandem-remote-' + peerId;\n      if (!document.getElementById(videoId)) {\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\n        const videoManager = webrtcManager.videoManager;\n        if (videoManager && videoManager.add) {\n          videoManager.add(peerId, stream);\n        }\n      }\n    });\n  }, 250); // Check every 250ms for faster restoration\n  \n  console.log('[Content Script] Started video element monitoring');\n}\n\nfunction stopVideoElementMonitoring() {\n  if (videoElementMonitor) {\n    clearInterval(videoElementMonitor);\n    videoElementMonitor = null;\n    console.log('[Content Script] Stopped video element monitoring');\n  }\n}\n\n(function checkRestorePartyState() {\n  const restorationState = urlSync.getRestorationState();\n  if (restorationState) {\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\n    urlSync.clearState();\n    stateManager.setRestoringFlag(true);\n    \n    setTimeout(function() {\n      console.log('[Content Script] Sending RESTORE_PARTY message');\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\n        if (response && response.success) {\n          console.log('[Content Script] Party restoration successful - setting state with userId:', response.userId);\n          // Immediately set the userId and roomId so we can handle incoming messages\n          stateManager.startParty(response.userId, response.roomId);\n          \n          // Re-obtain media stream for WebRTC signaling\n          console.log('[Content Script] Re-obtaining media stream after navigation');\n          navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n            .then(stream => {\n              console.log('[Content Script] Media stream obtained after restoration');\n              localStream = stream;\n              webrtcManager.setLocalStream(stream);\n              webrtcManager.onLocalStreamAvailable(stream);\n              uiManager.attachLocalPreview(stream);\n              \n              // Re-setup sync manager\n              syncManager.teardown();\n              syncManager.setup().catch(err => {\n                console.error('[Content Script] Failed to setup sync manager after restoration:', err);\n              });\n              \n              // Start URL monitoring if not already started\n              urlSync.start();\n              startVideoElementMonitoring();\n            })\n            .catch(err => {\n              console.error('[Content Script] Failed to get media stream after restoration:', err);\n            });\n        } else {\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\n        }\n        setTimeout(function() {\n          stateManager.setRestoringFlag(false);\n        }, 2000);\n      });\n    }, 1000);\n  }\n})();\n\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('[Content Script] Received message:', request.type);\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\n      .then(stream => {\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\n        localStream = stream;\n        console.log('[Content Script] Setting local stream on WebRTC manager');\n        webrtcManager.setLocalStream(stream);\n        webrtcManager.onLocalStreamAvailable(stream);\n        console.log('[Content Script] Attaching local preview to UI');\n        uiManager.attachLocalPreview(stream);\n        console.log('[Content Script] Local preview attached, sending success response');\n        sendResponse({ success: true });\n      })\n      .catch(err => {\n        console.error('[Content Script] Failed to get media stream:', err);\n        sendResponse({ success: false, error: err.message });\n      });\n    return true;\n  }\n\n  if (request.type === 'PARTY_STARTED') {\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\n    stateManager.startParty(request.userId, request.roomId);\n    \n    // Show \"Waiting for others...\" placeholder immediately\n    webrtcManager.showWaitingIndicator();\n    \n    // Show simple connection indicator\n    uiManager.showConnectionIndicator();\n    \n    // Set Netflix volume to 15%\n    setTimeout(() => {\n      netflixController.setVolume(0.15).then(() => {\n        console.log('[Content Script] Set Netflix volume to 15%');\n      }).catch(err => {\n        console.warn('[Content Script] Failed to set volume:', err);\n      });\n    }, 1000);\n    \n    // Teardown existing sync manager if already set up\n    syncManager.teardown();\n    \n    // Setup sync manager (will wait for video element)\n    syncManager.setup().catch(err => {\n      console.error('[Content Script] Failed to setup sync manager:', err);\n    });\n    \n    urlSync.start();\n    startVideoElementMonitoring();\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'PARTY_STOPPED') {\n    console.log('[Content Script] Stopping party');\n    stopVideoElementMonitoring();\n    stateManager.stopParty();\n    syncManager.teardown();\n    urlSync.stop();\n    urlSync.clearState();\n    webrtcManager.clearAll();\n    uiManager.removeLocalPreview();\n    uiManager.removeConnectionIndicator();\n    if (localStream) {\n      localStream.getTracks().forEach(t => t.stop());\n      localStream = null;\n    }\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SIGNAL') {\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\n    webrtcManager.handleSignal(request.message);\n  }\n\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\n    // Only apply playback controls if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring playback control - not on /watch page');\n      return;\n    }\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\n  }\n\n  // Passive sync removed - using event-based sync only\n\n  if (request.type === 'APPLY_SEEK') {\n    // Only apply seek if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring seek - not on /watch page');\n      return;\n    }\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\n  }\n\n  if (request.type === 'APPLY_URL_CHANGE') {\n    console.log('[Content Script] Received URL change request:', request.url, 'from', request.fromUserId);\n    \n    if (stateManager.restoringPartyState) {\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\n      return;\n    }\n    \n    // Apply URL changes to all Netflix pages (browse, title, watch, etc.)\n    const incomingUrl = new URL(request.url);\n    const currentUrl = window.location.href;\n    \n    // Don't navigate if we're already on this URL\n    if (currentUrl === request.url) {\n      console.log('[Content Script] Already on this URL, skipping navigation');\n      return;\n    }\n    \n    console.log('[Content Script] Navigating to:', request.url, 'using SPA navigation');\n    // Save state before navigating (for restoration if on /watch page)\n    const currentPath = window.location.pathname;\n    if (currentPath.startsWith('/watch')) {\n      urlSync.saveState();\n    }\n    \n    // Use history.pushState to navigate without full page reload (Netflix SPA style)\n    try {\n      window.history.pushState({}, '', request.url);\n      \n      // Trigger popstate event to let Netflix's router handle the navigation\n      window.dispatchEvent(new PopStateEvent('popstate', { state: {} }));\n      \n      console.log('[Content Script] SPA navigation triggered');\n    } catch (e) {\n      console.error('[Content Script] Failed to navigate via pushState, falling back to full reload:', e);\n      window.location.href = request.url;\n    }\n  }\n\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\n    // Only handle sync requests if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring sync request - not on /watch page');\n      return;\n    }\n    syncManager.handleRequestSync(request.fromUserId, request.respectAutoPlay);\n  }\n\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\n    // Only apply sync response if we're on a /watch page\n    if (!window.location.pathname.startsWith('/watch')) {\n      console.log('[Content Script] Ignoring sync response - not on /watch page');\n      return;\n    }\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url, request.respectAutoPlay ? '(respecting auto-play)' : '');\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url, request.respectAutoPlay);\n  }\n\n  if (request.type === 'REQUEST_INITIAL_SYNC_AND_PLAY') {\n    console.log('[Content Script] Requesting initial sync and will auto-play when synced');\n    // Request sync from other clients\n    stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\n  }\n\n  if (request.type === 'CONNECTION_STATUS') {\n    console.log('[Content Script] Connection status changed:', request.status);\n    uiManager.updateConnectionIndicator(request.status);\n  }\n\n  if (request.type === 'RECONNECTED') {\n    console.log('[Content Script] WebSocket reconnected, userId:', request.userId);\n  }\n\n  if (request.type === 'REQUEST_SYNC_AFTER_RECONNECT') {\n    // Only request sync if we're on a /watch page and party is active\n    if (window.location.pathname.startsWith('/watch') && stateManager.isActive()) {\n      console.log('[Content Script] Requesting sync after reconnection');\n      stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\n    }\n  }\n});\n\nwindow.addEventListener('beforeunload', () => {\n  if (stateManager.isActive()) {\n    urlSync.saveState();\n  }\n});\n","export class StateManager {\n  constructor() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    this.restoringPartyState = false;\n  }\n  startParty(userId, roomId) {\n    this.partyActive = true;\n    this.userId = userId;\n    this.roomId = roomId;\n    // Set flag so videos persist across navigation\n    sessionStorage.setItem('tandem_was_active', 'true');\n  }\n  stopParty() {\n    this.partyActive = false;\n    this.userId = null;\n    this.roomId = null;\n    // Clear flag so videos are cleaned up\n    sessionStorage.removeItem('tandem_was_active');\n  }\n  isActive() { return this.partyActive; }\n  getUserId() { return this.userId; }\n  getRoomId() { return this.roomId; }\n  getState() {\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\n  }\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\n  setRestoringFlag(value) { this.restoringPartyState = value; }\n  isExtensionContextValid() {\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\n  }\n  safeSendMessage(message, callback) {\n    if (!this.isExtensionContextValid()) {\n      console.warn('[StateManager] Extension context invalid - page needs reload after extension update');\n      // Show user notification that they need to reload\n      if (!document.getElementById('tandem-reload-notice')) {\n        const notice = document.createElement('div');\n        notice.id = 'tandem-reload-notice';\n        notice.style.cssText = 'position:fixed;top:20px;right:20px;background:#e50914;color:white;padding:15px;border-radius:8px;z-index:99999;font-family:Arial;box-shadow:0 4px 6px rgba(0,0,0,0.3);';\n        notice.innerHTML = '<strong>tandem.watch:</strong> Extension updated. Please reload this page.';\n        document.body.appendChild(notice);\n      }\n      return;\n    }\n    console.log('[StateManager] Sending message:', message.type, message);\n    try { \n      chrome.runtime.sendMessage(message, (response) => {\n        if (chrome.runtime.lastError) {\n          console.error('[StateManager] Error sending message:', message.type, chrome.runtime.lastError.message);\n        } else {\n          console.log('[StateManager] Message sent successfully:', message.type, response);\n        }\n        if (callback) callback(response);\n      }); \n    } catch (e) { \n      console.error('[StateManager] Exception sending message:', message.type, e.message, e); \n    }\n  }\n}\n","export class UIManager {\n  constructor() {\n    this.localPreviewVideo = null;\n    this.remoteVideos = new Map();\n    this.remoteStreams = new Map();\n    this.streamMonitorInterval = null;\n  }\n\n  makeDraggable(element) {\n    let isDragging = false;\n    let currentX;\n    let currentY;\n    let initialX;\n    let initialY;\n    let xOffset = 0;\n    let yOffset = 0;\n\n    element.addEventListener('mousedown', dragStart);\n    element.addEventListener('mouseup', dragEnd);\n    element.addEventListener('mousemove', drag);\n    element.style.cursor = 'move';\n\n    function dragStart(e) {\n      // Get current position from style\n      const computedStyle = window.getComputedStyle(element);\n      const bottom = computedStyle.bottom;\n      const left = computedStyle.left;\n      const right = computedStyle.right;\n      \n      // Convert to absolute positioning from current position\n      const rect = element.getBoundingClientRect();\n      element.style.left = rect.left + 'px';\n      element.style.top = rect.top + 'px';\n      element.style.bottom = 'auto';\n      element.style.right = 'auto';\n      \n      initialX = e.clientX - rect.left;\n      initialY = e.clientY - rect.top;\n      isDragging = true;\n      element.style.opacity = '0.8';\n    }\n\n    function dragEnd(e) {\n      initialX = currentX;\n      initialY = currentY;\n      isDragging = false;\n      element.style.opacity = '1';\n    }\n\n    function drag(e) {\n      if (isDragging) {\n        e.preventDefault();\n        currentX = e.clientX - initialX;\n        currentY = e.clientY - initialY;\n        \n        // Keep within viewport bounds\n        const maxX = window.innerWidth - element.offsetWidth;\n        const maxY = window.innerHeight - element.offsetHeight;\n        currentX = Math.max(0, Math.min(currentX, maxX));\n        currentY = Math.max(0, Math.min(currentY, maxY));\n        \n        setTranslate(currentX, currentY, element);\n      }\n    }\n\n    function setTranslate(xPos, yPos, el) {\n      el.style.left = xPos + 'px';\n      el.style.top = yPos + 'px';\n    }\n  }\n  getRemoteVideos() { return this.remoteVideos; }\n  getRemoteStreams() { return this.remoteStreams; }\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\n  clearStreamMonitorInterval() {\n    if (this.streamMonitorInterval) {\n      clearInterval(this.streamMonitorInterval);\n      this.streamMonitorInterval = null;\n    }\n  }\n\n  attachLocalPreview(stream) {\n    console.log('[UIManager] Attaching local preview with stream:', stream);\n    this.removeLocalPreview();\n    \n    const v = document.createElement('video');\n    v.id = 'tandem-local-preview';\n    v.autoplay = true;\n    v.muted = true; // Always mute local preview to avoid feedback\n    v.playsInline = true;\n    v.style.position = 'fixed';\n    v.style.bottom = '145px';\n    v.style.left = '20px';\n    v.style.width = '240px';\n    v.style.height = '160px';\n    v.style.zIndex = '999999';\n    v.style.border = '2px solid #e50914';\n    v.style.borderRadius = '4px';\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\n\n    try {\n      v.srcObject = stream;\n      console.log('[UIManager] Set srcObject on local preview');\n    } catch (e) {\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\n      v.src = URL.createObjectURL(stream);\n    }\n\n    document.body.appendChild(v);\n    this.localPreviewVideo = v;\n    console.log('[UIManager] Local preview video appended to body');\n\n    // Make it draggable\n    this.makeDraggable(v);\n\n    v.play().catch(err => {\n      console.warn('[UIManager] Local preview play() failed:', err);\n    });\n  }\n\n  removeLocalPreview() {\n    if (this.localPreviewVideo) {\n      console.log('[UIManager] Removing local preview video');\n      try {\n        if (this.localPreviewVideo.srcObject) {\n          this.localPreviewVideo.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[UIManager] Error clearing srcObject:', e);\n      }\n      this.localPreviewVideo.remove();\n      this.localPreviewVideo = null;\n    }\n  }\n\n  clearAll() {\n    this.removeLocalPreview();\n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    this.clearStreamMonitorInterval();\n    this.removeConnectionIndicator();\n  }\n\n  showConnectionIndicator() {\n    // Remove existing indicator if any\n    this.removeConnectionIndicator();\n\n    const indicator = document.createElement('div');\n    indicator.id = 'tandem-connection-indicator';\n    indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      left: 50%;\n      transform: translateX(-50%);\n      background: rgba(0, 0, 0, 0.85);\n      color: white;\n      padding: 8px 16px;\n      border-radius: 20px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      font-size: 13px;\n      font-weight: 500;\n      z-index: 999999;\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);\n      backdrop-filter: blur(10px);\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      transition: all 0.3s ease;\n    `;\n\n    const dot = document.createElement('div');\n    dot.id = 'tandem-connection-dot';\n    dot.style.cssText = `\n      width: 8px;\n      height: 8px;\n      border-radius: 50%;\n      background: #4ade80;\n      animation: pulse 2s ease-in-out infinite;\n    `;\n\n    const text = document.createElement('span');\n    text.id = 'tandem-connection-text';\n    text.textContent = 'Connected';\n\n    indicator.appendChild(dot);\n    indicator.appendChild(text);\n    document.body.appendChild(indicator);\n\n    // Add pulse animation\n    const style = document.createElement('style');\n    style.id = 'tandem-connection-style';\n    style.textContent = `\n      @keyframes pulse {\n        0%, 100% { opacity: 1; }\n        50% { opacity: 0.5; }\n      }\n      @keyframes spin {\n        0% { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    `;\n    document.head.appendChild(style);\n\n    return indicator;\n  }\n\n  updateConnectionIndicator(status) {\n    const dot = document.getElementById('tandem-connection-dot');\n    const text = document.getElementById('tandem-connection-text');\n    \n    if (dot && text) {\n      if (status === 'connected') {\n        dot.style.background = '#4ade80';\n        dot.style.animation = 'pulse 2s ease-in-out infinite';\n        text.textContent = 'Connected';\n      } else if (status === 'reconnecting') {\n        dot.style.background = '#f59e0b';\n        dot.style.animation = 'spin 1s linear infinite';\n        text.textContent = 'Reconnecting...';\n      } else if (status === 'disconnected') {\n        dot.style.background = '#ef4444';\n        dot.style.animation = 'pulse 1s ease-in-out infinite';\n        text.textContent = 'Disconnected';\n      }\n    }\n  }\n\n  removeConnectionIndicator() {\n    const indicator = document.getElementById('tandem-connection-indicator');\n    if (indicator) {\n      indicator.remove();\n    }\n  }\n}\n","export class NetflixController {\n  constructor() { this.injectAPIBridge(); }\n  injectAPIBridge() {\n    const script = document.createElement('script');\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\n    (document.head || document.documentElement).appendChild(script);\n    script.onload = function() { script.remove(); };\n  }\n  _sendCommand(command, args = []) {\n    return new Promise(function(resolve) {\n      const handler = function(e) {\n        if (e.detail.command === command) {\n          document.removeEventListener('__tandem_response', handler);\n          resolve(e.detail.result);\n        }\n      };\n      document.addEventListener('__tandem_response', handler);\n      setTimeout(function() { resolve(null); }, 1000);\n      document.dispatchEvent(new CustomEvent('__tandem_command', { detail: { command, args } }));\n    });\n  }\n  play() { return this._sendCommand('play'); }\n  pause() { return this._sendCommand('pause'); }\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\n  isPaused() { return this._sendCommand('isPaused'); }\n  setVolume(level) { return this._sendCommand('setVolume', [level]); }\n  getVolume() { return this._sendCommand('getVolume'); }\n  getVideoElement() { \n    // Find Netflix main player video element\n    // On /watch pages, look for video in the watch-video container\n    // On other pages, don't return any video (we don't want to sync preview videos)\n    \n    if (!window.location.pathname.startsWith('/watch')) {\n      return null;\n    }\n    \n    // Find Netflix video element, excluding tandem videos\n    const videos = document.querySelectorAll('video');\n    for (const video of videos) {\n      if (!video.id || !video.id.startsWith('tandem-')) {\n        return video;\n      }\n    }\n    return null;\n  }\n}\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef }) {\n  async function applyRemote(actionName, durationMs, actionFn) {\n    lock.set(durationMs);\n    try { await actionFn(); } catch (err) {\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\n    }\n  }\n\n  return {\n    async handleRequestSync(fromUserId, respectAutoPlay = false) {\n      if (!isInitializedRef.get()) {\n        console.log('[SyncManager] Not yet initialized, ignoring sync request');\n        return;\n      }\n      \n      const currentUrl = window.location.href;\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\n      \n      // If we're on browse page, don't send sync response\n      if (!isOnWatchPage) {\n        console.log('[SyncManager] On browse page, not sending sync response');\n        return;\n      }\n      \n      try {\n        const currentTime = await netflix.getCurrentTime();\n        const isPaused = await netflix.isPaused();\n        \n        if (currentTime == null) {\n          console.log('[SyncManager] Invalid playback state, ignoring sync request');\n          return;\n        }\n        \n        const currentTimeSeconds = currentTime / 1000;\n        console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl, respectAutoPlay ? '(will respect auto-play)' : '');\n        \n        state.safeSendMessage({\n          type: 'SYNC_RESPONSE',\n          targetUserId: fromUserId,\n          currentTime: currentTimeSeconds,\n          isPlaying: !isPaused,\n          url: currentUrl,\n          respectAutoPlay: respectAutoPlay\n        });\n      } catch (e) { console.error('[SyncManager] Error handling sync request:', e); }\n    },\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay = false) {\n      if (isInitializedRef.get()) {\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\n        return;\n      }\n      \n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\n        return;\n      }\n      \n      if (respectAutoPlay) {\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's (respecting auto-play)');\n      } else {\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\n      }\n      \n      // Check if we need to navigate to a different URL\n      const currentUrl = window.location.href;\n      const currentPath = window.location.pathname;\n      const isOnWatch = currentPath.startsWith('/watch');\n      const isOnBrowse = currentPath.startsWith('/browse');\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\n      \n      // Only navigate if we're NOT on a /watch page and the other user IS on /watch\n      // This allows initial sync to pull you to the watch page, but won't pull you back if you leave\n      if (!isOnWatch && otherIsOnWatch && isOnBrowse) {\n        console.log('[SyncManager] On browse page during initial join, other user on /watch - navigating to their show');\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        window.location.href = url;\n        return;\n      }\n      \n      // If we're not on /watch at all, ignore this sync response\n      if (!isOnWatch) {\n        console.log('[SyncManager] Not on /watch page - ignoring sync response');\n        isInitializedRef.set(true); // Mark as initialized so we don't keep processing these\n        return;\n      }\n      \n      // Regular URL mismatch handling\n      if (url && url !== currentUrl) {\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\n        // Store the sync state to apply after navigation\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\n          currentTime,\n          isPlaying,\n          timestamp: Date.now()\n        }));\n        // Navigate to the correct URL\n        window.location.href = url;\n        return;\n      }\n      \n      isInitializedRef.set(true);\n      \n      await applyRemote('initial-sync', 1500, async () => {\n        await netflix.seek(currentTime * 1000);\n        \n        // If respecting auto-play, only sync timestamp, not play/pause state\n        if (respectAutoPlay) {\n          console.log('[SyncManager] Synced timestamp only, respecting Netflix auto-play');\n          // Report position to server\n          const finalPaused = await netflix.isPaused();\n          state.safeSendMessage({\n            type: 'POSITION_UPDATE',\n            currentTime: currentTime,\n            isPlaying: !finalPaused\n          });\n          return;\n        }\n        \n        const localPaused = await netflix.isPaused();\n        \n        // Sync to the remote play/pause state\n        if (isPlaying && localPaused) {\n          console.log('[SyncManager] Remote is playing, starting playback');\n          await netflix.play();\n        } else if (!isPlaying && !localPaused) {\n          console.log('[SyncManager] Remote is paused, pausing playback');\n          await netflix.pause();\n        }\n        \n        // Report final position to server after sync complete\n        state.safeSendMessage({\n          type: 'POSITION_UPDATE',\n          currentTime: currentTime,\n          isPlaying: isPlaying\n        });\n      });\n    },\n    async handlePlaybackControl(control, currentTime, fromUserId) {\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'at', currentTime, 'from', fromUserId);\n      \n      await applyRemote(control, 1000, async () => {\n        // Seek to the exact position first\n        if (currentTime != null) {\n          const currentTimeMs = currentTime * 1000;\n          await netflix.seek(currentTimeMs);\n          console.log('[SyncManager] Seeked to', currentTime.toFixed(2) + 's before', control);\n        }\n        \n        // Then apply play/pause\n        if (control === 'play') {\n          await netflix.play();\n        } else {\n          await netflix.pause();\n        }\n      });\n    },\n    async handleSeek(currentTime, isPlaying, fromUserId) {\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\n      \n      await applyRemote('seek', 1200, async () => {\n        await netflix.seek(currentTime * 1000);\n        const isPaused = await netflix.isPaused();\n        \n        if (isPlaying && isPaused) {\n          await netflix.play();\n        } else if (!isPlaying && !isPaused) {\n          await netflix.pause();\n        }\n      });\n    }\n  };\n}\n","import { createSignalingHandlers } from './signaling.js';\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\nimport { createReconnectionManager } from './reconnect.js';\nimport { createRemoteVideoManager } from './ui.js';\n\nexport class WebRTCManager {\n  constructor(stateManager, uiManager) {\n    this.stateManager = stateManager;\n    this.uiManager = uiManager;\n    this.peerConnections = new Map();\n    this.remoteStreams = this.uiManager.getRemoteStreams();\n    this.remoteVideos = this.uiManager.getRemoteVideos();\n    this.peersThatLeft = new Set();\n    this.localStream = null;\n\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\n    \n    // Create a placeholder object for circular dependency resolution\n    const reconnectionManager = {};\n    \n    const createPeer = createPeerConnectionFactory({\n      stateManager: this.stateManager,\n      sendSignal: (msg) => this._sendSignal(msg),\n      remoteStreams: this.remoteStreams,\n      remoteVideos: this.remoteVideos,\n      addRemoteVideo: videoManager.add,\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      },\n      peersThatLeft: this.peersThatLeft,\n      showReconnecting: videoManager.showReconnecting,\n      hideOverlay: videoManager.hideOverlay,\n      showPlaceholder: videoManager.showPlaceholder\n    });\n\n    // Now create the actual reconnection manager with createPeer available\n    Object.assign(reconnectionManager, createReconnectionManager({\n      stateManager: this.stateManager,\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      localStream: () => this.localStream,\n      createPeer: createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack\n    }));\n\n    this.reconnectionManager = reconnectionManager;\n    this.createPeer = createPeer;\n    this.videoManager = videoManager;\n\n    this.signalingHandlers = createSignalingHandlers({\n      getState: () => this.stateManager.getState(),\n      peerConnections: this.peerConnections,\n      peersThatLeft: this.peersThatLeft,\n      getLocalStream: () => this.localStream,\n      createPeer,\n      sendSignal: (msg) => this._sendSignal(msg),\n      addOrReplaceTrack,\n      clearReconnection: reconnectionManager.clear,\n      removeRemoteVideo: (peerId) => {\n        videoManager.remove(peerId);\n        this.remoteStreams.delete(peerId);\n      }\n    });\n  }\n\n  setLocalStream(stream) { this.localStream = stream; }\n  getLocalStream() { return this.localStream; }\n  \n  onLocalStreamAvailable(stream) {\n    this.localStream = stream;\n    this.peerConnections.forEach((pc) => {\n      try {\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n      } catch (e) {}\n    });\n  }\n\n  async handleSignal(message) {\n    console.log('[WebRTCManager] handleSignal called with:', message);\n    if (!message || !message.type) {\n      console.warn('[WebRTCManager] Invalid message:', message);\n      return;\n    }\n    const type = message.type;\n    const from = message.userId || message.from;\n    const to = message.to;\n    const state = this.stateManager.getState();\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\n    \n    // Only check 'to' field for targeted messages (not broadcasts like JOIN)\n    // JOIN, LEAVE, and SYNC messages are broadcasts that don't have 'to' fields\n    const isTargetedMessage = type === 'OFFER' || type === 'ANSWER' || type === 'ICE_CANDIDATE' || type === 'SYNC_RESPONSE';\n    if (isTargetedMessage && to && to !== state.userId) {\n      console.log('[WebRTCManager] Ignoring targeted message not meant for me');\n      return;\n    }\n\n    if (type === 'JOIN' && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleJoin');\n      await this.signalingHandlers.handleJoin(from);\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleOffer');\n      await this.signalingHandlers.handleOffer(from, message.offer);\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\n      await this.signalingHandlers.handleAnswer(from, message.answer);\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\n    } else if (type === 'LEAVE' && from) {\n      console.log('[WebRTCManager] Dispatching to handleLeave');\n      this.signalingHandlers.handleLeave(from);\n    } else {\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'fromSelf:', from === state.userId, 'reasons:', {\n        JOIN: type === 'JOIN' ? `from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        OFFER: type === 'OFFER' ? `hasOffer=${!!message.offer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        ANSWER: type === 'ANSWER' ? `hasAnswer=${!!message.answer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        ICE: type === 'ICE_CANDIDATE' ? `hasCandidate=${!!message.candidate}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\n        LEAVE: type === 'LEAVE' ? `from=${!!from}` : 'N/A'\n      });\n    }\n  }\n\n  attemptReconnection(peerId) {\n    return this.reconnectionManager.attempt(peerId);\n  }\n\n  _sendSignal(message) {\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\n  }\n\n  showWaitingIndicator() {\n    console.log('[WebRTCManager] Showing waiting indicator');\n    this.videoManager.showWaitingIndicator();\n  }\n  \n  hideWaitingIndicator() {\n    console.log('[WebRTCManager] Hiding waiting indicator');\n    this.videoManager.hideWaitingIndicator();\n  }\n  \n  clearAll() {\n    console.log('[WebRTCManager] Clearing all connections and videos');\n    \n    // Hide waiting indicator\n    this.hideWaitingIndicator();\n    \n    this.peerConnections.forEach((pc) => {\n      try { pc.close(); } catch (e) {}\n    });\n    this.peerConnections.clear();\n    this.peersThatLeft.clear();\n    \n    // Clean up video elements and their containers\n    this.remoteVideos.forEach((v, peerId) => {\n      try { \n        if (v.srcObject) {\n          v.srcObject.getTracks().forEach(track => track.stop());\n          v.srcObject = null;\n        }\n      } catch (e) {}\n      \n      // Remove the container (which includes the video)\n      const container = document.getElementById('tandem-container-' + peerId);\n      if (container) {\n        console.log('[WebRTCManager] Removing container for peer:', peerId);\n        container.remove();\n      } else if (v.parentElement) {\n        // Fallback: remove parent if it exists\n        v.parentElement.remove();\n      } else {\n        // Last resort: just remove the video\n        v.remove();\n      }\n    });\n    \n    this.remoteVideos.clear();\n    this.remoteStreams.clear();\n    \n    // Extra cleanup: remove any orphaned tandem elements\n    document.querySelectorAll('[id^=\"tandem-container-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned container:', el.id);\n      el.remove();\n    });\n    document.querySelectorAll('[id^=\"tandem-remote-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned video:', el.id);\n      el.remove();\n    });\n    document.querySelectorAll('[id^=\"tandem-overlay-\"]').forEach(el => {\n      console.log('[WebRTCManager] Removing orphaned overlay:', el.id);\n      el.remove();\n    });\n    \n    if (this.localStream) {\n      this.localStream.getTracks().forEach(track => track.stop());\n      this.localStream = null;\n    }\n  }\n}\n","export function createRemoteVideoManager(remoteVideos) {\n  function createLoadingSpinner() {\n    // Create a more visually appealing spinner using CSS\n    const spinner = document.createElement('div');\n    spinner.className = 'tandem-spinner';\n    spinner.style.cssText = `\n      width: 40px;\n      height: 40px;\n      border: 4px solid rgba(255, 255, 255, 0.3);\n      border-top: 4px solid #00aaff;\n      border-radius: 50%;\n      animation: tandem-spin 1s linear infinite;\n      margin-bottom: 12px;\n    `;\n    return spinner;\n  }\n  \n  function makeDraggable(element) {\n    let isDragging = false;\n    let currentX;\n    let currentY;\n    let initialX;\n    let initialY;\n\n    element.addEventListener('mousedown', dragStart);\n    element.addEventListener('mouseup', dragEnd);\n    element.addEventListener('mousemove', drag);\n    element.style.cursor = 'move';\n\n    function dragStart(e) {\n      const computedStyle = window.getComputedStyle(element);\n      const rect = element.getBoundingClientRect();\n      \n      element.style.left = rect.left + 'px';\n      element.style.top = rect.top + 'px';\n      element.style.bottom = 'auto';\n      element.style.right = 'auto';\n      \n      initialX = e.clientX - rect.left;\n      initialY = e.clientY - rect.top;\n      isDragging = true;\n      element.style.opacity = '0.8';\n    }\n\n    function dragEnd(e) {\n      initialX = currentX;\n      initialY = currentY;\n      isDragging = false;\n      element.style.opacity = '1';\n    }\n\n    function drag(e) {\n      if (isDragging) {\n        e.preventDefault();\n        currentX = e.clientX - initialX;\n        currentY = e.clientY - initialY;\n        \n        const maxX = window.innerWidth - element.offsetWidth;\n        const maxY = window.innerHeight - element.offsetHeight;\n        currentX = Math.max(0, Math.min(currentX, maxX));\n        currentY = Math.max(0, Math.min(currentY, maxY));\n        \n        element.style.left = currentX + 'px';\n        element.style.top = currentY + 'px';\n      }\n    }\n  }\n\n  function add(peerId, stream) {\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\n    console.log('[RemoteVideoManager] Current remoteVideos map size:', remoteVideos.size, 'peers:', Array.from(remoteVideos.keys()));\n    \n    // Check if video already exists in DOM (double-check for race conditions)\n    const existingInDom = document.getElementById('tandem-remote-' + peerId);\n    if (existingInDom) {\n      console.log('[RemoteVideoManager] Video already exists in DOM for peer:', peerId, 'skipping duplicate creation');\n      // Update stream on existing element if different\n      if (existingInDom.srcObject !== stream) {\n        console.log('[RemoteVideoManager] Updating stream on existing video element');\n        existingInDom.srcObject = stream;\n        // Remove loading overlay if it exists\n        const overlay = document.getElementById('tandem-overlay-' + peerId);\n        if (overlay) overlay.remove();\n      }\n      // Make sure it's tracked\n      if (!remoteVideos.has(peerId)) {\n        remoteVideos.set(peerId, existingInDom);\n      }\n      return;\n    }\n    \n    // Check if a placeholder container already exists\n    let container = document.getElementById('tandem-container-' + peerId);\n    \n    if (!container) {\n      // No placeholder exists, create container from scratch\n      // Remove any stale references\n      remove(peerId);\n      \n      container = document.createElement('div');\n      container.id = 'tandem-container-' + peerId;\n      container.style.position = 'fixed';\n      container.style.bottom = '145px';\n      container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n      container.style.width = '240px';\n      container.style.height = '160px';\n      container.style.zIndex = 999999;\n      container.style.border = '2px solid #00aaff';\n      container.style.borderRadius = '4px';\n      container.style.backgroundColor = '#000';\n    } else {\n      console.log('[RemoteVideoManager] Using existing placeholder container for peer:', peerId);\n    }\n    \n    const v = document.createElement('video');\n    v.id = 'tandem-remote-' + peerId;\n    v.autoplay = true;\n    v.playsInline = true;\n    v.muted = true;\n    v.style.width = '100%';\n    v.style.height = '100%';\n    v.style.border = '2px solid #00aaff';\n    v.style.borderRadius = '4px';\n    v.style.backgroundColor = '#000';\n    \n    // Get or create overlay\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (!overlay) {\n      overlay = document.createElement('div');\n      overlay.id = 'tandem-overlay-' + peerId;\n      overlay.style.position = 'absolute';\n      overlay.style.top = '0';\n      overlay.style.left = '0';\n      overlay.style.width = '100%';\n      overlay.style.height = '100%';\n      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n      overlay.style.display = 'flex';\n      overlay.style.flexDirection = 'column';\n      overlay.style.alignItems = 'center';\n      overlay.style.justifyContent = 'center';\n      overlay.style.color = '#fff';\n      overlay.style.fontSize = '14px';\n      overlay.style.fontFamily = 'Arial, sans-serif';\n      overlay.style.borderRadius = '4px';\n      overlay.style.pointerEvents = 'none';\n      \n      const spinner = createLoadingSpinner();\n      const text = document.createElement('div');\n      text.textContent = 'Connecting...';\n      text.style.fontWeight = '500';\n      \n      overlay.appendChild(spinner);\n      overlay.appendChild(text);\n    }\n    \n    // Add spinner animation styles (only once)\n    if (!document.getElementById('tandem-spinner-styles')) {\n      const style = document.createElement('style');\n      style.id = 'tandem-spinner-styles';\n      style.textContent = `\n        @keyframes tandem-spin {\n          0% { transform: rotate(0deg); }\n          100% { transform: rotate(360deg); }\n        }\n        @keyframes tandem-pulse {\n          0%, 100% { opacity: 0.3; }\n          50% { opacity: 1; }\n        }\n      `;\n      document.head.appendChild(style);\n    }\n    \n    container.appendChild(v);\n    if (!overlay.parentElement) {\n      container.appendChild(overlay);\n    }\n    if (!container.parentElement) {\n      document.body.appendChild(container);\n      // Make container draggable if newly created\n      makeDraggable(container);\n    }\n    console.log('[RemoteVideoManager] Added video to container:', container.id);\n    \n    // Verify stream has active tracks\n    const activeTracks = stream.getTracks().filter(t => t.readyState === 'live');\n    console.log('[RemoteVideoManager] Stream has', activeTracks.length, 'active tracks:', \n      activeTracks.map(t => `${t.kind}:${t.id.substring(0,8)}`).join(', '));\n    \n    try { \n      v.srcObject = stream;\n      console.log('[RemoteVideoManager] Set srcObject successfully');\n    } catch (e) { \n      console.warn('[RemoteVideoManager] srcObject failed:', e);\n    }\n    \n    remoteVideos.set(peerId, v);\n    \n    // Handle video playback with better error handling\n    const playVideo = () => {\n      v.play().then(() => {\n        console.log('[RemoteVideoManager] Video playing, unmuting and removing overlay');\n        v.muted = false;\n        v.volume = 1.0;\n        // Remove loading overlay\n        overlay.remove();\n      }).catch((e) => { \n        console.warn('[RemoteVideoManager] Play failed:', e.name, e.message);\n        // Try unmuting anyway in case autoplay blocked\n        v.muted = false;\n        // Still remove overlay even if play failed\n        overlay.remove();\n      });\n    };\n    \n    // If stream already has tracks, play immediately\n    if (activeTracks.length > 0) {\n      playVideo();\n    } else {\n      // Wait for tracks to become active\n      console.log('[RemoteVideoManager] Waiting for stream tracks to become active');\n      overlay.innerHTML = '<div style=\"text-align: center;\"><div style=\"margin-bottom: 8px;\"></div><div>Waiting for stream...</div></div>';\n      const checkTracks = setInterval(() => {\n        const nowActive = stream.getTracks().filter(t => t.readyState === 'live');\n        if (nowActive.length > 0) {\n          clearInterval(checkTracks);\n          console.log('[RemoteVideoManager] Tracks now active, playing video');\n          playVideo();\n        }\n      }, 100);\n      // Give up after 5 seconds and remove overlay anyway\n      setTimeout(() => {\n        clearInterval(checkTracks);\n        if (overlay.parentNode) {\n          console.log('[RemoteVideoManager] Timeout waiting for tracks, removing overlay');\n          overlay.remove();\n        }\n      }, 5000);\n    }\n  }\n  \n  function remove(peerId) {\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\n    \n    // Remove from map\n    const v = remoteVideos.get(peerId);\n    if (v) {\n      try { \n        if (v.srcObject) {\n          v.srcObject.getTracks().forEach(track => track.stop());\n          v.srcObject = null;\n        }\n      } catch (e) {\n        console.warn('[RemoteVideoManager] Error cleaning up stream:', e);\n      }\n      // Remove the container (which includes the video)\n      const container = v.parentElement;\n      if (container && container.id === 'tandem-container-' + peerId) {\n        container.remove();\n      } else {\n        v.remove();\n      }\n      remoteVideos.delete(peerId);\n    }\n    \n    // Also check DOM for any orphaned elements (extra safety)\n    const domContainer = document.getElementById('tandem-container-' + peerId);\n    if (domContainer) {\n      console.log('[RemoteVideoManager] Found orphaned container, removing');\n      domContainer.remove();\n    }\n    \n    const domElement = document.getElementById('tandem-remote-' + peerId);\n    if (domElement && domElement !== v) {\n      console.log('[RemoteVideoManager] Found orphaned video element, removing');\n      try {\n        if (domElement.srcObject) {\n          domElement.srcObject = null;\n        }\n      } catch (e) {}\n      domElement.remove();\n    }\n    \n    // Clean up overlay if it exists\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      overlay.remove();\n    }\n  }\n  \n  function showReconnecting(peerId) {\n    console.log('[RemoteVideoManager] Showing reconnecting overlay for peer:', peerId);\n    \n    // Check if overlay already exists\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      // Update existing overlay content\n      overlay.innerHTML = '';\n      const spinner = createLoadingSpinner();\n      const text = document.createElement('div');\n      text.textContent = 'Reconnecting...';\n      text.style.fontWeight = '500';\n      overlay.appendChild(spinner);\n      overlay.appendChild(text);\n      overlay.style.display = 'flex';\n      return;\n    }\n    \n    // Create new overlay if it doesn't exist\n    const container = document.getElementById('tandem-container-' + peerId);\n    if (!container) {\n      console.warn('[RemoteVideoManager] Cannot show reconnecting - container not found');\n      return;\n    }\n    \n    overlay = document.createElement('div');\n    overlay.id = 'tandem-overlay-' + peerId;\n    overlay.style.position = 'absolute';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n    overlay.style.display = 'flex';\n    overlay.style.flexDirection = 'column';\n    overlay.style.alignItems = 'center';\n    overlay.style.justifyContent = 'center';\n    overlay.style.color = '#fff';\n    overlay.style.fontSize = '14px';\n    overlay.style.fontFamily = 'Arial, sans-serif';\n    overlay.style.borderRadius = '4px';\n    overlay.style.pointerEvents = 'none';\n    \n    const spinner = createLoadingSpinner();\n    const text = document.createElement('div');\n    text.textContent = 'Reconnecting...';\n    text.style.fontWeight = '500';\n    \n    overlay.appendChild(spinner);\n    overlay.appendChild(text);\n    container.appendChild(overlay);\n  }\n  \n  function hideOverlay(peerId) {\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\n    if (overlay) {\n      console.log('[RemoteVideoManager] Hiding overlay for peer:', peerId);\n      overlay.remove();\n    }\n  }\n  \n  function showWaitingIndicator() {\n    // Remove any existing waiting indicator first\n    hideWaitingIndicator();\n    \n    console.log('[RemoteVideoManager] Showing waiting indicator');\n    const container = document.createElement('div');\n    container.id = 'tandem-waiting-indicator';\n    container.style.position = 'fixed';\n    container.style.bottom = '145px';\n    container.style.right = '20px';\n    container.style.width = '240px';\n    container.style.height = '160px';\n    container.style.zIndex = 999999;\n    container.style.border = '2px solid #00aaff';\n    container.style.borderRadius = '4px';\n    container.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';\n    container.style.display = 'flex';\n    container.style.flexDirection = 'column';\n    container.style.alignItems = 'center';\n    container.style.justifyContent = 'center';\n    container.style.color = '#fff';\n    container.style.fontSize = '14px';\n    container.style.fontFamily = 'Arial, sans-serif';\n    container.style.pointerEvents = 'none';\n    \n    const spinner = createLoadingSpinner();\n    const text = document.createElement('div');\n    text.textContent = 'Waiting for others...';\n    text.style.fontWeight = '500';\n    text.style.marginTop = '8px';\n    \n    container.appendChild(spinner);\n    container.appendChild(text);\n    document.body.appendChild(container);\n  }\n  \n  function hideWaitingIndicator() {\n    const indicator = document.getElementById('tandem-waiting-indicator');\n    if (indicator) {\n      console.log('[RemoteVideoManager] Hiding waiting indicator');\n      indicator.remove();\n    }\n  }\n  \n  function showPlaceholder(peerId) {\n    console.log('[RemoteVideoManager] Showing placeholder for peer:', peerId);\n    \n    // Hide waiting indicator when first peer connects\n    hideWaitingIndicator();\n    \n    // Check if container already exists\n    let container = document.getElementById('tandem-container-' + peerId);\n    if (container) {\n      console.log('[RemoteVideoManager] Placeholder already exists for peer:', peerId, '- reusing it');\n      return;\n    }\n    \n    console.log('[RemoteVideoManager] Creating NEW placeholder container for peer:', peerId);\n    \n    // Create container immediately\n    container = document.createElement('div');\n    container.id = 'tandem-container-' + peerId;\n    container.style.position = 'fixed';\n    container.style.bottom = '145px';\n    container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\n    container.style.width = '240px';\n    container.style.height = '160px';\n    container.style.zIndex = 999999;\n    container.style.border = '2px solid #00aaff';\n    container.style.borderRadius = '4px';\n    container.style.backgroundColor = '#000';\n    \n    // Create loading overlay\n    const overlay = document.createElement('div');\n    overlay.id = 'tandem-overlay-' + peerId;\n    overlay.style.position = 'absolute';\n    overlay.style.top = '0';\n    overlay.style.left = '0';\n    overlay.style.width = '100%';\n    overlay.style.height = '100%';\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\n    overlay.style.display = 'flex';\n    overlay.style.flexDirection = 'column';\n    overlay.style.alignItems = 'center';\n    overlay.style.justifyContent = 'center';\n    overlay.style.color = '#fff';\n    overlay.style.fontSize = '14px';\n    overlay.style.fontFamily = 'Arial, sans-serif';\n    overlay.style.borderRadius = '4px';\n    overlay.style.pointerEvents = 'none';\n    \n    const spinner = createLoadingSpinner();\n    const text = document.createElement('div');\n    text.textContent = 'Connecting...';\n    text.style.fontWeight = '500';\n    \n    overlay.appendChild(spinner);\n    overlay.appendChild(text);\n    container.appendChild(overlay);\n    document.body.appendChild(container);\n    \n    // Make container draggable immediately\n    makeDraggable(container);\n    \n    console.log('[RemoteVideoManager] Created placeholder container:', container.id);\n  }\n  \n  return { add, remove, showReconnecting, hideOverlay, showPlaceholder, showWaitingIndicator, hideWaitingIndicator };\n}\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\n  const attempts = new Map();\n  const timeouts = new Map();\n  \n  function clear(peerId) {\n    attempts.delete(peerId);\n    const handle = timeouts.get(peerId);\n    if (handle) {\n      clearTimeout(handle);\n      timeouts.delete(peerId);\n    }\n  }\n  \n  async function attempt(peerId) {\n    if (!stateManager.isInParty()) return;\n    if (peersThatLeft.has(peerId)) {\n      clear(peerId);\n      return;\n    }\n    const count = attempts.get(peerId) || 0;\n    const maxAttempts = 5;\n    // Faster reconnection: 500ms, 1s, 2s, 4s, 8s (instead of 1s, 2s, 4s, 8s, 16s)\n    const backoffDelay = Math.min(500 * Math.pow(2, count), 10000);\n    if (count >= maxAttempts) {\n      console.log('[Reconnection] Max attempts reached for peer:', peerId);\n      clear(peerId);\n      return;\n    }\n    console.log('[Reconnection] Attempting reconnection for peer:', peerId, 'attempt:', count + 1, 'delay:', backoffDelay + 'ms');\n    attempts.set(peerId, count + 1);\n    const existing = timeouts.get(peerId);\n    if (existing) clearTimeout(existing);\n    const handle = setTimeout(async () => {\n      const oldPc = peerConnections.get(peerId);\n      if (oldPc) {\n        try { oldPc.close(); } catch (e) {}\n        peerConnections.delete(peerId);\n      }\n      try {\n        const pc = createPeer(peerId);\n        peerConnections.set(peerId, pc);\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\n        if (stream) {\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\n        }\n        const offer = await pc.createOffer();\n        await pc.setLocalDescription(offer);\n        const state = stateManager.getState();\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\n      } catch (err) {\n        console.error('[WebRTCManager] Reconnection failed:', err);\n        attempt(peerId);\n      }\n    }, backoffDelay);\n    timeouts.set(peerId, handle);\n  }\n  \n  return { attempt, clear };\n}\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\n  return {\n    async handleJoin(from) {\n      console.log('[Signaling] Handling JOIN from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring JOIN from self');\n        return;\n      }\n      \n      // First, clear any reconnection attempts - peer has explicitly rejoined\n      clearReconnection(from);\n      peersThatLeft.delete(from);\n      \n      let pc = peerConnections.get(from);\n      if (pc) {\n        const connectionState = pc.connectionState;\n        console.log('[Signaling] Already have peer connection for', from, 'state:', connectionState);\n        \n        // If connection is still good (connected/connecting), reuse it\n        if (connectionState === 'connected' || connectionState === 'connecting') {\n          console.log('[Signaling] Reusing existing connection - ensuring tracks are present');\n          const stream = getLocalStream();\n          if (stream) {\n            let needsRenegotiation = false;\n            stream.getTracks().forEach(t => {\n              const senders = pc.getSenders();\n              const existingSender = senders.find(s => s.track && s.track.kind === t.kind);\n              if (!existingSender || existingSender.track.id !== t.id) {\n                console.log('[Signaling] Track changed, replacing:', t.kind, t.id);\n                addOrReplaceTrack(pc, t, stream);\n                needsRenegotiation = true;\n              }\n            });\n            \n            // Only renegotiate if tracks changed\n            if (needsRenegotiation && pc.signalingState === 'stable') {\n              console.log('[Signaling] Renegotiating due to track changes');\n              const offer = await pc.createOffer();\n              await pc.setLocalDescription(offer);\n              sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n            }\n          }\n          return;\n        }\n        \n        // For any other state (disconnected/failed/closed), clean it up and create new connection\n        // This handles the case where a peer refreshes - their old connection is stuck in \n        // disconnected/failed state, so we need to clean it up when they rejoin\n        console.log('[Signaling] Cleaning up existing connection in state:', connectionState);\n        clearReconnection(from);\n        removeRemoteVideo(from);\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n        pc = null;\n      }\n      \n      if (!pc) {\n        try {\n          console.log('[Signaling] Creating new peer connection for', from);\n          pc = createPeer(from);\n          peerConnections.set(from, pc);\n          const stream = getLocalStream();\n          console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n          if (stream) {\n            stream.getTracks().forEach(t => {\n              console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n              addOrReplaceTrack(pc, t, stream);\n            });\n          } else {\n            console.warn('[Signaling] No local stream available when handling JOIN');\n          }\n          console.log('[Signaling] Creating and sending OFFER to', from);\n          const offer = await pc.createOffer();\n          await pc.setLocalDescription(offer);\n          sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\n        } catch (err) {\n          console.error('[Signaling] Error handling JOIN:', err);\n          peerConnections.delete(from);\n        }\n      }\n    },\n    async handleOffer(from, offer) {\n      console.log('[Signaling] Handling OFFER from', from);\n      const state = getState();\n      if (from === state.userId) {\n        console.log('[Signaling] Ignoring OFFER from self');\n        return;\n      }\n      let pc = peerConnections.get(from);\n      if (pc) {\n        console.log('[Signaling] Existing peer connection state:', pc.signalingState);\n        if (pc.signalingState !== 'closed' && pc.signalingState !== 'stable') {\n          console.log('[Signaling] Closing existing peer connection in state:', pc.signalingState);\n          try { pc.close(); } catch (e) {}\n          peerConnections.delete(from);\n          pc = null;\n        } else if (pc.signalingState === 'stable') {\n          // If stable, this might be a renegotiation - close and recreate\n          console.log('[Signaling] Closing stable peer connection for renegotiation');\n          try { pc.close(); } catch (e) {}\n          peerConnections.delete(from);\n          pc = null;\n        }\n      }\n      if (!pc) {\n        console.log('[Signaling] Creating new peer connection for', from);\n        // Clear any reconnection attempts when receiving an offer\n        clearReconnection(from);\n        peersThatLeft.delete(from);\n        pc = createPeer(from);\n        peerConnections.set(from, pc);\n      }\n      try {\n        console.log('[Signaling] Setting remote description, current state:', pc.signalingState);\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\n        const stream = getLocalStream();\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\n        if (stream) {\n          stream.getTracks().forEach(t => {\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\n            addOrReplaceTrack(pc, t, stream);\n          });\n        } else {\n          console.warn('[Signaling] No local stream available when handling OFFER');\n        }\n        console.log('[Signaling] Creating and sending ANSWER to', from);\n        const answer = await pc.createAnswer();\n        await pc.setLocalDescription(answer);\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\n      } catch (err) {\n        console.error('[Signaling] Error handling offer:', err.name, err.message);\n        console.error('[Signaling] Full error:', err);\n        peerConnections.delete(from);\n        try { pc.close(); } catch (e) {}\n      }\n    },\n    async handleAnswer(from, answer) {\n      console.log('[Signaling] Handling ANSWER from', from);\n      const pc = peerConnections.get(from);\n      if (!pc) {\n        console.warn('[Signaling] Cannot handle ANSWER - no peer connection found for', from);\n        return;\n      }\n      \n      console.log('[Signaling] Peer connection state:', {\n        signalingState: pc.signalingState,\n        connectionState: pc.connectionState,\n        iceConnectionState: pc.iceConnectionState\n      });\n      \n      if (pc.signalingState === 'have-local-offer') {\n        console.log('[Signaling] Setting remote description from ANSWER');\n        try {\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\n          console.log('[Signaling] Remote description set successfully');\n        } catch (err) {\n          console.error('[Signaling] Error handling answer:', err.name, err.message);\n          console.error('[Signaling] Full error:', err);\n          // If the peer connection is in a bad state, close it and remove it\n          if (err.name === 'InvalidStateError' || err.name === 'OperationError') {\n            console.log('[Signaling] Closing peer connection due to state error');\n            try { pc.close(); } catch (e) {}\n            peerConnections.delete(from);\n          }\n        }\n      } else if (pc.signalingState === 'stable') {\n        console.log('[Signaling] Received ANSWER but already in stable state (connection:', pc.connectionState + ') - likely duplicate, ignoring');\n      } else if (pc.signalingState === 'have-remote-offer') {\n        console.warn('[Signaling] Received ANSWER but expecting to send one (have-remote-offer) - might be glare, ignoring');\n      } else if (pc.signalingState === 'closed') {\n        console.warn('[Signaling] Received ANSWER but peer connection is closed - ignoring');\n      } else {\n        console.warn('[Signaling] Cannot handle ANSWER - unexpected state:', pc.signalingState);\n      }\n    },\n    async handleIceCandidate(from, candidate) {\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try {\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\n          console.log('[Signaling] ICE candidate added successfully');\n        } catch (err) {\n          console.warn('[Signaling] Error adding ICE candidate', err);\n        }\n      } else {\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\n      }\n    },\n    handleLeave(from) {\n      console.log('[Signaling] Handling LEAVE from', from);\n      peersThatLeft.add(from);\n      const pc = peerConnections.get(from);\n      if (pc) {\n        try { pc.close(); } catch (e) {}\n        peerConnections.delete(from);\n      }\n      clearReconnection(from);\n      removeRemoteVideo(from);\n    }\n  };\n}\n","export class URLSync {\n  constructor(stateManager, onWatchPageChange, onNavigateToWatch, onLeaveWatch) {\n    this.stateManager = stateManager;\n    this.urlMonitorInterval = null;\n    this.lastUrl = null;\n    this.onWatchPageChange = onWatchPageChange || (() => {});\n    this.onNavigateToWatch = onNavigateToWatch || (() => {});\n    this.onLeaveWatch = onLeaveWatch || (() => {});\n    this.handleUrlChange = this.handleUrlChange.bind(this);\n  }\n  \n  handleUrlChange() {\n    const currentUrl = window.location.href;\n    if (currentUrl !== this.lastUrl) {\n      console.log('[URLSync] URL changed from', this.lastUrl, 'to', currentUrl);\n      const lastPath = this.lastUrl ? new URL(this.lastUrl).pathname : '';\n      const currentPath = new URL(currentUrl).pathname;\n      \n      // Check if we navigated to a different /watch page or left /watch\n      const wasOnWatch = lastPath.startsWith('/watch');\n      const wasOnBrowse = lastPath.startsWith('/browse');\n      const nowOnWatch = currentPath.startsWith('/watch');\n      const watchPageChanged = wasOnWatch && nowOnWatch && lastPath !== currentPath;\n      const navigatedToWatch = !wasOnWatch && nowOnWatch;\n      const navigatedFromBrowseToWatch = wasOnBrowse && nowOnWatch;\n      const leftWatch = wasOnWatch && !nowOnWatch;\n      \n      this.lastUrl = currentUrl;\n      \n      // If we navigated from browse to watch, set flag to respect Netflix auto-play\n      if (navigatedFromBrowseToWatch) {\n        console.log('[URLSync] Navigated from browse to /watch - setting auto-play flag');\n        sessionStorage.setItem('tandem_from_browse', 'true');\n      }\n      \n      // If we changed to a different /watch page, reinitialize sync\n      if (watchPageChanged) {\n        console.log('[URLSync] Watch page changed - triggering sync reinitialization');\n        this.onWatchPageChange();\n      }\n      \n      // If we navigated TO a /watch page from elsewhere, initialize sync\n      if (navigatedToWatch) {\n        console.log('[URLSync] Navigated to /watch page - triggering sync initialization');\n        this.onNavigateToWatch();\n      }\n      \n      // If we left a /watch page, teardown sync\n      if (leftWatch) {\n        console.log('[URLSync] Left /watch page - triggering sync teardown');\n        this.onLeaveWatch();\n      }\n      \n      const state = this.stateManager.getState();\n      \n      // Broadcast all Netflix URL changes to the party\n      // This keeps everyone synchronized on browse, title pages, etc.\n      if (state.partyActive) {\n        console.log('[URLSync] Broadcasting URL change to party:', currentPath);\n        this.stateManager.safeSendMessage({ \n          type: 'URL_CHANGE', \n          url: currentUrl \n        });\n      }\n      \n      // If someone leaves /watch, pause the video for everyone\n      if (state.partyActive && leftWatch) {\n        console.log('[URLSync] Left /watch page - sending pause to all clients');\n        this.stateManager.safeSendMessage({ \n          type: 'PLAY_PAUSE', \n          control: 'pause',\n          timestamp: 0\n        });\n      }\n    }\n  }\n  \n  start() { \n    this.lastUrl = window.location.href;\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\n    \n    // Clear any existing interval and listeners\n    this.stop();\n    \n    // Listen for popstate events (back/forward button, pushState)\n    window.addEventListener('popstate', this.handleUrlChange);\n    \n    // Listen for pushState/replaceState by monkey-patching\n    const originalPushState = history.pushState;\n    const originalReplaceState = history.replaceState;\n    \n    history.pushState = (...args) => {\n      originalPushState.apply(history, args);\n      this.handleUrlChange();\n    };\n    \n    history.replaceState = (...args) => {\n      originalReplaceState.apply(history, args);\n      this.handleUrlChange();\n    };\n    \n    // Also poll as a fallback (in case Netflix uses some other navigation method)\n    this.urlMonitorInterval = setInterval(() => {\n      this.handleUrlChange();\n    }, 500);\n  }\n  \n  stop() {\n    console.log('[URLSync] Stopping URL monitoring');\n    \n    if (this.urlMonitorInterval) { \n      clearInterval(this.urlMonitorInterval); \n      this.urlMonitorInterval = null; \n    }\n    \n    window.removeEventListener('popstate', this.handleUrlChange);\n    \n    this.lastUrl = null;\n  }\n  saveState() {\n    const state = this.stateManager.getState();\n    if (!state.partyActive) return;\n    const existing = this.getRestorationState() || {};\n    const payload = {\n      roomId: state.roomId,\n      currentTime: existing.currentTime || null,\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\n      timestamp: Date.now()\n    };\n    sessionStorage.setItem('tandem_restore', JSON.stringify(payload));\n  }\n  clearState() { sessionStorage.removeItem('tandem_restore'); }\n  getRestorationState() {\n    const stored = sessionStorage.getItem('tandem_restore');\n    if (!stored) return null;\n    try {\n      const state = JSON.parse(stored);\n      if (Date.now() - state.timestamp < 30000) { return state; }\n    } catch (e) { console.error('[tandem] Failed to parse restoration state:', e); }\n    return null;\n  }\n}\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","attachPlaybackListeners","video","state","isInitializedRef","lock","onPlay","onPause","onSeek","handlePlay","console","log","isInitialized","get","lockActive","handlePause","handleSeeked","addEventListener","MutableRef","value","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","warn","addTrack","wasPartyActive","sessionStorage","getItem","staleContainers","document","querySelectorAll","staleVideos","staleOverlays","staleLocalVideo","getElementById","staleWaitingIndicator","forEach","el","id","remove","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","setItem","stopParty","removeItem","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","safeSendMessage","message","callback","type","sendMessage","response","lastError","error","notice","createElement","style","cssText","innerHTML","body","appendChild","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","makeDraggable","element","currentX","currentY","initialX","initialY","isDragging","computedStyle","window","getComputedStyle","rect","bottom","left","right","getBoundingClientRect","top","clientX","clientY","opacity","preventDefault","maxX","innerWidth","offsetWidth","maxY","innerHeight","offsetHeight","Math","max","min","xPos","yPos","cursor","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","clearInterval","attachLocalPreview","removeLocalPreview","autoplay","muted","playsInline","position","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","play","err","clearAll","clear","removeConnectionIndicator","showConnectionIndicator","indicator","dot","text","textContent","head","updateConnectionIndicator","status","background","animation","netflixController","injectAPIBridge","script","getURL","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","setVolume","level","getVolume","getVideoElement","location","pathname","startsWith","videos","syncManager","netflix","listeners","remote","async","applyRemote","actionName","actionFn","handleRequestSync","fromUserId","respectAutoPlay","currentUrl","href","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","url","handleSyncResponse","currentPath","isOnWatch","isOnBrowse","otherIsOnWatch","JSON","stringify","timestamp","finalPaused","localPaused","handlePlaybackControl","control","toUpperCase","currentTimeMs","handleSeek","createRemoteHandlers","setup","waitForVideo","pendingSyncStr","pendingSync","parse","vid","broadcastPlay","broadcastPause","broadcastSeek","broadcastLeaderState","onVideoReady","readyState","requestSyncWhenReady","teardown","reject","timeout","Error","check","clearTimeout","isOnWatchPage","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","createLoadingSpinner","spinner","className","peerId","getTracks","stop","container","parentElement","delete","domContainer","domElement","overlay","hideWaitingIndicator","add","size","Array","from","keys","existingInDom","has","backgroundColor","display","flexDirection","alignItems","justifyContent","color","fontSize","fontFamily","pointerEvents","fontWeight","activeTracks","filter","t","length","map","substring","join","playVideo","then","volume","name","checkTracks","setInterval","parentNode","showReconnecting","hideOverlay","showPlaceholder","showWaitingIndicator","marginTop","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","to","ontrack","streams","MediaStream","hasVideoInMap","hasVideoInDom","existingVideo","tracks","hasAudio","some","hasVideo","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","attempt","Object","assign","attempts","timeouts","handle","count","backoffDelay","pow","existing","oldPc","close","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","needsRenegotiation","signalingState","handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","iceConnectionState","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","JOIN","OFFER","ANSWER","ICE","LEAVE","urlSync","onWatchPageChange","onNavigateToWatch","onLeaveWatch","urlMonitorInterval","lastUrl","handleUrlChange","bind","lastPath","wasOnWatch","wasOnBrowse","nowOnWatch","watchPageChanged","navigatedToWatch","navigatedFromBrowseToWatch","leftWatch","start","originalPushState","history","pushState","originalReplaceState","replaceState","apply","saveState","getRestorationState","payload","clearState","stored","videoElementMonitor","startVideoElementMonitoring","videoId","restorationState","success","navigator","mediaDevices","getUserMedia","audio","onMessage","addListener","request","sender","sendResponse","PopStateEvent"],"ignoreList":[],"sourceRoot":""}