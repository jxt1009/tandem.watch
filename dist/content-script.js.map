{"version":3,"file":"content-script.js","mappings":"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","sources":["webpack://tandem.watch/./chrome-extension/src/managers/sync/lock.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/eventListeners.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/SyncManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/peerConnection.js","webpack://tandem.watch/./chrome-extension/src/content/main.js","webpack://tandem.watch/./chrome-extension/src/managers/state/StateManager.js","webpack://tandem.watch/./chrome-extension/src/ui/UIManager.js","webpack://tandem.watch/./chrome-extension/src/content/netflix/NetflixController.js","webpack://tandem.watch/./chrome-extension/src/managers/sync/remoteHandlers.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/WebRTCManager.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/ui.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/reconnect.js","webpack://tandem.watch/./chrome-extension/src/services/webrtc/signaling.js","webpack://tandem.watch/./chrome-extension/src/managers/url/URLSync.js"],"sourcesContent":["export class SyncLock {\r\n  constructor() {\r\n    this.suppressLocalUntil = 0;\r\n  }\r\n  set(durationMs) {\r\n    this.suppressLocalUntil = Date.now() + durationMs;\r\n  }\r\n  isActive() {\r\n    return Date.now() < this.suppressLocalUntil;\r\n  }\r\n}\r\n","export function attachPlaybackListeners({ video, state, isInitializedRef, lock, onPlay, onPause, onSeek, onPositionUpdate }) {\r\n  const handlePlay = () => {\r\n    console.log('[EventListeners] Play event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring play - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring play - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring play - lock active'); return; }\r\n    console.log('[EventListeners] Play event detected - broadcasting');\r\n    onPlay(video);\r\n  };\r\n\r\n  const handlePause = () => {\r\n    console.log('[EventListeners] Pause event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring pause - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring pause - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring pause - lock active'); return; }\r\n    console.log('[EventListeners] Pause event detected - broadcasting');\r\n    onPause(video);\r\n  };\r\n\r\n  const handleSeeked = () => {\r\n    console.log('[EventListeners] Seek event fired - checking conditions:', {\r\n      isActive: state.isActive(),\r\n      isInitialized: isInitializedRef.get(),\r\n      lockActive: lock.isActive()\r\n    });\r\n    if (!state.isActive()) { console.log('[EventListeners] Ignoring seek - party not active'); return; }\r\n    if (!isInitializedRef.get()) { console.log('[EventListeners] Ignoring seek - not initialized'); return; }\r\n    if (lock.isActive()) { console.log('[EventListeners] Ignoring seek - lock active'); return; }\r\n    console.log('[EventListeners] Seek event detected - broadcasting');\r\n    onSeek(video);\r\n  };\r\n\r\n  // Continuous position tracking (every 500ms)\r\n  const positionUpdateInterval = setInterval(() => {\r\n    // Only send position updates from /watch pages\r\n    if (window.location.pathname.startsWith('/watch') && state.isActive() && isInitializedRef.get() && !lock.isActive() && onPositionUpdate) {\r\n      onPositionUpdate(video);\r\n    }\r\n  }, 500);\r\n\r\n  video.addEventListener('play', handlePlay);\r\n  video.addEventListener('pause', handlePause);\r\n  video.addEventListener('seeked', handleSeeked);\r\n  console.log('[EventListeners] Event listeners attached to video element');\r\n\r\n  // Return cleanup function along with listeners\r\n  return { \r\n    video, \r\n    handlePlay, \r\n    handlePause, \r\n    handleSeeked,\r\n    cleanup: () => clearInterval(positionUpdateInterval)\r\n  };\r\n}\r\n","import { SyncLock } from './lock.js';\r\nimport { attachPlaybackListeners } from './eventListeners.js';\r\nimport { createRemoteHandlers } from './remoteHandlers.js';\r\n\r\nclass MutableRef {\r\n  constructor(value) { this.value = value; }\r\n  get() { return this.value; }\r\n  set(v) { this.value = v; }\r\n}\r\n\r\nexport class SyncManager {\r\n  constructor(stateManager, netflixController) {\r\n    this.state = stateManager;\r\n    this.netflix = netflixController;\r\n    this.lock = new SyncLock();\r\n    this.isInitializedRef = new MutableRef(false);\r\n    this.listeners = null;\r\n    this.initialSyncRequestAt = 0;\r\n    this.initialSyncWindowMs = 8000;\r\n\r\n    this.remote = createRemoteHandlers({\r\n      state: this.state,\r\n      netflix: this.netflix,\r\n      lock: this.lock,\r\n      isInitializedRef: this.isInitializedRef,\r\n      shouldAcceptLateSync: () => {\r\n        if (!this.initialSyncRequestAt) return false;\r\n        return (Date.now() - this.initialSyncRequestAt) < this.initialSyncWindowMs;\r\n      },\r\n      onInitialSyncApplied: () => {\r\n        this.initialSyncRequestAt = 0;\r\n      }\r\n    });\r\n  }\r\n\r\n  async setup() {\r\n    try {\r\n      // Only setup sync manager on /watch pages\r\n      if (!window.location.pathname.startsWith('/watch')) {\r\n        console.log('[SyncManager] Not on /watch page, skipping setup');\r\n        return;\r\n      }\r\n      \r\n      console.log('[SyncManager] Starting setup - waiting for video element...');\r\n      const video = await this.waitForVideo();\r\n      if (!video) { \r\n        console.warn('[SyncManager] Netflix video element not found'); \r\n        return; \r\n      }\r\n      \r\n      console.log('[SyncManager] Video element found, setting up event listeners');\r\n      \r\n      // Check for pending sync from URL navigation\r\n      const pendingSyncStr = sessionStorage.getItem('tandem_pending_sync');\r\n      if (pendingSyncStr) {\r\n        try {\r\n          const pendingSync = JSON.parse(pendingSyncStr);\r\n          if (Date.now() - pendingSync.timestamp < 10000) {\r\n            console.log('[SyncManager] Applying pending sync from URL navigation');\r\n            sessionStorage.removeItem('tandem_pending_sync');\r\n            this.isInitializedRef.set(true);\r\n            this.initialSyncRequestAt = 0;\r\n            \r\n            // Apply the pending sync state\r\n            this.lock.set(1500);\r\n            await this.netflix.seek(pendingSync.currentTime * 1000);\r\n            const isPaused = await this.netflix.isPaused();\r\n            if (pendingSync.isPlaying && isPaused) {\r\n              await this.netflix.play();\r\n            } else if (!pendingSync.isPlaying && !isPaused) {\r\n              await this.netflix.pause();\r\n            }\r\n            \r\n            const listeners = attachPlaybackListeners({\r\n              video,\r\n              state: this.state,\r\n              isInitializedRef: this.isInitializedRef,\r\n              lock: this.lock,\r\n              onPlay: (vid) => this.broadcastPlay(vid),\r\n              onPause: (vid) => this.broadcastPause(vid),\r\n              onSeek: (vid) => this.broadcastSeek(vid),\r\n              onPositionUpdate: (vid) => this.broadcastPosition(vid)\r\n            });\r\n            this.listeners = listeners;\r\n            console.log('[SyncManager] Setup complete with pending sync applied');\r\n            return;\r\n          } else {\r\n            console.log('[SyncManager] Pending sync expired, ignoring');\r\n            sessionStorage.removeItem('tandem_pending_sync');\r\n          }\r\n        } catch (e) {\r\n          console.error('[SyncManager] Error applying pending sync:', e);\r\n          sessionStorage.removeItem('tandem_pending_sync');\r\n        }\r\n      }\r\n      \r\n      this.isInitializedRef.set(false);\r\n      \r\n      // Check if we just navigated from browse - if so, respect Netflix's natural behavior\r\n      // and become the leader that others sync to\r\n      const fromBrowse = sessionStorage.getItem('tandem_from_browse');\r\n      if (fromBrowse === 'true') {\r\n        console.log('[SyncManager] Just navigated from browse - becoming leader, will broadcast state once video is ready');\r\n        sessionStorage.removeItem('tandem_from_browse');\r\n        // Mark as initialized immediately so we start broadcasting our state\r\n        this.isInitializedRef.set(true);\r\n        this.initialSyncRequestAt = 0;\r\n        \r\n        // Wait for Netflix resume event before broadcasting state\r\n        const broadcastAfterResume = () => {\r\n          let resumed = false;\r\n          let timeoutId = null;\r\n          \r\n          const broadcast = async (source) => {\r\n            if (resumed) return;\r\n            resumed = true;\r\n            \r\n            // Clean up listeners\r\n            video.removeEventListener('seeked', onSeeked);\r\n            video.removeEventListener('timeupdate', onTimeUpdate);\r\n            if (timeoutId) clearTimeout(timeoutId);\r\n            \r\n            try {\r\n              const currentTime = await this.netflix.getCurrentTime();\r\n              const isPaused = await this.netflix.isPaused();\r\n              const currentTimeSeconds = currentTime != null ? currentTime / 1000 : 0;\r\n              console.log('[SyncManager] Broadcasting initial state as leader from', source + ':', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing');\r\n              \r\n              this.state.safeSendMessage({ \r\n                type: 'PLAY_PAUSE', \r\n                control: isPaused ? 'pause' : 'play'\r\n              });\r\n            } catch (e) {\r\n              console.error('[SyncManager] Error broadcasting leader state:', e);\r\n            }\r\n          };\r\n          \r\n          // Listen for seeked event (Netflix resuming to saved position)\r\n          const onSeeked = async () => {\r\n            const currentTime = await this.netflix.getCurrentTime();\r\n            if (currentTime != null && currentTime > 5000) {\r\n              console.log('[SyncManager] Detected resume via seeked event at', (currentTime / 1000).toFixed(2) + 's');\r\n              broadcast('seeked');\r\n            }\r\n          };\r\n          \r\n          // Listen for timeupdate as fallback\r\n          const onTimeUpdate = async () => {\r\n            const currentTime = await this.netflix.getCurrentTime();\r\n            if (currentTime != null && currentTime > 5000) {\r\n              console.log('[SyncManager] Detected resume via timeupdate at', (currentTime / 1000).toFixed(2) + 's');\r\n              broadcast('timeupdate');\r\n            }\r\n          };\r\n          \r\n          video.addEventListener('seeked', onSeeked);\r\n          video.addEventListener('timeupdate', onTimeUpdate);\r\n          \r\n          // Fallback timeout (8 seconds)\r\n          timeoutId = setTimeout(() => {\r\n            console.log('[SyncManager] Resume timeout reached, broadcasting current state');\r\n            broadcast('timeout');\r\n          }, 8000);\r\n          \r\n          // Check immediately if already at resume position\r\n          this.netflix.getCurrentTime().then(currentTime => {\r\n            if (currentTime != null && currentTime > 5000) {\r\n              console.log('[SyncManager] Already at resume position:', (currentTime / 1000).toFixed(2) + 's');\r\n              broadcast('immediate');\r\n            }\r\n          });\r\n        };\r\n        \r\n        // Start waiting for resume\r\n        if (video.readyState >= 3) {\r\n          console.log('[SyncManager] Video ready, waiting for Netflix resume event');\r\n          broadcastAfterResume();\r\n        } else {\r\n          console.log('[SyncManager] Waiting for video ready before resume detection');\r\n          const onVideoReady = () => {\r\n            video.removeEventListener('canplay', onVideoReady);\r\n            console.log('[SyncManager] Video ready, waiting for Netflix resume event');\r\n            broadcastAfterResume();\r\n          };\r\n          video.addEventListener('canplay', onVideoReady);\r\n          setTimeout(() => {\r\n            video.removeEventListener('canplay', onVideoReady);\r\n            console.log('[SyncManager] Video ready timeout, starting resume detection anyway');\r\n            broadcastAfterResume();\r\n          }, 3000);\r\n        }\r\n      } else {\r\n        // Wait for video to be ready before requesting sync\r\n        const requestSyncWhenReady = () => {\r\n          console.log('[SyncManager] Video ready - requesting initial sync from other clients');\r\n          this.initialSyncRequestAt = Date.now();\r\n          this.state.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n          \r\n          // If no response after 2 seconds, consider ourselves initialized\r\n          setTimeout(() => {\r\n            if (!this.isInitializedRef.get()) {\r\n              console.log('[SyncManager] No sync response received after 2s, marking as initialized (will still accept late sync briefly)');\r\n              this.isInitializedRef.set(true);\r\n              console.log('[SyncManager] isInitialized is now:', this.isInitializedRef.get());\r\n            } else {\r\n              console.log('[SyncManager] Already initialized, skipping timeout initialization');\r\n            }\r\n          }, 2000);\r\n        };\r\n        \r\n        const onVideoReady = () => {\r\n          console.log('[SyncManager] Video canplay event fired');\r\n          video.removeEventListener('canplay', onVideoReady);\r\n          requestSyncWhenReady();\r\n        };\r\n        \r\n        // If video is already ready, request sync immediately\r\n        if (video.readyState >= 3) { // HAVE_FUTURE_DATA or better\r\n          console.log('[SyncManager] Video already ready (readyState:', video.readyState + ')');\r\n          requestSyncWhenReady();\r\n        } else {\r\n          console.log('[SyncManager] Waiting for video to be ready before requesting sync (readyState:', video.readyState + ')');\r\n          video.addEventListener('canplay', onVideoReady);\r\n          // Fallback timeout\r\n          setTimeout(() => {\r\n            video.removeEventListener('canplay', onVideoReady);\r\n            console.log('[SyncManager] Timeout reached, requesting sync anyway');\r\n            requestSyncWhenReady();\r\n          }, 5000);\r\n        }\r\n      }\r\n      \r\n      // Clean up old listeners first (in case of re-setup)\r\n      if (this.listeners && this.listeners.cleanup) {\r\n        try {\r\n          this.listeners.cleanup();\r\n          console.log('[SyncManager] Cleaned up old listeners before attaching new ones');\r\n        } catch (e) {\r\n          console.warn('[SyncManager] Error cleaning up old listeners:', e);\r\n        }\r\n      }\r\n\r\n      const listeners = attachPlaybackListeners({\r\n        video,\r\n        state: this.state,\r\n        isInitializedRef: this.isInitializedRef,\r\n        lock: this.lock,\r\n        onPlay: (vid) => this.broadcastPlay(vid),\r\n        onPause: (vid) => this.broadcastPause(vid),\r\n        onSeek: (vid) => this.broadcastSeek(vid),\r\n        onPositionUpdate: (vid) => this.broadcastPosition(vid)\r\n      });\r\n      this.listeners = listeners;\r\n      console.log('[SyncManager] Setup complete - ready to sync');\r\n    } catch (err) { \r\n      console.error('[SyncManager] Error setting up playback sync:', err); \r\n    }\r\n  }\r\n\r\n  teardown() {\r\n    console.log('[SyncManager] Tearing down sync manager');\r\n    if (this.listeners) {\r\n      const { video, handlePlay, handlePause, handleSeeked, cleanup } = this.listeners;\r\n      try {\r\n        video.removeEventListener('play', handlePlay);\r\n        video.removeEventListener('pause', handlePause);\r\n        video.removeEventListener('seeked', handleSeeked);\r\n        if (cleanup) cleanup(); // Clear the position update interval\r\n        console.log('[SyncManager] Event listeners removed');\r\n      } catch (e) { console.warn('[SyncManager] Error removing listeners:', e); }\r\n      this.listeners = null;\r\n    }\r\n    this.isInitializedRef.set(false);\r\n  }\r\n\r\n  waitForVideo() {\r\n    return new Promise((resolve, reject) => {\r\n      const timeout = setTimeout(() => reject(new Error('Video element timeout')), 10000);\r\n      const check = () => {\r\n        const video = this.netflix.getVideoElement();\r\n        if (video) { clearTimeout(timeout); resolve(video); }\r\n        else { setTimeout(check, 100); }\r\n      };\r\n      check();\r\n    });\r\n  }\r\n\r\n  isOnWatchPage() {\r\n    return window.location.pathname.startsWith('/watch');\r\n  }\r\n\r\n  broadcastPlay(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PLAY event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PLAY event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'play'\r\n    });\r\n  }\r\n\r\n  broadcastPause(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring PAUSE event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting PAUSE event');\r\n    this.state.safeSendMessage({ \r\n      type: 'PLAY_PAUSE', \r\n      control: 'pause'\r\n    });\r\n  }\r\n\r\n  broadcastSeek(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring SEEK event - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[SyncManager] Broadcasting SEEK event at', video.currentTime);\r\n    this.state.safeSendMessage({ \r\n      type: 'SEEK', \r\n      currentTime: video.currentTime, \r\n      isPlaying: !video.paused \r\n    });\r\n  }\r\n\r\n  broadcastPosition(video) {\r\n    if (!this.isOnWatchPage()) {\r\n      return;\r\n    }\r\n    // Send continuous position update for live timestamp tracking\r\n    this.state.safeSendMessage({ \r\n      type: 'POSITION_UPDATE', \r\n      currentTime: video.currentTime, \r\n      isPlaying: !video.paused \r\n    });\r\n  }\r\n\r\n  // Remote event handlers\r\n  handleRequestSync(fromUserId, respectAutoPlay) { return this.remote.handleRequestSync(fromUserId, respectAutoPlay); }\r\n  handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay) {\r\n    // Only handle sync responses on /watch pages to avoid preview videos interfering\r\n    if (!this.isOnWatchPage()) {\r\n      console.log('[SyncManager] Ignoring sync response - not on /watch page');\r\n      return;\r\n    }\r\n    return this.remote.handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay);\r\n  }\r\n  handlePlaybackControl(control, currentTime, fromUserId) { return this.remote.handlePlaybackControl(control, currentTime, fromUserId); }\r\n  handleSeek(currentTime, isPlaying, fromUserId) { return this.remote.handleSeek(currentTime, isPlaying, fromUserId); }\r\n}\r\n","export function createPeerConnectionFactory({ stateManager, sendSignal, remoteStreams, remoteVideos, addRemoteVideo, attemptReconnection, clearReconnection, removeRemoteVideo, peersThatLeft, showReconnecting, hideOverlay, showPlaceholder }) {\r\n  return function createPeerConnection(peerId) {\r\n    console.log('[PeerConnection] Creating peer connection for peerId:', peerId);\r\n    \r\n    // Ensure any existing video/container AND stream is removed before creating placeholder\r\n    // This prevents duplicates when rapidly recreating connections (like force refresh)\r\n    removeRemoteVideo(peerId);\r\n    remoteStreams.delete(peerId); // Also clear the stream\r\n    \r\n    // Show placeholder immediately when peer connection is created\r\n    showPlaceholder(peerId);\r\n    \r\n    const state = stateManager.getState();\r\n    const pc = new RTCPeerConnection({\r\n      iceServers: [\r\n        { urls: ['stun:stun.l.google.com:19302'] },\r\n        { urls: ['stun:stun1.l.google.com:19302'] }\r\n      ]\r\n    });\r\n    pc.onicecandidate = (event) => {\r\n      if (event.candidate) {\r\n        console.log('[PeerConnection] ICE candidate for peer:', peerId, event.candidate);\r\n        sendSignal({ type: 'ICE_CANDIDATE', from: state.userId, to: peerId, candidate: event.candidate });\r\n      }\r\n    };\r\n    pc.ontrack = (event) => {\r\n      console.log('[PeerConnection] ontrack fired for peer:', peerId, 'track:', event.track, 'streams:', event.streams);\r\n      let stream = (event.streams && event.streams[0]) || remoteStreams.get(peerId);\r\n      if (!stream) {\r\n        console.log('[PeerConnection] Creating new MediaStream for peer:', peerId);\r\n        stream = new MediaStream();\r\n        remoteStreams.set(peerId, stream);\r\n      }\r\n      if (event.track) {\r\n        console.log('[PeerConnection] Adding track to stream:', event.track.kind, event.track.id);\r\n        try { \r\n          // Check if track already exists in stream to prevent duplicates\r\n          const existingTrack = stream.getTracks().find(t => t.id === event.track.id);\r\n          if (!existingTrack) {\r\n            stream.addTrack(event.track);\r\n          } else {\r\n            console.log('[PeerConnection] Track already in stream, skipping');\r\n          }\r\n        } catch (e) {\r\n          console.warn('[PeerConnection] Error adding track:', e);\r\n        }\r\n      }\r\n      \r\n      // Check if video element exists\r\n      const hasVideoInMap = remoteVideos.has(peerId);\r\n      const hasVideoInDom = !!document.getElementById('tandem-remote-' + peerId);\r\n      const videoExists = hasVideoInMap || hasVideoInDom;\r\n      \r\n      if (videoExists) {\r\n        console.log('[PeerConnection] Video already exists for peer:', peerId, 'inMap:', hasVideoInMap, 'inDom:', hasVideoInDom);\r\n        // Update the existing video element's stream if it's different\r\n        const existingVideo = remoteVideos.get(peerId) || document.getElementById('tandem-remote-' + peerId);\r\n        if (existingVideo && existingVideo.srcObject !== stream) {\r\n          console.log('[PeerConnection] Updating existing video element with new stream');\r\n          existingVideo.srcObject = stream;\r\n          // Ensure it's tracked in the map\r\n          if (!hasVideoInMap) {\r\n            remoteVideos.set(peerId, existingVideo);\r\n          }\r\n        }\r\n      } else {\r\n        // Wait for both audio and video tracks before creating video element\r\n        const tracks = stream.getTracks();\r\n        const hasAudio = tracks.some(t => t.kind === 'audio');\r\n        const hasVideo = tracks.some(t => t.kind === 'video');\r\n        \r\n        console.log('[PeerConnection] Stream status - audio:', hasAudio, 'video:', hasVideo, 'total tracks:', tracks.length);\r\n        \r\n        // Only create video element when we have both tracks\r\n        if (hasAudio && hasVideo) {\r\n          console.log('[PeerConnection] Both tracks present, adding remote video for peer:', peerId);\r\n          addRemoteVideo(peerId, stream);\r\n        } else {\r\n          console.log('[PeerConnection] Waiting for more tracks before creating video element');\r\n        }\r\n      }\r\n    };\r\n    pc.onconnectionstatechange = () => {\r\n      console.log('[PeerConnection] Connection state changed for peer:', peerId, '', pc.connectionState);\r\n      if (pc.connectionState === 'connected') {\r\n        clearReconnection(peerId);\r\n        hideOverlay(peerId);\r\n      } else if (pc.connectionState === 'disconnected') {\r\n        if (peersThatLeft.has(peerId)) {\r\n          removeRemoteVideo(peerId);\r\n          clearReconnection(peerId);\r\n        } else {\r\n          // Keep video visible while reconnecting - don't remove immediately\r\n          console.log('[PeerConnection] Connection disconnected, attempting reconnection while keeping video visible');\r\n          showReconnecting(peerId);\r\n          attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'failed') {\r\n        console.log('[PeerConnection] Connection failed for peer:', peerId);\r\n        if (peersThatLeft.has(peerId)) {\r\n          removeRemoteVideo(peerId);\r\n          clearReconnection(peerId);\r\n        } else {\r\n          // Remove video on failed state and try to reconnect\r\n          removeRemoteVideo(peerId);\r\n          attemptReconnection(peerId);\r\n        }\r\n      } else if (pc.connectionState === 'closed') {\r\n        removeRemoteVideo(peerId);\r\n        clearReconnection(peerId);\r\n      }\r\n    };\r\n    return pc;\r\n  };\r\n}\r\n\r\nexport function addOrReplaceTrack(pc, track, stream) {\r\n  const senders = pc.getSenders();\r\n  const existingSender = senders.find(s => s.track && s.track.kind === track.kind);\r\n  if (existingSender) {\r\n    existingSender.replaceTrack(track).catch(e => console.warn('[WebRTCManager] Error replacing track', e));\r\n  } else {\r\n    try { pc.addTrack(track, stream); } catch (e) {}\r\n  }\r\n}\r\n","import { StateManager } from '../managers/state/StateManager.js';\r\nimport { NetflixController } from './netflix/NetflixController.js';\r\nimport { SyncManager } from '../managers/sync/SyncManager.js';\r\nimport { WebRTCManager } from '../services/webrtc/WebRTCManager.js';\r\nimport { UIManager } from '../ui/UIManager.js';\r\nimport { URLSync } from '../managers/url/URLSync.js';\r\n\r\nconsole.log('[Content Script] Initializing managers...');\r\n\r\n// Don't clean up stale elements on navigation - they should persist\r\n// Only clean up if party is not active\r\nconst wasPartyActive = sessionStorage.getItem('tandem_was_active') === 'true';\r\nif (!wasPartyActive) {\r\n  console.log('[Content Script] No active party detected, cleaning up stale elements...');\r\n  const staleContainers = document.querySelectorAll('[id^=\"tandem-container-\"]');\r\n  const staleVideos = document.querySelectorAll('[id^=\"tandem-remote-\"]');\r\n  const staleOverlays = document.querySelectorAll('[id^=\"tandem-overlay-\"]');\r\n  const staleLocalVideo = document.getElementById('tandem-local-preview');\r\n  const staleWaitingIndicator = document.getElementById('tandem-waiting-indicator');\r\n\r\n  staleContainers.forEach(el => {\r\n    console.log('[Content Script] Removing stale container:', el.id);\r\n    el.remove();\r\n  });\r\n  staleVideos.forEach(el => {\r\n    console.log('[Content Script] Removing stale video:', el.id);\r\n    el.remove();\r\n  });\r\n  staleOverlays.forEach(el => {\r\n    console.log('[Content Script] Removing stale overlay:', el.id);\r\n    el.remove();\r\n  });\r\n  if (staleLocalVideo) {\r\n    console.log('[Content Script] Removing stale local video');\r\n    staleLocalVideo.remove();\r\n  }\r\n  if (staleWaitingIndicator) {\r\n    console.log('[Content Script] Removing stale waiting indicator');\r\n    staleWaitingIndicator.remove();\r\n  }\r\n} else {\r\n  console.log('[Content Script] Party is active, keeping existing video elements');\r\n}\r\n\r\nconst stateManager = new StateManager();\r\nconst uiManager = new UIManager();\r\nconst netflixController = new NetflixController();\r\nconst syncManager = new SyncManager(stateManager, netflixController);\r\nconst webrtcManager = new WebRTCManager(stateManager, uiManager);\r\n\r\n// Callback when we navigate to a different /watch page\r\nconst handleWatchPageChange = () => {\r\n  console.log('[Content Script] Watch page changed - reinitializing sync manager');\r\n  const state = stateManager.getState();\r\n  if (state.partyActive) {\r\n    console.log('[Content Script] Party is active, reinitializing sync manager');\r\n    syncManager.teardown();\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to reinitialize sync manager:', err);\r\n    });\r\n  } else {\r\n    console.log('[Content Script] Party not active, skipping sync manager reinitialization');\r\n  }\r\n};\r\n\r\n// Also initialize sync manager when navigating TO a watch page (not just between watch pages)\r\nconst handleNavigationToWatch = () => {\r\n  console.log('[Content Script] Navigated to /watch page');\r\n  const state = stateManager.getState();\r\n  if (state.partyActive) {\r\n    console.log('[Content Script] Party is active, initializing sync manager');\r\n    syncManager.teardown();\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to initialize sync manager:', err);\r\n    });\r\n  }\r\n};\r\n\r\n// Teardown sync manager when leaving a watch page\r\nconst handleLeaveWatch = () => {\r\n  console.log('[Content Script] Left /watch page');\r\n  syncManager.teardown();\r\n};\r\n\r\nconst urlSync = new URLSync(stateManager, handleWatchPageChange, handleNavigationToWatch, handleLeaveWatch);\r\nconsole.log('[Content Script] Managers initialized');\r\n\r\nfunction checkJoinFromLink() {\r\n  const state = stateManager.getState();\r\n  if (state.partyActive) {\r\n    return;\r\n  }\r\n\r\n  try {\r\n    const url = new URL(window.location.href);\r\n    const roomId = url.searchParams.get('tandemRoom');\r\n    if (!roomId) {\r\n      return;\r\n    }\r\n\r\n    console.log('[Content Script] Found tandemRoom in URL, joining room:', roomId);\r\n\r\n    // Clean the URL so it doesn't keep re-triggering\r\n    url.searchParams.delete('tandemRoom');\r\n    history.replaceState({}, document.title, url.toString());\r\n\r\n    chrome.runtime.sendMessage({ type: 'START_PARTY', roomId }, (response) => {\r\n      if (response && response.success) {\r\n        console.log('[Content Script] Joined party from link successfully');\r\n      } else {\r\n        console.error('[Content Script] Failed to join party from link:', response ? response.error : 'Unknown error');\r\n      }\r\n    });\r\n  } catch (e) {\r\n    console.error('[Content Script] Failed to process tandemRoom in URL:', e);\r\n  }\r\n}\r\n\r\nlet localStream = null;\r\nlet videoElementMonitor = null;\r\n\r\n// If party was active before this page load, try to restore videos immediately\r\nif (wasPartyActive) {\r\n  console.log('[Content Script] Party was active, checking for restoration state...');\r\n  setTimeout(() => {\r\n    // Give the page a moment to initialize\r\n    const state = stateManager.getState();\r\n    if (state.partyActive && localStream) {\r\n      console.log('[Content Script] Restoring local preview video after navigation');\r\n      const existingPreview = document.getElementById('tandem-local-preview');\r\n      if (!existingPreview) {\r\n        uiManager.attachLocalPreview(localStream);\r\n      }\r\n    }\r\n  }, 100);\r\n}\r\n\r\n// Monitor and restore video elements if they get removed during navigation\r\nfunction startVideoElementMonitoring() {\r\n  if (videoElementMonitor) return;\r\n  \r\n  videoElementMonitor = setInterval(() => {\r\n    const state = stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    \r\n    // Check if local preview exists\r\n    if (localStream && !document.getElementById('tandem-local-preview')) {\r\n      console.log('[Content Script] Local preview missing, re-attaching');\r\n      uiManager.attachLocalPreview(localStream);\r\n    }\r\n    \r\n    // Check if remote videos exist\r\n    const remoteVideos = uiManager.getRemoteVideos();\r\n    const remoteStreams = uiManager.getRemoteStreams();\r\n    remoteStreams.forEach((stream, peerId) => {\r\n      const videoId = 'tandem-remote-' + peerId;\r\n      if (!document.getElementById(videoId)) {\r\n        console.log('[Content Script] Remote video missing for peer:', peerId, 're-adding');\r\n        const videoManager = webrtcManager.videoManager;\r\n        if (videoManager && videoManager.add) {\r\n          videoManager.add(peerId, stream);\r\n        }\r\n      }\r\n    });\r\n  }, 250); // Check every 250ms for faster restoration\r\n  \r\n  console.log('[Content Script] Started video element monitoring');\r\n}\r\n\r\nfunction stopVideoElementMonitoring() {\r\n  if (videoElementMonitor) {\r\n    clearInterval(videoElementMonitor);\r\n    videoElementMonitor = null;\r\n    console.log('[Content Script] Stopped video element monitoring');\r\n  }\r\n}\r\n\r\ncheckJoinFromLink();\r\n\r\n(function checkRestorePartyState() {\r\n  const restorationState = urlSync.getRestorationState();\r\n  if (restorationState) {\r\n    console.log('[Content Script] Restoring party state for room:', restorationState.roomId);\r\n    urlSync.clearState();\r\n    stateManager.setRestoringFlag(true);\r\n    \r\n    setTimeout(function() {\r\n      console.log('[Content Script] Sending RESTORE_PARTY message');\r\n      chrome.runtime.sendMessage({ type: 'RESTORE_PARTY', roomId: restorationState.roomId }, (response) => {\r\n        if (response && response.success) {\r\n          console.log('[Content Script] Party restoration successful - setting state with userId:', response.userId);\r\n          // Immediately set the userId and roomId so we can handle incoming messages\r\n          stateManager.startParty(response.userId, response.roomId);\r\n          \r\n          // Re-obtain media stream for WebRTC signaling\r\n          console.log('[Content Script] Re-obtaining media stream after navigation');\r\n          navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n            .then(stream => {\r\n              console.log('[Content Script] Media stream obtained after restoration');\r\n              localStream = stream;\r\n              webrtcManager.setLocalStream(stream);\r\n              webrtcManager.onLocalStreamAvailable(stream);\r\n              uiManager.attachLocalPreview(stream);\r\n              \r\n              // Re-setup sync manager\r\n              syncManager.teardown();\r\n              syncManager.setup().catch(err => {\r\n                console.error('[Content Script] Failed to setup sync manager after restoration:', err);\r\n              });\r\n              \r\n              // Start URL monitoring if not already started\r\n              urlSync.start();\r\n              startVideoElementMonitoring();\r\n            })\r\n            .catch(err => {\r\n              console.error('[Content Script] Failed to get media stream after restoration:', err);\r\n            });\r\n        } else {\r\n          console.error('[Content Script] Party restoration failed:', response ? response.error : 'Unknown error');\r\n        }\r\n        setTimeout(function() {\r\n          stateManager.setRestoringFlag(false);\r\n        }, 2000);\r\n      });\r\n    }, 1000);\r\n  }\r\n})();\r\n\r\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\r\n  console.log('[Content Script] Received message:', request.type);\r\n  if (request.type === 'GET_MEDIA_STATE') {\r\n    const audioTrack = localStream ? localStream.getAudioTracks()[0] : null;\r\n    const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;\r\n    sendResponse({\r\n      success: true,\r\n      state: {\r\n        audioEnabled: audioTrack ? audioTrack.enabled : false,\r\n        videoEnabled: videoTrack ? videoTrack.enabled : false,\r\n        hasStream: !!localStream,\r\n      },\r\n    });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'TOGGLE_MIC') {\r\n    if (!localStream) {\r\n      sendResponse({ success: false, error: 'No local stream' });\r\n      return true;\r\n    }\r\n    const tracks = localStream.getAudioTracks();\r\n    if (!tracks.length) {\r\n      sendResponse({ success: false, error: 'No audio track' });\r\n      return true;\r\n    }\r\n    const newEnabled = !tracks[0].enabled;\r\n    tracks.forEach(t => { t.enabled = newEnabled; });\r\n    sendResponse({\r\n      success: true,\r\n      state: {\r\n        audioEnabled: newEnabled,\r\n        videoEnabled: localStream.getVideoTracks()[0]?.enabled ?? false,\r\n        hasStream: true,\r\n      },\r\n    });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'TOGGLE_CAMERA') {\r\n    if (!localStream) {\r\n      sendResponse({ success: false, error: 'No local stream' });\r\n      return true;\r\n    }\r\n    const tracks = localStream.getVideoTracks();\r\n    if (!tracks.length) {\r\n      sendResponse({ success: false, error: 'No video track' });\r\n      return true;\r\n    }\r\n    const newEnabled = !tracks[0].enabled;\r\n    tracks.forEach(t => { t.enabled = newEnabled; });\r\n    sendResponse({\r\n      success: true,\r\n      state: {\r\n        audioEnabled: localStream.getAudioTracks()[0]?.enabled ?? false,\r\n        videoEnabled: newEnabled,\r\n        hasStream: true,\r\n      },\r\n    });\r\n    return true;\r\n  }\r\n  if (request.type === 'REQUEST_MEDIA_STREAM') {\r\n    console.log('[Content Script] Processing REQUEST_MEDIA_STREAM');\r\n    navigator.mediaDevices.getUserMedia({ video: true, audio: true })\r\n      .then(stream => {\r\n        console.log('[Content Script] Media stream obtained, tracks:', stream.getTracks().length);\r\n        localStream = stream;\r\n        console.log('[Content Script] Setting local stream on WebRTC manager');\r\n        webrtcManager.setLocalStream(stream);\r\n        webrtcManager.onLocalStreamAvailable(stream);\r\n        console.log('[Content Script] Attaching local preview to UI');\r\n        uiManager.attachLocalPreview(stream);\r\n        console.log('[Content Script] Local preview attached, sending success response');\r\n        sendResponse({ success: true });\r\n      })\r\n      .catch(err => {\r\n        console.error('[Content Script] Failed to get media stream:', err);\r\n        sendResponse({ success: false, error: err.message });\r\n      });\r\n    return true;\r\n  }\r\n\r\n  if (request.type === 'PARTY_STARTED') {\r\n    console.log('[Content Script] Party started:', request.userId, request.roomId);\r\n    stateManager.startParty(request.userId, request.roomId);\r\n    \r\n    // Show simple connection indicator\r\n    uiManager.showConnectionIndicator();\r\n    \r\n    // Set Netflix volume to 15%\r\n    setTimeout(() => {\r\n      netflixController.setVolume(0.15).then(() => {\r\n        console.log('[Content Script] Set Netflix volume to 15%');\r\n      }).catch(err => {\r\n        console.warn('[Content Script] Failed to set volume:', err);\r\n      });\r\n    }, 1000);\r\n    \r\n    // Teardown existing sync manager if already set up\r\n    syncManager.teardown();\r\n    \r\n    // Setup sync manager (will wait for video element)\r\n    syncManager.setup().catch(err => {\r\n      console.error('[Content Script] Failed to setup sync manager:', err);\r\n    });\r\n    \r\n    urlSync.start();\r\n    startVideoElementMonitoring();\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'PARTY_STOPPED') {\r\n    console.log('[Content Script] Stopping party');\r\n    stopVideoElementMonitoring();\r\n    stateManager.stopParty();\r\n    syncManager.teardown();\r\n    urlSync.stop();\r\n    urlSync.clearState();\r\n    webrtcManager.clearAll();\r\n    uiManager.removeLocalPreview();\r\n    uiManager.removeConnectionIndicator();\r\n    if (localStream) {\r\n      localStream.getTracks().forEach(t => t.stop());\r\n      localStream = null;\r\n    }\r\n    sendResponse({ success: true });\r\n  }\r\n\r\n  if (request.type === 'SIGNAL') {\r\n    console.log('[Content Script] Handling SIGNAL:', request.message?.type);\r\n    webrtcManager.handleSignal(request.message);\r\n  }\r\n\r\n  if (request.type === 'APPLY_PLAYBACK_CONTROL') {\r\n    // Only apply playback controls if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring playback control - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[Content Script] Applying playback control:', request.control, 'at', request.currentTime, 'from', request.fromUserId);\r\n    syncManager.handlePlaybackControl(request.control, request.currentTime, request.fromUserId);\r\n  }\r\n\r\n  // Passive sync removed - using event-based sync only\r\n\r\n  if (request.type === 'APPLY_SEEK') {\r\n    // Only apply seek if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring seek - not on /watch page');\r\n      return;\r\n    }\r\n    syncManager.handleSeek(request.currentTime, request.isPlaying, request.fromUserId);\r\n  }\r\n\r\n  if (request.type === 'APPLY_URL_CHANGE') {\r\n    console.log('[Content Script] Received URL change request:', request.url, 'from', request.fromUserId);\r\n    \r\n    if (stateManager.restoringPartyState) {\r\n      console.log('[Content Script] Ignoring URL change - currently restoring party state');\r\n      return;\r\n    }\r\n    \r\n    // Apply URL changes to all Netflix pages (browse, title, watch, etc.)\r\n    const incomingUrl = new URL(request.url);\r\n    const currentUrl = window.location.href;\r\n    \r\n    // Don't navigate if we're already on this URL\r\n    if (currentUrl === request.url) {\r\n      console.log('[Content Script] Already on this URL, skipping navigation');\r\n      return;\r\n    }\r\n    \r\n    console.log('[Content Script] Navigating to:', request.url, 'using SPA navigation');\r\n    // Save state before navigating (for restoration if on /watch page)\r\n    const currentPath = window.location.pathname;\r\n    if (currentPath.startsWith('/watch')) {\r\n      urlSync.saveState();\r\n    }\r\n    \r\n    // Use history.pushState to navigate without full page reload (Netflix SPA style)\r\n    try {\r\n      window.history.pushState({}, '', request.url);\r\n      \r\n      // Trigger popstate event to let Netflix's router handle the navigation\r\n      window.dispatchEvent(new PopStateEvent('popstate', { state: {} }));\r\n      \r\n      console.log('[Content Script] SPA navigation triggered');\r\n    } catch (e) {\r\n      console.error('[Content Script] Failed to navigate via pushState, falling back to full reload:', e);\r\n      window.location.href = request.url;\r\n    }\r\n  }\r\n\r\n  if (request.type === 'HANDLE_REQUEST_SYNC') {\r\n    // Only handle sync requests if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring sync request - not on /watch page');\r\n      return;\r\n    }\r\n    syncManager.handleRequestSync(request.fromUserId, request.respectAutoPlay);\r\n  }\r\n\r\n  if (request.type === 'APPLY_SYNC_RESPONSE') {\r\n    // Only apply sync response if we're on a /watch page\r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      console.log('[Content Script] Ignoring sync response - not on /watch page');\r\n      return;\r\n    }\r\n    console.log('[Content Script] Applying sync response from', request.fromUserId, 'URL:', request.url, request.respectAutoPlay ? '(respecting auto-play)' : '');\r\n    syncManager.handleSyncResponse(request.currentTime, request.isPlaying, request.fromUserId, request.url, request.respectAutoPlay);\r\n  }\r\n\r\n  if (request.type === 'REQUEST_INITIAL_SYNC_AND_PLAY') {\r\n    console.log('[Content Script] Requesting initial sync and will auto-play when synced');\r\n    // Request sync from other clients\r\n    stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n  }\r\n\r\n  if (request.type === 'CONNECTION_STATUS') {\r\n    console.log('[Content Script] Connection status changed:', request.status);\r\n    uiManager.updateConnectionIndicator(request.status);\r\n  }\r\n\r\n  if (request.type === 'RECONNECTED') {\r\n    console.log('[Content Script] WebSocket reconnected, userId:', request.userId);\r\n  }\r\n\r\n  if (request.type === 'REQUEST_SYNC_AFTER_RECONNECT') {\r\n    // Only request sync if we're on a /watch page and party is active\r\n    if (window.location.pathname.startsWith('/watch') && stateManager.isActive()) {\r\n      console.log('[Content Script] Requesting sync after reconnection');\r\n      stateManager.safeSendMessage({ type: 'REQUEST_SYNC' });\r\n    }\r\n  }\r\n});\r\n\r\nwindow.addEventListener('beforeunload', () => {\r\n  if (stateManager.isActive()) {\r\n    urlSync.saveState();\r\n  }\r\n});\r\n","export class StateManager {\r\n  constructor() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    this.restoringPartyState = false;\r\n  }\r\n  startParty(userId, roomId) {\r\n    this.partyActive = true;\r\n    this.userId = userId;\r\n    this.roomId = roomId;\r\n    // Set flag so videos persist across navigation\r\n    sessionStorage.setItem('tandem_was_active', 'true');\r\n  }\r\n  stopParty() {\r\n    this.partyActive = false;\r\n    this.userId = null;\r\n    this.roomId = null;\r\n    // Clear flag so videos are cleaned up\r\n    sessionStorage.removeItem('tandem_was_active');\r\n  }\r\n  isActive() { return this.partyActive; }\r\n  getUserId() { return this.userId; }\r\n  getRoomId() { return this.roomId; }\r\n  getState() {\r\n    return { partyActive: this.partyActive, userId: this.userId, roomId: this.roomId, restoringPartyState: this.restoringPartyState };\r\n  }\r\n  isInParty() { return !!(this.partyActive && this.userId && this.roomId); }\r\n  setRestoringFlag(value) { this.restoringPartyState = value; }\r\n  isExtensionContextValid() {\r\n    try { return chrome.runtime && chrome.runtime.id; } catch { return false; }\r\n  }\r\n  safeSendMessage(message, callback) {\r\n    if (!this.isExtensionContextValid()) {\r\n      console.warn('[StateManager] Extension context invalid - page needs reload after extension update');\r\n      // Show user notification that they need to reload\r\n      if (!document.getElementById('tandem-reload-notice')) {\r\n        const notice = document.createElement('div');\r\n        notice.id = 'tandem-reload-notice';\r\n        notice.style.cssText = 'position:fixed;top:20px;right:20px;background:#e50914;color:white;padding:15px;border-radius:8px;z-index:99999;font-family:Arial;box-shadow:0 4px 6px rgba(0,0,0,0.3);';\r\n        notice.innerHTML = '<strong>tandem.watch:</strong> Extension updated. Please reload this page.';\r\n        document.body.appendChild(notice);\r\n      }\r\n      return;\r\n    }\r\n    console.log('[StateManager] Sending message:', message.type, message);\r\n    try { \r\n      chrome.runtime.sendMessage(message, (response) => {\r\n        if (chrome.runtime.lastError) {\r\n          console.error('[StateManager] Error sending message:', message.type, chrome.runtime.lastError.message);\r\n        } else {\r\n          console.log('[StateManager] Message sent successfully:', message.type, response);\r\n        }\r\n        if (callback) callback(response);\r\n      }); \r\n    } catch (e) { \r\n      console.error('[StateManager] Exception sending message:', message.type, e.message, e); \r\n    }\r\n  }\r\n}\r\n","export class UIManager {\r\n  constructor() {\r\n    this.localPreviewVideo = null;\r\n    this.remoteVideos = new Map();\r\n    this.remoteStreams = new Map();\r\n    this.streamMonitorInterval = null;\r\n  }\r\n\r\n  makeDraggable(element) {\r\n    let isDragging = false;\r\n    let currentX;\r\n    let currentY;\r\n    let initialX;\r\n    let initialY;\r\n    let xOffset = 0;\r\n    let yOffset = 0;\r\n\r\n    element.addEventListener('mousedown', dragStart);\r\n    element.addEventListener('mouseup', dragEnd);\r\n    element.addEventListener('mousemove', drag);\r\n    element.style.cursor = 'move';\r\n\r\n    function dragStart(e) {\r\n      // Get current position from style\r\n      const computedStyle = window.getComputedStyle(element);\r\n      const bottom = computedStyle.bottom;\r\n      const left = computedStyle.left;\r\n      const right = computedStyle.right;\r\n      \r\n      // Convert to absolute positioning from current position\r\n      const rect = element.getBoundingClientRect();\r\n      element.style.left = rect.left + 'px';\r\n      element.style.top = rect.top + 'px';\r\n      element.style.bottom = 'auto';\r\n      element.style.right = 'auto';\r\n      \r\n      initialX = e.clientX - rect.left;\r\n      initialY = e.clientY - rect.top;\r\n      isDragging = true;\r\n      element.style.opacity = '0.8';\r\n    }\r\n\r\n    function dragEnd(e) {\r\n      initialX = currentX;\r\n      initialY = currentY;\r\n      isDragging = false;\r\n      element.style.opacity = '1';\r\n    }\r\n\r\n    function drag(e) {\r\n      if (isDragging) {\r\n        e.preventDefault();\r\n        currentX = e.clientX - initialX;\r\n        currentY = e.clientY - initialY;\r\n        \r\n        // Keep within viewport bounds\r\n        const maxX = window.innerWidth - element.offsetWidth;\r\n        const maxY = window.innerHeight - element.offsetHeight;\r\n        currentX = Math.max(0, Math.min(currentX, maxX));\r\n        currentY = Math.max(0, Math.min(currentY, maxY));\r\n        \r\n        setTranslate(currentX, currentY, element);\r\n      }\r\n    }\r\n\r\n    function setTranslate(xPos, yPos, el) {\r\n      el.style.left = xPos + 'px';\r\n      el.style.top = yPos + 'px';\r\n    }\r\n  }\r\n  getRemoteVideos() { return this.remoteVideos; }\r\n  getRemoteStreams() { return this.remoteStreams; }\r\n  setLocalPreviewVideo(video) { this.localPreviewVideo = video; }\r\n  getLocalPreviewVideo() { return this.localPreviewVideo; }\r\n  setStreamMonitorInterval(interval) { this.streamMonitorInterval = interval; }\r\n  getStreamMonitorInterval() { return this.streamMonitorInterval; }\r\n  clearStreamMonitorInterval() {\r\n    if (this.streamMonitorInterval) {\r\n      clearInterval(this.streamMonitorInterval);\r\n      this.streamMonitorInterval = null;\r\n    }\r\n  }\r\n\r\n  attachLocalPreview(stream) {\r\n    console.log('[UIManager] Attaching local preview with stream:', stream);\r\n    this.removeLocalPreview();\r\n    \r\n    const v = document.createElement('video');\r\n    v.id = 'tandem-local-preview';\r\n    v.autoplay = true;\r\n    v.muted = true; // Always mute local preview to avoid feedback\r\n    v.playsInline = true;\r\n    v.style.position = 'fixed';\r\n    v.style.bottom = '145px';\r\n    v.style.left = '20px';\r\n    v.style.width = '240px';\r\n    v.style.height = '160px';\r\n    v.style.zIndex = '999999';\r\n    v.style.border = '2px solid #e50914';\r\n    v.style.borderRadius = '4px';\r\n    v.style.transform = 'scaleX(-1)'; // Mirror for natural preview\r\n\r\n    try {\r\n      v.srcObject = stream;\r\n      console.log('[UIManager] Set srcObject on local preview');\r\n    } catch (e) {\r\n      console.warn('[UIManager] srcObject failed, trying createObjectURL:', e);\r\n      v.src = URL.createObjectURL(stream);\r\n    }\r\n\r\n    document.body.appendChild(v);\r\n    this.localPreviewVideo = v;\r\n    console.log('[UIManager] Local preview video appended to body');\r\n\r\n    // Make it draggable\r\n    this.makeDraggable(v);\r\n\r\n    v.play().catch(err => {\r\n      console.warn('[UIManager] Local preview play() failed:', err);\r\n    });\r\n  }\r\n\r\n  removeLocalPreview() {\r\n    if (this.localPreviewVideo) {\r\n      console.log('[UIManager] Removing local preview video');\r\n      try {\r\n        if (this.localPreviewVideo.srcObject) {\r\n          this.localPreviewVideo.srcObject = null;\r\n        }\r\n      } catch (e) {\r\n        console.warn('[UIManager] Error clearing srcObject:', e);\r\n      }\r\n      this.localPreviewVideo.remove();\r\n      this.localPreviewVideo = null;\r\n    }\r\n  }\r\n\r\n  clearAll() {\r\n    this.removeLocalPreview();\r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    this.clearStreamMonitorInterval();\r\n    this.removeConnectionIndicator();\r\n  }\r\n\r\n  showConnectionIndicator() {\r\n    // Remove existing indicator if any\r\n    this.removeConnectionIndicator();\r\n\r\n    const indicator = document.createElement('div');\r\n    indicator.id = 'tandem-connection-indicator';\r\n    indicator.style.cssText = `\r\n      position: fixed;\r\n      top: 10px;\r\n      left: 50%;\r\n      transform: translateX(-50%);\r\n      background: rgba(0, 0, 0, 0.85);\r\n      color: white;\r\n      padding: 8px 16px;\r\n      border-radius: 20px;\r\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\r\n      font-size: 13px;\r\n      font-weight: 500;\r\n      z-index: 999999;\r\n      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);\r\n      backdrop-filter: blur(10px);\r\n      display: flex;\r\n      align-items: center;\r\n      gap: 8px;\r\n      transition: all 0.3s ease;\r\n      cursor: pointer;\r\n    `;\r\n\r\n    // Add click handler to open extension popup\r\n    indicator.addEventListener('click', () => {\r\n      chrome.runtime.sendMessage({ type: 'OPEN_POPUP' });\r\n    });\r\n\r\n    const dot = document.createElement('div');\r\n    dot.id = 'tandem-connection-dot';\r\n    dot.style.cssText = `\r\n      width: 8px;\r\n      height: 8px;\r\n      border-radius: 50%;\r\n      background: #4ade80;\r\n      animation: pulse 2s ease-in-out infinite;\r\n    `;\r\n\r\n    const text = document.createElement('span');\r\n    text.id = 'tandem-connection-text';\r\n    text.textContent = 'Connected';\r\n\r\n    indicator.appendChild(dot);\r\n    indicator.appendChild(text);\r\n    document.body.appendChild(indicator);\r\n\r\n    // Add pulse animation\r\n    const style = document.createElement('style');\r\n    style.id = 'tandem-connection-style';\r\n    style.textContent = `\r\n      @keyframes pulse {\r\n        0%, 100% { opacity: 1; }\r\n        50% { opacity: 0.5; }\r\n      }\r\n      @keyframes spin {\r\n        0% { transform: rotate(0deg); }\r\n        100% { transform: rotate(360deg); }\r\n      }\r\n    `;\r\n    document.head.appendChild(style);\r\n\r\n    return indicator;\r\n  }\r\n\r\n  updateConnectionIndicator(status) {\r\n    const dot = document.getElementById('tandem-connection-dot');\r\n    const text = document.getElementById('tandem-connection-text');\r\n    \r\n    if (dot && text) {\r\n      if (status === 'connected') {\r\n        dot.style.background = '#4ade80';\r\n        dot.style.animation = 'pulse 2s ease-in-out infinite';\r\n        text.textContent = 'Connected';\r\n      } else if (status === 'waiting') {\r\n        dot.style.background = '#a78bfa';\r\n        dot.style.animation = 'spin 1s linear infinite';\r\n        text.textContent = 'Waiting for others...';\r\n      } else if (status === 'reconnecting') {\r\n        dot.style.background = '#f59e0b';\r\n        dot.style.animation = 'spin 1s linear infinite';\r\n        text.textContent = 'Reconnecting...';\r\n      } else if (status === 'disconnected') {\r\n        dot.style.background = '#ef4444';\r\n        dot.style.animation = 'pulse 1s ease-in-out infinite';\r\n        text.textContent = 'Disconnected';\r\n      }\r\n    }\r\n  }\r\n\r\n  removeConnectionIndicator() {\r\n    const indicator = document.getElementById('tandem-connection-indicator');\r\n    if (indicator) {\r\n      indicator.remove();\r\n    }\r\n  }\r\n}\r\n","export class NetflixController {\r\n  constructor() { this.injectAPIBridge(); }\r\n  injectAPIBridge() {\r\n    const script = document.createElement('script');\r\n    script.src = chrome.runtime.getURL('netflix-api-bridge.js');\r\n    (document.head || document.documentElement).appendChild(script);\r\n    script.onload = function() { script.remove(); };\r\n  }\r\n  _sendCommand(command, args = []) {\r\n    return new Promise(function(resolve) {\r\n      const handler = function(e) {\r\n        if (e.detail.command === command) {\r\n          document.removeEventListener('__tandem_response', handler);\r\n          resolve(e.detail.result);\r\n        }\r\n      };\r\n      document.addEventListener('__tandem_response', handler);\r\n      setTimeout(function() { resolve(null); }, 1000);\r\n      document.dispatchEvent(new CustomEvent('__tandem_command', { detail: { command, args } }));\r\n    });\r\n  }\r\n  play() { return this._sendCommand('play'); }\r\n  pause() { return this._sendCommand('pause'); }\r\n  seek(timeMs) { return this._sendCommand('seek', [timeMs]); }\r\n  getCurrentTime() { return this._sendCommand('getCurrentTime'); }\r\n  isPaused() { return this._sendCommand('isPaused'); }\r\n  setVolume(level) { return this._sendCommand('setVolume', [level]); }\r\n  getVolume() { return this._sendCommand('getVolume'); }\r\n  getVideoElement() { \r\n    // Find Netflix main player video element\r\n    // On /watch pages, look for video in the watch-video container\r\n    // On other pages, don't return any video (we don't want to sync preview videos)\r\n    \r\n    if (!window.location.pathname.startsWith('/watch')) {\r\n      return null;\r\n    }\r\n    \r\n    // Find Netflix video element, excluding tandem videos\r\n    const videos = document.querySelectorAll('video');\r\n    for (const video of videos) {\r\n      if (!video.id || !video.id.startsWith('tandem-')) {\r\n        return video;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n}\r\n","export function createRemoteHandlers({ state, netflix, lock, isInitializedRef, shouldAcceptLateSync, onInitialSyncApplied }) {\r\n  async function applyRemote(actionName, durationMs, actionFn) {\r\n    lock.set(durationMs);\r\n    try { await actionFn(); } catch (err) {\r\n      console.error(`[SyncManager] Error applying remote ${actionName}:`, err);\r\n    }\r\n  }\r\n\r\n  return {\r\n    async handleRequestSync(fromUserId, respectAutoPlay = false) {\r\n      const currentUrl = window.location.href;\r\n      const isOnWatchPage = window.location.pathname.startsWith('/watch');\r\n\r\n      // If we're on browse page, don't send sync response\r\n      if (!isOnWatchPage) {\r\n        console.log('[SyncManager] On browse page, not sending sync response');\r\n        return;\r\n      }\r\n\r\n      const maxAttempts = 6;\r\n      const retryDelayMs = 500;\r\n\r\n      const attemptSyncResponse = async (attempt) => {\r\n        try {\r\n          const currentTime = await netflix.getCurrentTime();\r\n          const isPaused = await netflix.isPaused();\r\n\r\n          if (currentTime == null) {\r\n            if (attempt < maxAttempts) {\r\n              console.log('[SyncManager] Playback state not ready, retrying sync response (attempt', attempt + 1, ')');\r\n              setTimeout(() => attemptSyncResponse(attempt + 1), retryDelayMs);\r\n            } else {\r\n              console.log('[SyncManager] Playback state still not ready, giving up on sync response');\r\n            }\r\n            return;\r\n          }\r\n\r\n          const currentTimeSeconds = currentTime / 1000;\r\n          console.log('[SyncManager] Sending SYNC_RESPONSE to', fromUserId, 'at', currentTimeSeconds.toFixed(2) + 's', isPaused ? 'paused' : 'playing', 'URL:', currentUrl, respectAutoPlay ? '(will respect auto-play)' : '');\r\n\r\n          state.safeSendMessage({\r\n            type: 'SYNC_RESPONSE',\r\n            targetUserId: fromUserId,\r\n            currentTime: currentTimeSeconds,\r\n            isPlaying: !isPaused,\r\n            url: currentUrl,\r\n            respectAutoPlay: respectAutoPlay\r\n          });\r\n        } catch (e) {\r\n          console.error('[SyncManager] Error handling sync request:', e);\r\n        }\r\n      };\r\n\r\n      if (!isInitializedRef.get()) {\r\n        console.log('[SyncManager] Not yet initialized, will still attempt to respond to sync request');\r\n      }\r\n\r\n      attemptSyncResponse(1);\r\n    },\r\n    async handleSyncResponse(currentTime, isPlaying, fromUserId, url, respectAutoPlay = false) {\r\n      if (isInitializedRef.get() && !shouldAcceptLateSync?.()) {\r\n        console.log('[SyncManager] Already initialized, ignoring late SYNC_RESPONSE');\r\n        return;\r\n      }\r\n\r\n      if (isInitializedRef.get() && shouldAcceptLateSync?.()) {\r\n        console.log('[SyncManager] Accepting late SYNC_RESPONSE within initial window');\r\n      }\r\n      \r\n      if (currentTime == null || typeof currentTime !== 'number' || currentTime < 0) {\r\n        console.warn('[SyncManager] Invalid SYNC_RESPONSE - bad currentTime:', currentTime);\r\n        return;\r\n      }\r\n      \r\n      if (respectAutoPlay) {\r\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's (respecting auto-play)');\r\n      } else {\r\n        console.log('[SyncManager] Initial sync from', fromUserId, 'seeking to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'URL:', url);\r\n      }\r\n      \r\n      // Check if we need to navigate to a different URL\r\n      const currentUrl = window.location.href;\r\n      const currentPath = window.location.pathname;\r\n      const isOnWatch = currentPath.startsWith('/watch');\r\n      const isOnBrowse = currentPath.startsWith('/browse');\r\n      const otherIsOnWatch = url && (new URL(url).pathname.startsWith('/watch'));\r\n      \r\n      // Only navigate if we're NOT on a /watch page and the other user IS on /watch\r\n      // This allows initial sync to pull you to the watch page, but won't pull you back if you leave\r\n      if (!isOnWatch && otherIsOnWatch && isOnBrowse) {\r\n        console.log('[SyncManager] On browse page during initial join, other user on /watch - navigating to their show');\r\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n      \r\n      // If we're not on /watch at all, ignore this sync response\r\n      if (!isOnWatch) {\r\n        console.log('[SyncManager] Not on /watch page - ignoring sync response');\r\n        isInitializedRef.set(true); // Mark as initialized so we don't keep processing these\r\n        if (onInitialSyncApplied) onInitialSyncApplied();\r\n        return;\r\n      }\r\n      \r\n      // Regular URL mismatch handling\r\n      if (url && url !== currentUrl) {\r\n        console.log('[SyncManager] URL mismatch - navigating from', currentUrl, 'to', url);\r\n        // Store the sync state to apply after navigation\r\n        sessionStorage.setItem('tandem_pending_sync', JSON.stringify({\r\n          currentTime,\r\n          isPlaying,\r\n          timestamp: Date.now()\r\n        }));\r\n        // Navigate to the correct URL\r\n        window.location.href = url;\r\n        return;\r\n      }\r\n\r\n      // If sync returns a near-zero timestamp, wait briefly for Netflix resume\r\n      // and prefer local progress to avoid resetting watch history.\r\n      // This handles cases where room state is default or stale.\r\n      if (currentTime <= 2) {\r\n        try {\r\n          console.log('[SyncManager] Received near-zero sync (', currentTime.toFixed(2) + 's), checking for local resume position from', fromUserId);\r\n          const waitForLocalResume = async () => {\r\n            const attempts = 8;\r\n            const delayMs = 500;\r\n            for (let i = 0; i < attempts; i++) {\r\n              const localTimeMs = await netflix.getCurrentTime();\r\n              console.log('[SyncManager] Resume check attempt', i + 1, '- local time:', localTimeMs != null ? (localTimeMs / 1000).toFixed(2) + 's' : 'null');\r\n              if (localTimeMs != null && localTimeMs > 5000) {\r\n                return localTimeMs;\r\n              }\r\n              await new Promise(r => setTimeout(r, delayMs));\r\n            }\r\n            return null;\r\n          };\r\n\r\n          const localTimeMs = await waitForLocalResume();\r\n          if (localTimeMs != null && localTimeMs > 5000) {\r\n            const localPaused = await netflix.isPaused();\r\n            const localSeconds = localTimeMs / 1000;\r\n            console.log('[SyncManager] Using local resume position instead of near-zero sync:', localSeconds.toFixed(2) + 's', localPaused ? 'paused' : 'playing');\r\n            isInitializedRef.set(true);\r\n            if (onInitialSyncApplied) onInitialSyncApplied();\r\n            state.safeSendMessage({\r\n              type: 'POSITION_UPDATE',\r\n              currentTime: localSeconds,\r\n              isPlaying: !localPaused\r\n            });\r\n            return;\r\n          } else {\r\n            console.log('[SyncManager] No local resume position found after waiting, applying sync at', currentTime.toFixed(2) + 's');\r\n          }\r\n        } catch (e) {\r\n          console.warn('[SyncManager] Error checking local resume position:', e);\r\n        }\r\n      }\r\n      \r\n      isInitializedRef.set(true);\r\n      if (onInitialSyncApplied) onInitialSyncApplied();\r\n      \r\n      await applyRemote('initial-sync', 1500, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        \r\n        // If respecting auto-play, only sync timestamp, not play/pause state\r\n        if (respectAutoPlay) {\r\n          console.log('[SyncManager] Synced timestamp only, respecting Netflix auto-play');\r\n          // Report position to server\r\n          const finalPaused = await netflix.isPaused();\r\n          state.safeSendMessage({\r\n            type: 'POSITION_UPDATE',\r\n            currentTime: currentTime,\r\n            isPlaying: !finalPaused\r\n          });\r\n          return;\r\n        }\r\n        \r\n        const localPaused = await netflix.isPaused();\r\n        \r\n        // Sync to the remote play/pause state\r\n        if (isPlaying && localPaused) {\r\n          console.log('[SyncManager] Remote is playing, starting playback');\r\n          await netflix.play();\r\n        } else if (!isPlaying && !localPaused) {\r\n          console.log('[SyncManager] Remote is paused, pausing playback');\r\n          await netflix.pause();\r\n        }\r\n        \r\n        // Report final position to server after sync complete\r\n        state.safeSendMessage({\r\n          type: 'POSITION_UPDATE',\r\n          currentTime: currentTime,\r\n          isPlaying: isPlaying\r\n        });\r\n      });\r\n    },\r\n    async handlePlaybackControl(control, currentTime, fromUserId) {\r\n      console.log('[SyncManager] Remote', control.toUpperCase(), 'from', fromUserId);\r\n      \r\n      await applyRemote(control, 1000, async () => {\r\n        // Only apply play/pause, don't seek\r\n        // Position is synced separately via SEEK and POSITION_UPDATE messages\r\n        if (control === 'play') {\r\n          await netflix.play();\r\n        } else {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    },\r\n    async handleSeek(currentTime, isPlaying, fromUserId) {\r\n      console.log('[SyncManager] Remote SEEK to', currentTime.toFixed(2) + 's', isPlaying ? 'playing' : 'paused', 'from', fromUserId);\r\n      \r\n      await applyRemote('seek', 1200, async () => {\r\n        await netflix.seek(currentTime * 1000);\r\n        const isPaused = await netflix.isPaused();\r\n        \r\n        if (isPlaying && isPaused) {\r\n          await netflix.play();\r\n        } else if (!isPlaying && !isPaused) {\r\n          await netflix.pause();\r\n        }\r\n      });\r\n    }\r\n  };\r\n}\r\n","import { createSignalingHandlers } from './signaling.js';\r\nimport { createPeerConnectionFactory, addOrReplaceTrack } from './peerConnection.js';\r\nimport { createReconnectionManager } from './reconnect.js';\r\nimport { createRemoteVideoManager } from './ui.js';\r\n\r\nexport class WebRTCManager {\r\n  constructor(stateManager, uiManager) {\r\n    this.stateManager = stateManager;\r\n    this.uiManager = uiManager;\r\n    this.peerConnections = new Map();\r\n    this.remoteStreams = this.uiManager.getRemoteStreams();\r\n    this.remoteVideos = this.uiManager.getRemoteVideos();\r\n    this.peersThatLeft = new Set();\r\n    this.localStream = null;\r\n\r\n    const videoManager = createRemoteVideoManager(this.remoteVideos);\r\n    \r\n    // Create a placeholder object for circular dependency resolution\r\n    const reconnectionManager = {};\r\n    \r\n    const createPeer = createPeerConnectionFactory({\r\n      stateManager: this.stateManager,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      remoteStreams: this.remoteStreams,\r\n      remoteVideos: this.remoteVideos,\r\n      addRemoteVideo: videoManager.add,\r\n      attemptReconnection: (peerId) => reconnectionManager.attempt(peerId),\r\n      clearReconnection: (peerId) => reconnectionManager.clear(peerId),\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      },\r\n      peersThatLeft: this.peersThatLeft,\r\n      showReconnecting: videoManager.showReconnecting,\r\n      hideOverlay: videoManager.hideOverlay,\r\n      showPlaceholder: videoManager.showPlaceholder\r\n    });\r\n\r\n    // Now create the actual reconnection manager with createPeer available\r\n    Object.assign(reconnectionManager, createReconnectionManager({\r\n      stateManager: this.stateManager,\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      localStream: () => this.localStream,\r\n      createPeer: createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack\r\n    }));\r\n\r\n    this.reconnectionManager = reconnectionManager;\r\n    this.createPeer = createPeer;\r\n    this.videoManager = videoManager;\r\n\r\n    this.signalingHandlers = createSignalingHandlers({\r\n      getState: () => this.stateManager.getState(),\r\n      peerConnections: this.peerConnections,\r\n      peersThatLeft: this.peersThatLeft,\r\n      getLocalStream: () => this.localStream,\r\n      createPeer,\r\n      sendSignal: (msg) => this._sendSignal(msg),\r\n      addOrReplaceTrack,\r\n      clearReconnection: reconnectionManager.clear,\r\n      removeRemoteVideo: (peerId) => {\r\n        videoManager.remove(peerId);\r\n        this.remoteStreams.delete(peerId);\r\n      }\r\n    });\r\n  }\r\n\r\n  setLocalStream(stream) { this.localStream = stream; }\r\n  getLocalStream() { return this.localStream; }\r\n  \r\n  onLocalStreamAvailable(stream) {\r\n    this.localStream = stream;\r\n    this.peerConnections.forEach((pc) => {\r\n      try {\r\n        stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n      } catch (e) {}\r\n    });\r\n  }\r\n\r\n  async handleSignal(message) {\r\n    console.log('[WebRTCManager] handleSignal called with:', message);\r\n    if (!message || !message.type) {\r\n      console.warn('[WebRTCManager] Invalid message:', message);\r\n      return;\r\n    }\r\n    const type = message.type;\r\n    const from = message.userId || message.from;\r\n    const to = message.to;\r\n    const state = this.stateManager.getState();\r\n    console.log('[WebRTCManager] Processing signal type:', type, 'from:', from, 'to:', to, 'myId:', state.userId);\r\n    \r\n    // Only check 'to' field for targeted messages (not broadcasts like JOIN)\r\n    // JOIN, LEAVE, and SYNC messages are broadcasts that don't have 'to' fields\r\n    const isTargetedMessage = type === 'OFFER' || type === 'ANSWER' || type === 'ICE_CANDIDATE' || type === 'SYNC_RESPONSE';\r\n    if (isTargetedMessage && to && to !== state.userId) {\r\n      console.log('[WebRTCManager] Ignoring targeted message not meant for me');\r\n      return;\r\n    }\r\n\r\n    if (type === 'JOIN' && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleJoin');\r\n      await this.signalingHandlers.handleJoin(from);\r\n    } else if (type === 'OFFER' && message.offer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleOffer');\r\n      await this.signalingHandlers.handleOffer(from, message.offer);\r\n    } else if (type === 'ANSWER' && message.answer && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleAnswer');\r\n      await this.signalingHandlers.handleAnswer(from, message.answer);\r\n    } else if (type === 'ICE_CANDIDATE' && message.candidate && from && from !== state.userId) {\r\n      console.log('[WebRTCManager] Dispatching to handleIceCandidate');\r\n      await this.signalingHandlers.handleIceCandidate(from, message.candidate);\r\n    } else if (type === 'LEAVE' && from) {\r\n      console.log('[WebRTCManager] Dispatching to handleLeave');\r\n      this.signalingHandlers.handleLeave(from);\r\n    } else {\r\n      console.log('[WebRTCManager] Signal not handled - type:', type, 'from:', from, 'fromSelf:', from === state.userId, 'reasons:', {\r\n        JOIN: type === 'JOIN' ? `from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        OFFER: type === 'OFFER' ? `hasOffer=${!!message.offer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        ANSWER: type === 'ANSWER' ? `hasAnswer=${!!message.answer}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        ICE: type === 'ICE_CANDIDATE' ? `hasCandidate=${!!message.candidate}, from=${!!from}, notSelf=${from !== state.userId}` : 'N/A',\r\n        LEAVE: type === 'LEAVE' ? `from=${!!from}` : 'N/A'\r\n      });\r\n    }\r\n  }\r\n\r\n  attemptReconnection(peerId) {\r\n    return this.reconnectionManager.attempt(peerId);\r\n  }\r\n\r\n  _sendSignal(message) {\r\n    this.stateManager.safeSendMessage({ type: 'SIGNAL_SEND', message }, function() {});\r\n  }\r\n\r\n  showWaitingIndicator() {\r\n    console.log('[WebRTCManager] Showing waiting indicator');\r\n    this.videoManager.showWaitingIndicator();\r\n  }\r\n  \r\n  hideWaitingIndicator() {\r\n    console.log('[WebRTCManager] Hiding waiting indicator');\r\n    this.videoManager.hideWaitingIndicator();\r\n  }\r\n  \r\n  clearAll() {\r\n    console.log('[WebRTCManager] Clearing all connections and videos');\r\n    \r\n    // Hide waiting indicator\r\n    this.hideWaitingIndicator();\r\n    \r\n    this.peerConnections.forEach((pc) => {\r\n      try { pc.close(); } catch (e) {}\r\n    });\r\n    this.peerConnections.clear();\r\n    this.peersThatLeft.clear();\r\n    \r\n    // Clean up video elements and their containers\r\n    this.remoteVideos.forEach((v, peerId) => {\r\n      try { \r\n        if (v.srcObject) {\r\n          v.srcObject.getTracks().forEach(track => track.stop());\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      \r\n      // Remove the container (which includes the video)\r\n      const container = document.getElementById('tandem-container-' + peerId);\r\n      if (container) {\r\n        console.log('[WebRTCManager] Removing container for peer:', peerId);\r\n        container.remove();\r\n      } else if (v.parentElement) {\r\n        // Fallback: remove parent if it exists\r\n        v.parentElement.remove();\r\n      } else {\r\n        // Last resort: just remove the video\r\n        v.remove();\r\n      }\r\n    });\r\n    \r\n    this.remoteVideos.clear();\r\n    this.remoteStreams.clear();\r\n    \r\n    // Extra cleanup: remove any orphaned tandem elements\r\n    document.querySelectorAll('[id^=\"tandem-container-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned container:', el.id);\r\n      el.remove();\r\n    });\r\n    document.querySelectorAll('[id^=\"tandem-remote-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned video:', el.id);\r\n      el.remove();\r\n    });\r\n    document.querySelectorAll('[id^=\"tandem-overlay-\"]').forEach(el => {\r\n      console.log('[WebRTCManager] Removing orphaned overlay:', el.id);\r\n      el.remove();\r\n    });\r\n    \r\n    if (this.localStream) {\r\n      this.localStream.getTracks().forEach(track => track.stop());\r\n      this.localStream = null;\r\n    }\r\n  }\r\n}\r\n","export function createRemoteVideoManager(remoteVideos) {\r\n  function ensureSpinnerStyles() {\r\n    if (document.getElementById('tandem-spinner-styles')) {\r\n      return;\r\n    }\r\n\r\n    const style = document.createElement('style');\r\n    style.id = 'tandem-spinner-styles';\r\n    style.textContent = `\r\n      @keyframes tandem-spin {\r\n        0% { transform: rotate(0deg); }\r\n        100% { transform: rotate(360deg); }\r\n      }\r\n      @keyframes tandem-pulse {\r\n        0%, 100% { opacity: 0.3; }\r\n        50% { opacity: 1; }\r\n      }\r\n      @keyframes tandem-dot {\r\n        0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; }\r\n        40% { transform: scale(1); opacity: 1; }\r\n      }\r\n      .tandem-dots {\r\n        display: inline-flex;\r\n        gap: 4px;\r\n        align-items: center;\r\n        justify-content: center;\r\n      }\r\n      .tandem-dot {\r\n        width: 6px;\r\n        height: 6px;\r\n        border-radius: 50%;\r\n        background: #38bdf8;\r\n        animation: tandem-dot 1.2s infinite ease-in-out;\r\n      }\r\n      .tandem-dot:nth-child(2) { animation-delay: 0.2s; }\r\n      .tandem-dot:nth-child(3) { animation-delay: 0.4s; }\r\n    `;\r\n    document.head.appendChild(style);\r\n  }\r\n\r\n  function createLoadingSpinner() {\r\n    ensureSpinnerStyles();\r\n    // Create a more visually appealing spinner using CSS\r\n    const spinner = document.createElement('div');\r\n    spinner.className = 'tandem-spinner';\r\n    spinner.style.cssText = `\r\n      width: 40px;\r\n      height: 40px;\r\n      border: 4px solid rgba(255, 255, 255, 0.3);\r\n      border-top: 4px solid #00aaff;\r\n      border-radius: 50%;\r\n      animation: tandem-spin 1s linear infinite;\r\n      margin-bottom: 12px;\r\n    `;\r\n    return spinner;\r\n  }\r\n\r\n  function createWaitingDots() {\r\n    ensureSpinnerStyles();\r\n    const dots = document.createElement('div');\r\n    dots.className = 'tandem-dots';\r\n    dots.innerHTML = '<span class=\"tandem-dot\"></span><span class=\"tandem-dot\"></span><span class=\"tandem-dot\"></span>';\r\n    return dots;\r\n  }\r\n  \r\n  function makeDraggable(element) {\r\n    let isDragging = false;\r\n    let currentX;\r\n    let currentY;\r\n    let initialX;\r\n    let initialY;\r\n\r\n    element.addEventListener('mousedown', dragStart);\r\n    element.addEventListener('mouseup', dragEnd);\r\n    element.addEventListener('mousemove', drag);\r\n    element.style.cursor = 'move';\r\n\r\n    function dragStart(e) {\r\n      const computedStyle = window.getComputedStyle(element);\r\n      const rect = element.getBoundingClientRect();\r\n      \r\n      element.style.left = rect.left + 'px';\r\n      element.style.top = rect.top + 'px';\r\n      element.style.bottom = 'auto';\r\n      element.style.right = 'auto';\r\n      \r\n      initialX = e.clientX - rect.left;\r\n      initialY = e.clientY - rect.top;\r\n      isDragging = true;\r\n      element.style.opacity = '0.8';\r\n    }\r\n\r\n    function dragEnd(e) {\r\n      initialX = currentX;\r\n      initialY = currentY;\r\n      isDragging = false;\r\n      element.style.opacity = '1';\r\n    }\r\n\r\n    function drag(e) {\r\n      if (isDragging) {\r\n        e.preventDefault();\r\n        currentX = e.clientX - initialX;\r\n        currentY = e.clientY - initialY;\r\n        \r\n        const maxX = window.innerWidth - element.offsetWidth;\r\n        const maxY = window.innerHeight - element.offsetHeight;\r\n        currentX = Math.max(0, Math.min(currentX, maxX));\r\n        currentY = Math.max(0, Math.min(currentY, maxY));\r\n        \r\n        element.style.left = currentX + 'px';\r\n        element.style.top = currentY + 'px';\r\n      }\r\n    }\r\n  }\r\n\r\n  function add(peerId, stream) {\r\n    console.log('[RemoteVideoManager] Adding remote video for peer:', peerId, 'stream:', stream, 'tracks:', stream.getTracks());\r\n    console.log('[RemoteVideoManager] Current remoteVideos map size:', remoteVideos.size, 'peers:', Array.from(remoteVideos.keys()));\r\n    \r\n    // Check if video already exists in DOM (double-check for race conditions)\r\n    const existingInDom = document.getElementById('tandem-remote-' + peerId);\r\n    if (existingInDom) {\r\n      console.log('[RemoteVideoManager] Video already exists in DOM for peer:', peerId, 'skipping duplicate creation');\r\n      // Update stream on existing element if different\r\n      if (existingInDom.srcObject !== stream) {\r\n        console.log('[RemoteVideoManager] Updating stream on existing video element');\r\n        existingInDom.srcObject = stream;\r\n        // Remove loading overlay if it exists\r\n        const overlay = document.getElementById('tandem-overlay-' + peerId);\r\n        if (overlay) overlay.remove();\r\n      }\r\n      // Make sure it's tracked\r\n      if (!remoteVideos.has(peerId)) {\r\n        remoteVideos.set(peerId, existingInDom);\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Check if a placeholder container already exists\r\n    let container = document.getElementById('tandem-container-' + peerId);\r\n    \r\n    if (!container) {\r\n      // No placeholder exists, create container from scratch\r\n      // Remove any stale references\r\n      remove(peerId);\r\n      \r\n      container = document.createElement('div');\r\n      container.id = 'tandem-container-' + peerId;\r\n      container.style.position = 'fixed';\r\n      container.style.bottom = '145px';\r\n      container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n      container.style.width = '240px';\r\n      container.style.height = '160px';\r\n      container.style.zIndex = 999999;\r\n      container.style.border = '2px solid #00aaff';\r\n      container.style.borderRadius = '4px';\r\n      container.style.backgroundColor = '#000';\r\n    } else {\r\n      console.log('[RemoteVideoManager] Using existing placeholder container for peer:', peerId);\r\n    }\r\n    \r\n    const v = document.createElement('video');\r\n    v.id = 'tandem-remote-' + peerId;\r\n    v.autoplay = true;\r\n    v.playsInline = true;\r\n    v.muted = true;\r\n    v.style.width = '100%';\r\n    v.style.height = '100%';\r\n    v.style.border = '2px solid #00aaff';\r\n    v.style.borderRadius = '4px';\r\n    v.style.backgroundColor = '#000';\r\n    \r\n    // Get or create overlay\r\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\r\n    if (!overlay) {\r\n      overlay = document.createElement('div');\r\n      overlay.id = 'tandem-overlay-' + peerId;\r\n      overlay.style.position = 'absolute';\r\n      overlay.style.top = '0';\r\n      overlay.style.left = '0';\r\n      overlay.style.width = '100%';\r\n      overlay.style.height = '100%';\r\n      overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n      overlay.style.display = 'flex';\r\n      overlay.style.flexDirection = 'column';\r\n      overlay.style.alignItems = 'center';\r\n      overlay.style.justifyContent = 'center';\r\n      overlay.style.color = '#fff';\r\n      overlay.style.fontSize = '14px';\r\n      overlay.style.fontFamily = 'Arial, sans-serif';\r\n      overlay.style.borderRadius = '4px';\r\n      overlay.style.pointerEvents = 'none';\r\n      \r\n      const spinner = createLoadingSpinner();\r\n      const text = document.createElement('div');\r\n      text.textContent = 'Connecting...';\r\n      text.style.fontWeight = '500';\r\n      \r\n      overlay.appendChild(spinner);\r\n      overlay.appendChild(text);\r\n    }\r\n    \r\n    ensureSpinnerStyles();\r\n    \r\n    container.appendChild(v);\r\n    if (!overlay.parentElement) {\r\n      container.appendChild(overlay);\r\n    }\r\n    if (!container.parentElement) {\r\n      document.body.appendChild(container);\r\n      // Make container draggable if newly created\r\n      makeDraggable(container);\r\n    }\r\n    console.log('[RemoteVideoManager] Added video to container:', container.id);\r\n    \r\n    // Verify stream has active tracks\r\n    const activeTracks = stream.getTracks().filter(t => t.readyState === 'live');\r\n    console.log('[RemoteVideoManager] Stream has', activeTracks.length, 'active tracks:', \r\n      activeTracks.map(t => `${t.kind}:${t.id.substring(0,8)}`).join(', '));\r\n    \r\n    try { \r\n      v.srcObject = stream;\r\n      console.log('[RemoteVideoManager] Set srcObject successfully');\r\n    } catch (e) { \r\n      console.warn('[RemoteVideoManager] srcObject failed:', e);\r\n    }\r\n    \r\n    remoteVideos.set(peerId, v);\r\n    \r\n    // Handle video playback with better error handling\r\n    const playVideo = () => {\r\n      v.play().then(() => {\r\n        console.log('[RemoteVideoManager] Video playing, unmuting and removing overlay');\r\n        v.muted = false;\r\n        v.volume = 1.0;\r\n        // Remove loading overlay\r\n        overlay.remove();\r\n      }).catch((e) => { \r\n        console.warn('[RemoteVideoManager] Play failed:', e.name, e.message);\r\n        // Try unmuting anyway in case autoplay blocked\r\n        v.muted = false;\r\n        // Still remove overlay even if play failed\r\n        overlay.remove();\r\n      });\r\n    };\r\n    \r\n    // If stream already has tracks, play immediately\r\n    if (activeTracks.length > 0) {\r\n      playVideo();\r\n    } else {\r\n      // Wait for tracks to become active\r\n      console.log('[RemoteVideoManager] Waiting for stream tracks to become active');\r\n      overlay.innerHTML = '<div style=\"text-align: center;\"><div style=\"margin-bottom: 8px;\"></div><div>Waiting for stream...</div></div>';\r\n      const checkTracks = setInterval(() => {\r\n        const nowActive = stream.getTracks().filter(t => t.readyState === 'live');\r\n        if (nowActive.length > 0) {\r\n          clearInterval(checkTracks);\r\n          console.log('[RemoteVideoManager] Tracks now active, playing video');\r\n          playVideo();\r\n        }\r\n      }, 100);\r\n      // Give up after 5 seconds and remove overlay anyway\r\n      setTimeout(() => {\r\n        clearInterval(checkTracks);\r\n        if (overlay.parentNode) {\r\n          console.log('[RemoteVideoManager] Timeout waiting for tracks, removing overlay');\r\n          overlay.remove();\r\n        }\r\n      }, 5000);\r\n    }\r\n  }\r\n  \r\n  function remove(peerId) {\r\n    console.log('[RemoteVideoManager] Removing remote video for peer:', peerId);\r\n    \r\n    // Remove from map\r\n    const v = remoteVideos.get(peerId);\r\n    if (v) {\r\n      try { \r\n        if (v.srcObject) {\r\n          v.srcObject.getTracks().forEach(track => track.stop());\r\n          v.srcObject = null;\r\n        }\r\n      } catch (e) {\r\n        console.warn('[RemoteVideoManager] Error cleaning up stream:', e);\r\n      }\r\n      // Remove the container (which includes the video)\r\n      const container = v.parentElement;\r\n      if (container && container.id === 'tandem-container-' + peerId) {\r\n        container.remove();\r\n      } else {\r\n        v.remove();\r\n      }\r\n      remoteVideos.delete(peerId);\r\n    }\r\n    \r\n    // Also check DOM for any orphaned elements (extra safety)\r\n    const domContainer = document.getElementById('tandem-container-' + peerId);\r\n    if (domContainer) {\r\n      console.log('[RemoteVideoManager] Found orphaned container, removing');\r\n      domContainer.remove();\r\n    }\r\n    \r\n    const domElement = document.getElementById('tandem-remote-' + peerId);\r\n    if (domElement && domElement !== v) {\r\n      console.log('[RemoteVideoManager] Found orphaned video element, removing');\r\n      try {\r\n        if (domElement.srcObject) {\r\n          domElement.srcObject = null;\r\n        }\r\n      } catch (e) {}\r\n      domElement.remove();\r\n    }\r\n    \r\n    // Clean up overlay if it exists\r\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\r\n    if (overlay) {\r\n      overlay.remove();\r\n    }\r\n  }\r\n  \r\n  function showReconnecting(peerId) {\r\n    console.log('[RemoteVideoManager] Showing reconnecting overlay for peer:', peerId);\r\n    \r\n    // Check if overlay already exists\r\n    let overlay = document.getElementById('tandem-overlay-' + peerId);\r\n    if (overlay) {\r\n      // Update existing overlay content\r\n      overlay.innerHTML = '';\r\n      const spinner = createLoadingSpinner();\r\n      const text = document.createElement('div');\r\n      text.textContent = 'Reconnecting...';\r\n      text.style.fontWeight = '500';\r\n      overlay.appendChild(spinner);\r\n      overlay.appendChild(text);\r\n      overlay.style.display = 'flex';\r\n      return;\r\n    }\r\n    \r\n    // Create new overlay if it doesn't exist\r\n    const container = document.getElementById('tandem-container-' + peerId);\r\n    if (!container) {\r\n      console.warn('[RemoteVideoManager] Cannot show reconnecting - container not found');\r\n      return;\r\n    }\r\n    \r\n    overlay = document.createElement('div');\r\n    overlay.id = 'tandem-overlay-' + peerId;\r\n    overlay.style.position = 'absolute';\r\n    overlay.style.top = '0';\r\n    overlay.style.left = '0';\r\n    overlay.style.width = '100%';\r\n    overlay.style.height = '100%';\r\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n    overlay.style.display = 'flex';\r\n    overlay.style.flexDirection = 'column';\r\n    overlay.style.alignItems = 'center';\r\n    overlay.style.justifyContent = 'center';\r\n    overlay.style.color = '#fff';\r\n    overlay.style.fontSize = '14px';\r\n    overlay.style.fontFamily = 'Arial, sans-serif';\r\n    overlay.style.borderRadius = '4px';\r\n    overlay.style.pointerEvents = 'none';\r\n    \r\n    const spinner = createLoadingSpinner();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Reconnecting...';\r\n    text.style.fontWeight = '500';\r\n    \r\n    overlay.appendChild(spinner);\r\n    overlay.appendChild(text);\r\n    container.appendChild(overlay);\r\n  }\r\n  \r\n  function hideOverlay(peerId) {\r\n    const overlay = document.getElementById('tandem-overlay-' + peerId);\r\n    if (overlay) {\r\n      console.log('[RemoteVideoManager] Hiding overlay for peer:', peerId);\r\n      overlay.remove();\r\n    }\r\n  }\r\n  \r\n  function showWaitingIndicator() {\r\n    // Remove any existing waiting indicator first\r\n    hideWaitingIndicator();\r\n    \r\n    console.log('[RemoteVideoManager] Showing waiting indicator');\r\n    const container = document.createElement('div');\r\n    container.id = 'tandem-waiting-indicator';\r\n    container.style.position = 'fixed';\r\n    container.style.bottom = '24px';\r\n    container.style.right = '20px';\r\n    container.style.padding = '8px 12px';\r\n    container.style.zIndex = 999999;\r\n    container.style.border = '1px solid rgba(56, 189, 248, 0.4)';\r\n    container.style.borderRadius = '999px';\r\n    container.style.backgroundColor = 'rgba(15, 23, 42, 0.9)';\r\n    container.style.display = 'flex';\r\n    container.style.alignItems = 'center';\r\n    container.style.gap = '8px';\r\n    container.style.color = '#e2e8f0';\r\n    container.style.fontSize = '12px';\r\n    container.style.fontFamily = 'Arial, sans-serif';\r\n    container.style.pointerEvents = 'none';\r\n    container.style.boxShadow = '0 6px 18px rgba(0, 0, 0, 0.35)';\r\n    \r\n    const dots = createWaitingDots();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Party started  waiting for others';\r\n    text.style.fontWeight = '500';\r\n    text.style.letterSpacing = '0.2px';\r\n    \r\n    container.appendChild(dots);\r\n    container.appendChild(text);\r\n    document.body.appendChild(container);\r\n  }\r\n  \r\n  function hideWaitingIndicator() {\r\n    const indicator = document.getElementById('tandem-waiting-indicator');\r\n    if (indicator) {\r\n      console.log('[RemoteVideoManager] Hiding waiting indicator');\r\n      indicator.remove();\r\n    }\r\n  }\r\n  \r\n  function showPlaceholder(peerId) {\r\n    console.log('[RemoteVideoManager] Showing placeholder for peer:', peerId);\r\n    \r\n    // Hide waiting indicator when first peer connects\r\n    hideWaitingIndicator();\r\n    \r\n    // Check if container already exists\r\n    let container = document.getElementById('tandem-container-' + peerId);\r\n    if (container) {\r\n      console.log('[RemoteVideoManager] Placeholder already exists for peer:', peerId, '- reusing it');\r\n      return;\r\n    }\r\n    \r\n    console.log('[RemoteVideoManager] Creating NEW placeholder container for peer:', peerId);\r\n    \r\n    // Create container immediately\r\n    container = document.createElement('div');\r\n    container.id = 'tandem-container-' + peerId;\r\n    container.style.position = 'fixed';\r\n    container.style.bottom = '145px';\r\n    container.style.right = (20 + (remoteVideos.size * 180)) + 'px';\r\n    container.style.width = '240px';\r\n    container.style.height = '160px';\r\n    container.style.zIndex = 999999;\r\n    container.style.border = '2px solid #00aaff';\r\n    container.style.borderRadius = '4px';\r\n    container.style.backgroundColor = '#000';\r\n    \r\n    // Create loading overlay\r\n    const overlay = document.createElement('div');\r\n    overlay.id = 'tandem-overlay-' + peerId;\r\n    overlay.style.position = 'absolute';\r\n    overlay.style.top = '0';\r\n    overlay.style.left = '0';\r\n    overlay.style.width = '100%';\r\n    overlay.style.height = '100%';\r\n    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';\r\n    overlay.style.display = 'flex';\r\n    overlay.style.flexDirection = 'column';\r\n    overlay.style.alignItems = 'center';\r\n    overlay.style.justifyContent = 'center';\r\n    overlay.style.color = '#fff';\r\n    overlay.style.fontSize = '14px';\r\n    overlay.style.fontFamily = 'Arial, sans-serif';\r\n    overlay.style.borderRadius = '4px';\r\n    overlay.style.pointerEvents = 'none';\r\n    \r\n    const spinner = createLoadingSpinner();\r\n    const text = document.createElement('div');\r\n    text.textContent = 'Connecting...';\r\n    text.style.fontWeight = '500';\r\n    \r\n    overlay.appendChild(spinner);\r\n    overlay.appendChild(text);\r\n    container.appendChild(overlay);\r\n    document.body.appendChild(container);\r\n    \r\n    // Make container draggable immediately\r\n    makeDraggable(container);\r\n    \r\n    console.log('[RemoteVideoManager] Created placeholder container:', container.id);\r\n  }\r\n  \r\n  return { add, remove, showReconnecting, hideOverlay, showPlaceholder, showWaitingIndicator, hideWaitingIndicator };\r\n}\r\n","export function createReconnectionManager({ stateManager, peerConnections, peersThatLeft, localStream, createPeer, sendSignal, addOrReplaceTrack }) {\r\n  const attempts = new Map();\r\n  const timeouts = new Map();\r\n  \r\n  function clear(peerId) {\r\n    attempts.delete(peerId);\r\n    const handle = timeouts.get(peerId);\r\n    if (handle) {\r\n      clearTimeout(handle);\r\n      timeouts.delete(peerId);\r\n    }\r\n  }\r\n  \r\n  async function attempt(peerId) {\r\n    if (!stateManager.isInParty()) return;\r\n    if (peersThatLeft.has(peerId)) {\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    const count = attempts.get(peerId) || 0;\r\n    const maxAttempts = 5;\r\n    // Faster reconnection: 500ms, 1s, 2s, 4s, 8s (instead of 1s, 2s, 4s, 8s, 16s)\r\n    const backoffDelay = Math.min(500 * Math.pow(2, count), 10000);\r\n    if (count >= maxAttempts) {\r\n      console.log('[Reconnection] Max attempts reached for peer:', peerId);\r\n      clear(peerId);\r\n      return;\r\n    }\r\n    console.log('[Reconnection] Attempting reconnection for peer:', peerId, 'attempt:', count + 1, 'delay:', backoffDelay + 'ms');\r\n    attempts.set(peerId, count + 1);\r\n    const existing = timeouts.get(peerId);\r\n    if (existing) clearTimeout(existing);\r\n    const handle = setTimeout(async () => {\r\n      const oldPc = peerConnections.get(peerId);\r\n      if (oldPc) {\r\n        try { oldPc.close(); } catch (e) {}\r\n        peerConnections.delete(peerId);\r\n      }\r\n      try {\r\n        const pc = createPeer(peerId);\r\n        peerConnections.set(peerId, pc);\r\n        const stream = typeof localStream === 'function' ? localStream() : localStream;\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => addOrReplaceTrack(pc, t, stream));\r\n        }\r\n        const offer = await pc.createOffer();\r\n        await pc.setLocalDescription(offer);\r\n        const state = stateManager.getState();\r\n        sendSignal({ type: 'OFFER', from: state.userId, to: peerId, offer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[WebRTCManager] Reconnection failed:', err);\r\n        attempt(peerId);\r\n      }\r\n    }, backoffDelay);\r\n    timeouts.set(peerId, handle);\r\n  }\r\n  \r\n  return { attempt, clear };\r\n}\r\n","export function createSignalingHandlers({ getState, peerConnections, peersThatLeft, getLocalStream, createPeer, sendSignal, addOrReplaceTrack, clearReconnection, removeRemoteVideo }) {\r\n  return {\r\n    async handleJoin(from) {\r\n      console.log('[Signaling] Handling JOIN from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring JOIN from self');\r\n        return;\r\n      }\r\n      \r\n      // First, clear any reconnection attempts - peer has explicitly rejoined\r\n      clearReconnection(from);\r\n      peersThatLeft.delete(from);\r\n      \r\n      let pc = peerConnections.get(from);\r\n      if (pc) {\r\n        const connectionState = pc.connectionState;\r\n        console.log('[Signaling] Already have peer connection for', from, 'state:', connectionState);\r\n        \r\n        // If connection is still good (connected/connecting), reuse it\r\n        if (connectionState === 'connected' || connectionState === 'connecting') {\r\n          console.log('[Signaling] Reusing existing connection - ensuring tracks are present');\r\n          const stream = getLocalStream();\r\n          if (stream) {\r\n            let needsRenegotiation = false;\r\n            stream.getTracks().forEach(t => {\r\n              const senders = pc.getSenders();\r\n              const existingSender = senders.find(s => s.track && s.track.kind === t.kind);\r\n              if (!existingSender || existingSender.track.id !== t.id) {\r\n                console.log('[Signaling] Track changed, replacing:', t.kind, t.id);\r\n                addOrReplaceTrack(pc, t, stream);\r\n                needsRenegotiation = true;\r\n              }\r\n            });\r\n            \r\n            // Only renegotiate if tracks changed\r\n            if (needsRenegotiation && pc.signalingState === 'stable') {\r\n              console.log('[Signaling] Renegotiating due to track changes');\r\n              const offer = await pc.createOffer();\r\n              await pc.setLocalDescription(offer);\r\n              sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n            }\r\n          }\r\n          return;\r\n        }\r\n        \r\n        // For any other state (disconnected/failed/closed), clean it up and create new connection\r\n        // This handles the case where a peer refreshes - their old connection is stuck in \r\n        // disconnected/failed state, so we need to clean it up when they rejoin\r\n        console.log('[Signaling] Cleaning up existing connection in state:', connectionState);\r\n        clearReconnection(from);\r\n        removeRemoteVideo(from);\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n        pc = null;\r\n      }\r\n      \r\n      if (!pc) {\r\n        try {\r\n          console.log('[Signaling] Creating new peer connection for', from);\r\n          pc = createPeer(from);\r\n          peerConnections.set(from, pc);\r\n          const stream = getLocalStream();\r\n          console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n          if (stream) {\r\n            stream.getTracks().forEach(t => {\r\n              console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n              addOrReplaceTrack(pc, t, stream);\r\n            });\r\n          } else {\r\n            console.warn('[Signaling] No local stream available when handling JOIN');\r\n          }\r\n          console.log('[Signaling] Creating and sending OFFER to', from);\r\n          const offer = await pc.createOffer();\r\n          await pc.setLocalDescription(offer);\r\n          sendSignal({ type: 'OFFER', from: state.userId, to: from, offer: pc.localDescription });\r\n        } catch (err) {\r\n          console.error('[Signaling] Error handling JOIN:', err);\r\n          peerConnections.delete(from);\r\n        }\r\n      }\r\n    },\r\n    async handleOffer(from, offer) {\r\n      console.log('[Signaling] Handling OFFER from', from);\r\n      const state = getState();\r\n      if (from === state.userId) {\r\n        console.log('[Signaling] Ignoring OFFER from self');\r\n        return;\r\n      }\r\n      let pc = peerConnections.get(from);\r\n      if (pc) {\r\n        console.log('[Signaling] Existing peer connection state:', pc.signalingState);\r\n        if (pc.signalingState !== 'closed' && pc.signalingState !== 'stable') {\r\n          console.log('[Signaling] Closing existing peer connection in state:', pc.signalingState);\r\n          try { pc.close(); } catch (e) {}\r\n          peerConnections.delete(from);\r\n          pc = null;\r\n        } else if (pc.signalingState === 'stable') {\r\n          // If stable, this might be a renegotiation - close and recreate\r\n          console.log('[Signaling] Closing stable peer connection for renegotiation');\r\n          try { pc.close(); } catch (e) {}\r\n          peerConnections.delete(from);\r\n          pc = null;\r\n        }\r\n      }\r\n      if (!pc) {\r\n        console.log('[Signaling] Creating new peer connection for', from);\r\n        // Clear any reconnection attempts when receiving an offer\r\n        clearReconnection(from);\r\n        peersThatLeft.delete(from);\r\n        pc = createPeer(from);\r\n        peerConnections.set(from, pc);\r\n      }\r\n      try {\r\n        console.log('[Signaling] Setting remote description, current state:', pc.signalingState);\r\n        await pc.setRemoteDescription(new RTCSessionDescription(offer));\r\n        const stream = getLocalStream();\r\n        console.log('[Signaling] Local stream:', stream, 'tracks:', stream ? stream.getTracks().length : 0);\r\n        if (stream) {\r\n          stream.getTracks().forEach(t => {\r\n            console.log('[Signaling] Adding local track to peer:', t.kind, t.id);\r\n            addOrReplaceTrack(pc, t, stream);\r\n          });\r\n        } else {\r\n          console.warn('[Signaling] No local stream available when handling OFFER');\r\n        }\r\n        console.log('[Signaling] Creating and sending ANSWER to', from);\r\n        const answer = await pc.createAnswer();\r\n        await pc.setLocalDescription(answer);\r\n        sendSignal({ type: 'ANSWER', from: state.userId, to: from, answer: pc.localDescription });\r\n      } catch (err) {\r\n        console.error('[Signaling] Error handling offer:', err.name, err.message);\r\n        console.error('[Signaling] Full error:', err);\r\n        peerConnections.delete(from);\r\n        try { pc.close(); } catch (e) {}\r\n      }\r\n    },\r\n    async handleAnswer(from, answer) {\r\n      console.log('[Signaling] Handling ANSWER from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (!pc) {\r\n        console.warn('[Signaling] Cannot handle ANSWER - no peer connection found for', from);\r\n        return;\r\n      }\r\n      \r\n      console.log('[Signaling] Peer connection state:', {\r\n        signalingState: pc.signalingState,\r\n        connectionState: pc.connectionState,\r\n        iceConnectionState: pc.iceConnectionState\r\n      });\r\n      \r\n      if (pc.signalingState === 'have-local-offer') {\r\n        console.log('[Signaling] Setting remote description from ANSWER');\r\n        try {\r\n          await pc.setRemoteDescription(new RTCSessionDescription(answer));\r\n          console.log('[Signaling] Remote description set successfully');\r\n        } catch (err) {\r\n          console.error('[Signaling] Error handling answer:', err.name, err.message);\r\n          console.error('[Signaling] Full error:', err);\r\n          // If the peer connection is in a bad state, close it and remove it\r\n          if (err.name === 'InvalidStateError' || err.name === 'OperationError') {\r\n            console.log('[Signaling] Closing peer connection due to state error');\r\n            try { pc.close(); } catch (e) {}\r\n            peerConnections.delete(from);\r\n          }\r\n        }\r\n      } else if (pc.signalingState === 'stable') {\r\n        console.log('[Signaling] Received ANSWER but already in stable state (connection:', pc.connectionState + ') - likely duplicate, ignoring');\r\n      } else if (pc.signalingState === 'have-remote-offer') {\r\n        console.warn('[Signaling] Received ANSWER but expecting to send one (have-remote-offer) - might be glare, ignoring');\r\n      } else if (pc.signalingState === 'closed') {\r\n        console.warn('[Signaling] Received ANSWER but peer connection is closed - ignoring');\r\n      } else {\r\n        console.warn('[Signaling] Cannot handle ANSWER - unexpected state:', pc.signalingState);\r\n      }\r\n    },\r\n    async handleIceCandidate(from, candidate) {\r\n      console.log('[Signaling] Handling ICE_CANDIDATE from', from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try {\r\n          await pc.addIceCandidate(new RTCIceCandidate(candidate));\r\n          console.log('[Signaling] ICE candidate added successfully');\r\n        } catch (err) {\r\n          console.warn('[Signaling] Error adding ICE candidate', err);\r\n        }\r\n      } else {\r\n        console.warn('[Signaling] No peer connection found for ICE candidate from', from);\r\n      }\r\n    },\r\n    handleLeave(from) {\r\n      console.log('[Signaling] Handling LEAVE from', from);\r\n      peersThatLeft.add(from);\r\n      const pc = peerConnections.get(from);\r\n      if (pc) {\r\n        try { pc.close(); } catch (e) {}\r\n        peerConnections.delete(from);\r\n      }\r\n      clearReconnection(from);\r\n      removeRemoteVideo(from);\r\n    }\r\n  };\r\n}\r\n","export class URLSync {\r\n  constructor(stateManager, onWatchPageChange, onNavigateToWatch, onLeaveWatch) {\r\n    this.stateManager = stateManager;\r\n    this.urlMonitorInterval = null;\r\n    this.lastUrl = null;\r\n    this.onWatchPageChange = onWatchPageChange || (() => {});\r\n    this.onNavigateToWatch = onNavigateToWatch || (() => {});\r\n    this.onLeaveWatch = onLeaveWatch || (() => {});\r\n    this.handleUrlChange = this.handleUrlChange.bind(this);\r\n  }\r\n  \r\n  handleUrlChange() {\r\n    const currentUrl = window.location.href;\r\n    if (currentUrl !== this.lastUrl) {\r\n      console.log('[URLSync] URL changed from', this.lastUrl, 'to', currentUrl);\r\n      const lastPath = this.lastUrl ? new URL(this.lastUrl).pathname : '';\r\n      const currentPath = new URL(currentUrl).pathname;\r\n      \r\n      // Check if we navigated to a different /watch page or left /watch\r\n      const wasOnWatch = lastPath.startsWith('/watch');\r\n      const wasOnBrowse = lastPath.startsWith('/browse');\r\n      const nowOnWatch = currentPath.startsWith('/watch');\r\n      const watchPageChanged = wasOnWatch && nowOnWatch && lastPath !== currentPath;\r\n      const navigatedToWatch = !wasOnWatch && nowOnWatch;\r\n      const navigatedFromBrowseToWatch = wasOnBrowse && nowOnWatch;\r\n      const leftWatch = wasOnWatch && !nowOnWatch;\r\n      \r\n      this.lastUrl = currentUrl;\r\n      \r\n      // If we navigated from browse to watch, set flag to respect Netflix auto-play\r\n      if (navigatedFromBrowseToWatch) {\r\n        console.log('[URLSync] Navigated from browse to /watch - setting auto-play flag');\r\n        sessionStorage.setItem('tandem_from_browse', 'true');\r\n      }\r\n      \r\n      // If we changed to a different /watch page, reinitialize sync\r\n      if (watchPageChanged) {\r\n        console.log('[URLSync] Watch page changed - triggering sync reinitialization');\r\n        this.onWatchPageChange();\r\n      }\r\n      \r\n      // If we navigated TO a /watch page from elsewhere, initialize sync\r\n      if (navigatedToWatch) {\r\n        console.log('[URLSync] Navigated to /watch page - triggering sync initialization');\r\n        this.onNavigateToWatch();\r\n      }\r\n      \r\n      // If we left a /watch page, teardown sync\r\n      if (leftWatch) {\r\n        console.log('[URLSync] Left /watch page - triggering sync teardown');\r\n        this.onLeaveWatch();\r\n      }\r\n      \r\n      const state = this.stateManager.getState();\r\n      \r\n      // Broadcast all Netflix URL changes to the party\r\n      // This keeps everyone synchronized on browse, title pages, etc.\r\n      if (state.partyActive) {\r\n        console.log('[URLSync] Broadcasting URL change to party:', currentPath);\r\n        this.stateManager.safeSendMessage({ \r\n          type: 'URL_CHANGE', \r\n          url: currentUrl \r\n        });\r\n      }\r\n      \r\n      // If someone leaves /watch, pause the video for everyone\r\n      if (state.partyActive && leftWatch) {\r\n        console.log('[URLSync] Left /watch page - sending pause to all clients');\r\n        this.stateManager.safeSendMessage({ \r\n          type: 'PLAY_PAUSE', \r\n          control: 'pause',\r\n          timestamp: 0\r\n        });\r\n      }\r\n    }\r\n  }\r\n  \r\n  start() { \r\n    this.lastUrl = window.location.href;\r\n    console.log('[URLSync] Starting URL monitoring, current URL:', this.lastUrl);\r\n    \r\n    // Clear any existing interval and listeners\r\n    this.stop();\r\n    \r\n    // Listen for popstate events (back/forward button, pushState)\r\n    window.addEventListener('popstate', this.handleUrlChange);\r\n    \r\n    // Listen for pushState/replaceState by monkey-patching\r\n    const originalPushState = history.pushState;\r\n    const originalReplaceState = history.replaceState;\r\n    \r\n    history.pushState = (...args) => {\r\n      originalPushState.apply(history, args);\r\n      this.handleUrlChange();\r\n    };\r\n    \r\n    history.replaceState = (...args) => {\r\n      originalReplaceState.apply(history, args);\r\n      this.handleUrlChange();\r\n    };\r\n    \r\n    // Also poll as a fallback (in case Netflix uses some other navigation method)\r\n    this.urlMonitorInterval = setInterval(() => {\r\n      this.handleUrlChange();\r\n    }, 500);\r\n  }\r\n  \r\n  stop() {\r\n    console.log('[URLSync] Stopping URL monitoring');\r\n    \r\n    if (this.urlMonitorInterval) { \r\n      clearInterval(this.urlMonitorInterval); \r\n      this.urlMonitorInterval = null; \r\n    }\r\n    \r\n    window.removeEventListener('popstate', this.handleUrlChange);\r\n    \r\n    this.lastUrl = null;\r\n  }\r\n  saveState() {\r\n    const state = this.stateManager.getState();\r\n    if (!state.partyActive) return;\r\n    const existing = this.getRestorationState() || {};\r\n    const payload = {\r\n      roomId: state.roomId,\r\n      currentTime: existing.currentTime || null,\r\n      isPlaying: typeof existing.isPlaying === 'boolean' ? existing.isPlaying : null,\r\n      timestamp: Date.now()\r\n    };\r\n    sessionStorage.setItem('tandem_restore', JSON.stringify(payload));\r\n  }\r\n  clearState() { sessionStorage.removeItem('tandem_restore'); }\r\n  getRestorationState() {\r\n    const stored = sessionStorage.getItem('tandem_restore');\r\n    if (!stored) return null;\r\n    try {\r\n      const state = JSON.parse(stored);\r\n      if (Date.now() - state.timestamp < 30000) { return state; }\r\n    } catch (e) { console.error('[tandem] Failed to parse restoration state:', e); }\r\n    return null;\r\n  }\r\n}\r\n"],"names":["SyncLock","constructor","this","suppressLocalUntil","set","durationMs","Date","now","isActive","attachPlaybackListeners","video","state","isInitializedRef","lock","onPlay","onPause","onSeek","onPositionUpdate","handlePlay","console","log","isInitialized","get","lockActive","handlePause","handleSeeked","positionUpdateInterval","setInterval","window","location","pathname","startsWith","addEventListener","cleanup","clearInterval","MutableRef","value","v","addOrReplaceTrack","pc","track","stream","existingSender","getSenders","find","s","kind","replaceTrack","catch","e","warn","addTrack","wasPartyActive","sessionStorage","getItem","staleContainers","document","querySelectorAll","staleVideos","staleOverlays","staleLocalVideo","getElementById","staleWaitingIndicator","forEach","el","id","remove","stateManager","partyActive","userId","roomId","restoringPartyState","startParty","setItem","stopParty","removeItem","getUserId","getRoomId","getState","isInParty","setRestoringFlag","isExtensionContextValid","chrome","runtime","safeSendMessage","message","callback","type","sendMessage","response","lastError","error","notice","createElement","style","cssText","innerHTML","body","appendChild","uiManager","localPreviewVideo","remoteVideos","Map","remoteStreams","streamMonitorInterval","makeDraggable","element","currentX","currentY","initialX","initialY","isDragging","computedStyle","getComputedStyle","rect","bottom","left","right","getBoundingClientRect","top","clientX","clientY","opacity","preventDefault","maxX","innerWidth","offsetWidth","maxY","innerHeight","offsetHeight","Math","max","min","xPos","yPos","cursor","getRemoteVideos","getRemoteStreams","setLocalPreviewVideo","getLocalPreviewVideo","setStreamMonitorInterval","interval","getStreamMonitorInterval","clearStreamMonitorInterval","attachLocalPreview","removeLocalPreview","autoplay","muted","playsInline","position","width","height","zIndex","border","borderRadius","transform","srcObject","src","URL","createObjectURL","play","err","clearAll","clear","removeConnectionIndicator","showConnectionIndicator","indicator","dot","text","textContent","head","updateConnectionIndicator","status","background","animation","netflixController","injectAPIBridge","script","getURL","documentElement","onload","_sendCommand","command","args","Promise","resolve","handler","detail","removeEventListener","result","setTimeout","dispatchEvent","CustomEvent","pause","seek","timeMs","getCurrentTime","isPaused","setVolume","level","getVolume","getVideoElement","videos","syncManager","netflix","listeners","initialSyncRequestAt","initialSyncWindowMs","remote","shouldAcceptLateSync","onInitialSyncApplied","async","applyRemote","actionName","actionFn","handleRequestSync","fromUserId","respectAutoPlay","currentUrl","href","attemptSyncResponse","attempt","currentTime","currentTimeSeconds","toFixed","targetUserId","isPlaying","url","handleSyncResponse","currentPath","isOnWatch","isOnBrowse","otherIsOnWatch","JSON","stringify","timestamp","waitForLocalResume","i","localTimeMs","r","localPaused","localSeconds","finalPaused","handlePlaybackControl","control","toUpperCase","handleSeek","createRemoteHandlers","setup","waitForVideo","pendingSyncStr","pendingSync","parse","vid","broadcastPlay","broadcastPause","broadcastSeek","broadcastPosition","broadcastAfterResume","resumed","timeoutId","broadcast","source","onSeeked","onTimeUpdate","clearTimeout","then","readyState","onVideoReady","requestSyncWhenReady","teardown","reject","timeout","Error","check","isOnWatchPage","paused","webrtcManager","peerConnections","peersThatLeft","Set","localStream","videoManager","ensureSpinnerStyles","createLoadingSpinner","spinner","className","peerId","getTracks","stop","container","parentElement","delete","domContainer","domElement","overlay","hideWaitingIndicator","add","size","Array","from","keys","existingInDom","has","backgroundColor","display","flexDirection","alignItems","justifyContent","color","fontSize","fontFamily","pointerEvents","fontWeight","activeTracks","filter","t","length","map","substring","join","playVideo","volume","name","checkTracks","parentNode","showReconnecting","hideOverlay","showPlaceholder","showWaitingIndicator","padding","gap","boxShadow","dots","createWaitingDots","letterSpacing","createRemoteVideoManager","reconnectionManager","createPeer","sendSignal","addRemoteVideo","attemptReconnection","clearReconnection","removeRemoteVideo","RTCPeerConnection","iceServers","urls","onicecandidate","event","candidate","to","ontrack","streams","MediaStream","hasVideoInMap","hasVideoInDom","existingVideo","tracks","hasAudio","some","hasVideo","onconnectionstatechange","connectionState","createPeerConnectionFactory","msg","_sendSignal","Object","assign","attempts","timeouts","handle","count","backoffDelay","pow","existing","oldPc","close","offer","createOffer","setLocalDescription","localDescription","createReconnectionManager","signalingHandlers","getLocalStream","handleJoin","needsRenegotiation","signalingState","handleOffer","setRemoteDescription","RTCSessionDescription","answer","createAnswer","handleAnswer","iceConnectionState","handleIceCandidate","addIceCandidate","RTCIceCandidate","handleLeave","createSignalingHandlers","setLocalStream","onLocalStreamAvailable","handleSignal","JOIN","OFFER","ANSWER","ICE","LEAVE","urlSync","onWatchPageChange","onNavigateToWatch","onLeaveWatch","urlMonitorInterval","lastUrl","handleUrlChange","bind","lastPath","wasOnWatch","wasOnBrowse","nowOnWatch","watchPageChanged","navigatedToWatch","navigatedFromBrowseToWatch","leftWatch","start","originalPushState","history","pushState","originalReplaceState","replaceState","apply","saveState","getRestorationState","payload","clearState","stored","videoElementMonitor","startVideoElementMonitoring","videoId","searchParams","title","toString","success","checkJoinFromLink","restorationState","navigator","mediaDevices","getUserMedia","audio","onMessage","addListener","request","sender","sendResponse","audioTrack","getAudioTracks","videoTrack","getVideoTracks","audioEnabled","enabled","videoEnabled","hasStream","newEnabled","PopStateEvent"],"ignoreList":[],"sourceRoot":""}