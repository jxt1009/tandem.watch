{"version":3,"file":"background.js","mappings":"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","sources":["webpack://toperparty/./chrome-extension/background.js","webpack://toperparty/webpack/bootstrap","webpack://toperparty/webpack/runtime/compat get default export","webpack://toperparty/webpack/runtime/define property getters","webpack://toperparty/webpack/runtime/hasOwnProperty shorthand"],"sourcesContent":["// background.js - Manages WebSocket connection and media streams\n\nlet ws = null;\nlet localStream = null;\nlet isConnected = false;\nlet roomId = null;\nlet userId = generateUserId();\n\n// WebRTC Configuration\nconst rtcConfig = {\n  iceServers: [\n    { urls: ['stun:stun.l.google.com:19302'] },\n    { urls: ['stun:stun1.l.google.com:19302'] }\n  ]\n};\n\nfunction generateUserId() {\n  return 'user_' + Math.random().toString(36).substr(2, 9);\n}\n\n// Initialize connection\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  console.log('Background received message:', request.type);\n  \n  if (request.type === 'START_PARTY') {\n    startParty(request.roomId).then(() => {\n      sendResponse({ success: true });\n    }).catch(err => {\n      sendResponse({ success: false, error: err.message });\n    });\n    return true; // Keep channel open for async response\n  }\n\n  if (request.type === 'STOP_PARTY') {\n    stopParty();\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'RESTORE_PARTY') {\n    console.log('Restoring party after navigation:', request.roomId);\n    \n    // Force a clean slate by stopping any existing party session first (Reset behavior)\n    // Pass false to skip sending LEAVE, as the tab already sent it via beforeunload\n    // and we don't want to race with the new JOIN.\n    console.log('Performing full party reset (Stop -> Start) for restoration');\n    stopParty(false);\n\n    // Always generate a new userId for the restored session to ensure clean WebRTC state\n    userId = generateUserId();\n    \n    startParty(request.roomId).then(() => {\n      sendResponse({ success: true });\n    }).catch(err => {\n      console.error('Failed to restore party:', err);\n      sendResponse({ success: false, error: err.message });\n    });\n    return true; // Keep channel open for async response\n  }\n\n  if (request.type === 'GET_STATUS') {\n    console.log('Sending status:', { isConnected, roomId, userId, hasLocalStream: !!localStream });\n    sendResponse({\n      isConnected,\n      roomId,\n      userId,\n      hasLocalStream: !!localStream\n    });\n    return true;\n  }\n\n  if (request.type === 'PLAY_PAUSE') {\n    broadcastMessage({\n      type: 'PLAYBACK_CONTROL',\n      control: request.control,\n      timestamp: request.timestamp,\n      userId\n    });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SYNC_TIME') {\n    broadcastMessage({\n      type: 'SYNC_PLAYBACK',\n      currentTime: request.currentTime,\n      isPlaying: request.isPlaying,\n      userId\n    });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SEEK') {\n    console.log('Broadcasting SEEK command:', request.currentTime);\n    broadcastMessage({\n      type: 'SEEK',\n      currentTime: request.currentTime,\n      isPlaying: request.isPlaying,\n      userId\n    });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'URL_CHANGE') {\n    console.log('Broadcasting URL change:', request.url);\n    broadcastMessage({\n      type: 'URL_CHANGE',\n      url: request.url,\n      userId\n    });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'REQUEST_SYNC') {\n    console.log('Broadcasting REQUEST_SYNC from', userId);\n    broadcastMessage({\n      type: 'REQUEST_SYNC',\n      userId\n    });\n    sendResponse({ success: true });\n  }\n\n  if (request.type === 'SYNC_RESPONSE') {\n    // Forward response only to the requester\n    console.log('Forwarding SYNC_RESPONSE to', request.targetUserId);\n    if (ws && ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify({\n        type: 'SYNC_RESPONSE',\n        to: request.targetUserId,\n        currentTime: request.currentTime,\n        isPlaying: request.isPlaying,\n        fromUserId: userId\n      }));\n    }\n    sendResponse({ success: true });\n  }\n\n  // Relay signaling messages from content scripts (offers/answers/ice)\n  if (request.type === 'SIGNAL_SEND') {\n    const msg = Object.assign({}, request.message || {});\n    // ensure identifying info is present\n    msg.userId = msg.userId || userId;\n    msg.roomId = msg.roomId || roomId;\n    if (ws && ws.readyState === WebSocket.OPEN) {\n      try {\n        ws.send(JSON.stringify(msg));\n        sendResponse({ success: true });\n      } catch (err) {\n        sendResponse({ success: false, error: err.message });\n      }\n    } else {\n      sendResponse({ success: false, error: 'Not connected to signaling server' });\n    }\n    return true;\n  }\n});\n\n// Start party mode\nasync function startParty(inputRoomId) {\n  roomId = inputRoomId || 'default_room_' + Date.now();\n\n  // Request media stream from content script\n  return new Promise((resolve, reject) => {\n    try {\n      // First, try to get media access through the content script\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        if (tabs.length === 0) {\n          // If no Netflix tab, we can still try to get media in the background\n          getMediaStreamInBackground()\n            .then(() => connectToSignalingServer(resolve, reject))\n            .catch(reject);\n        } else {\n          // Ask the Netflix content script to get media\n          chrome.tabs.sendMessage(tabs[0].id, {\n            type: 'REQUEST_MEDIA_STREAM'\n          }, (response) => {\n            if (chrome.runtime.lastError) {\n              console.warn('Content script not ready, trying background:', chrome.runtime.lastError);\n              getMediaStreamInBackground()\n                .then(() => connectToSignalingServer(resolve, reject))\n                .catch(reject);\n              return;\n            }\n            \n            if (response && response.success) {\n              console.log('Got media stream from content script');\n              connectToSignalingServer(resolve, reject);\n            } else {\n              // Fallback to background attempt\n              console.warn('Content script failed to get media, trying background');\n              getMediaStreamInBackground()\n                .then(() => connectToSignalingServer(resolve, reject))\n                .catch(reject);\n            }\n          });\n        }\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n}\n\n// Try to get media stream in background (for testing without Netflix tab)\nasync function getMediaStreamInBackground() {\n  try {\n    // This will fail in service worker, but we set a flag so we can continue\n    // In production, the content script will handle this\n    console.log('Note: Media stream will be obtained from Netflix page');\n    return;\n  } catch (err) {\n    console.error('Could not get media in background:', err);\n    throw err;\n  }\n}\n\n// Connect to signaling server\nfunction connectToSignalingServer(resolve, reject) {\n  try {\n    ws = new WebSocket('ws://watch.toper.dev/ws');\n\n    ws.onopen = () => {\n      console.log('Connected to signaling server');\n      isConnected = true;\n\n      // Send join message\n      ws.send(JSON.stringify({\n        type: 'JOIN',\n        userId,\n        roomId,\n        timestamp: Date.now()\n      }));\n\n      // Notify all tabs\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, {\n            type: 'PARTY_STARTED',\n            userId,\n            roomId\n          }).catch(() => {}); // Ignore errors if content script not ready\n        });\n      });\n\n      resolve();\n    };\n\n    ws.onmessage = (event) => {\n      handleSignalingMessage(event.data);\n    };\n\n    ws.onerror = (error) => {\n      console.error('WebSocket error:', error);\n      reject(new Error('Failed to connect to signaling server'));\n    };\n\n    ws.onclose = () => {\n      console.log('Disconnected from signaling server');\n      isConnected = false;\n      cleanup();\n    };\n  } catch (err) {\n    reject(err);\n  }\n}\n\n// Stop party mode\nfunction stopParty(sendLeaveSignal = true) {\n  if (ws) {\n    if (sendLeaveSignal) {\n      try {\n        ws.send(JSON.stringify({\n          type: 'LEAVE',\n          userId,\n          roomId,\n          timestamp: Date.now()\n        }));\n      } catch (e) {\n        console.warn('Error sending LEAVE signal:', e);\n      }\n    }\n    ws.close();\n    ws = null;\n  }\n\n  cleanup();\n  isConnected = false;\n\n  // Notify all tabs\n  chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n    tabs.forEach(tab => {\n      chrome.tabs.sendMessage(tab.id, {\n        type: 'PARTY_STOPPED'\n      }).catch(() => {});\n    });\n  });\n}\n\n// Cleanup resources\nfunction cleanup() {\n  if (localStream) {\n    localStream.getTracks().forEach(track => track.stop());\n    localStream = null;\n  }\n}\n\n// Handle signaling messages\nasync function handleSignalingMessage(data) {\n  try {\n    const message = JSON.parse(data);\n\n    // Forward signaling payloads to all Netflix tabs so content scripts can handle WebRTC\n    chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n      tabs.forEach(tab => {\n        chrome.tabs.sendMessage(tab.id, { type: 'SIGNAL', message }).catch(() => {});\n      });\n    });\n\n    // Additionally handle playback control / sync specially (apply immediately)\n    if (message.type === 'PLAYBACK_CONTROL' && message.userId !== userId) {\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'APPLY_PLAYBACK_CONTROL', \n            control: message.control, \n            timestamp: message.timestamp,\n            fromUserId: message.userId \n          }).catch(() => {});\n        });\n      });\n    }\n\n    if (message.type === 'SYNC_PLAYBACK' && message.userId !== userId) {\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'APPLY_SYNC_PLAYBACK', \n            currentTime: message.currentTime, \n            isPlaying: message.isPlaying,\n            timestamp: message.timestamp,\n            fromUserId: message.userId \n          }).catch(() => {});\n        });\n      });\n    }\n\n    if (message.type === 'SEEK' && message.userId !== userId) {\n      console.log('Forwarding SEEK command from remote user');\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'APPLY_SEEK', \n            currentTime: message.currentTime, \n            isPlaying: message.isPlaying,\n            fromUserId: message.userId \n          }).catch(() => {});\n        });\n      });\n    }\n\n    if (message.type === 'URL_CHANGE' && message.userId !== userId) {\n      console.log('Received URL change from remote user:', message.url);\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'APPLY_URL_CHANGE', \n            url: message.url,\n            fromUserId: message.userId \n          }).catch(() => {});\n        });\n      });\n    }\n\n    if (message.type === 'REQUEST_SYNC' && message.userId !== userId) {\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'HANDLE_REQUEST_SYNC', \n            fromUserId: message.userId \n          }).catch(() => {});\n        });\n      });\n    }\n\n    if (message.type === 'SYNC_RESPONSE' && message.to === userId) {\n      chrome.tabs.query({ url: 'https://www.netflix.com/*' }, (tabs) => {\n        tabs.forEach(tab => {\n          chrome.tabs.sendMessage(tab.id, { \n            type: 'APPLY_SYNC_RESPONSE', \n            currentTime: message.currentTime,\n            isPlaying: message.isPlaying,\n            fromUserId: message.fromUserId \n          }).catch(() => {});\n        });\n      });\n    }\n  } catch (err) {\n    console.error('Error handling signaling message:', err);\n  }\n}\n\n// Note: WebRTC peer connection management is handled in the content script.\n\n// Broadcast message to all peers\nfunction broadcastMessage(message) {\n  if (ws && ws.readyState === WebSocket.OPEN) {\n    ws.send(JSON.stringify(message));\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))"],"names":["ws","localStream","isConnected","roomId","userId","generateUserId","Math","random","toString","substr","async","startParty","inputRoomId","Date","now","Promise","resolve","reject","chrome","tabs","query","url","length","getMediaStreamInBackground","then","connectToSignalingServer","catch","sendMessage","id","type","response","runtime","lastError","console","warn","success","log","err","error","WebSocket","onopen","send","JSON","stringify","timestamp","forEach","tab","onmessage","event","data","message","parse","control","fromUserId","currentTime","isPlaying","to","handleSignalingMessage","onerror","Error","onclose","cleanup","stopParty","sendLeaveSignal","e","close","getTracks","track","stop","broadcastMessage","readyState","OPEN","onMessage","addListener","request","sender","sendResponse","hasLocalStream","targetUserId","msg","Object","assign","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"ignoreList":[],"sourceRoot":""}